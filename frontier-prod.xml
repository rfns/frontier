<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Frontier.AbstractSerializer">
<Abstract>1</Abstract>
<IncludeCode>frontier,%ZEN.Utils</IncludeCode>
<TimeCreated>64553,37866.500056</TimeCreated>

<Method name="SerializeToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>*str:%Stream.Object="",arguments...</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new oldMnemonic, alreadyRedirected, sc
  
  set sc = $$$OK
  set isRedirected = 0
  
  set str = ##class(%Stream.TmpBinary).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
  set initIO = $io
  
  try {    
    use $io::("^"_$zname)
    
    do ##class(%Device).ReDirectIO(1)
    set isRedirected = 1
    set sc = ..Serialize(arguments...)
    do str.Rewind()
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }   
  
  if oldMnemonic '= "" {
    use initIO::(oldMnemonic)
  } else {
    use oldMnemonic
  }
  
  do ##class(%Device).ReDirectIO(alreadyRedirected)  
      
  return sc
  
wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>

<Method name="HandleJSONWord">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String</FormalSpec>
<Implementation><![CDATA[
  if value?1(1"true",1"false",1"null") {
    return value    
  }
  return $$$ZENJSONVALUE(value, "s")
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.ArgumentDescription">
<Super>%RegisteredObject</Super>
<TimeCreated>64492,37806.502663</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Alias">
<Type>%String</Type>
</Property>

<Property name="DefaultValue">
<Type>%String</Type>
</Property>

<Property name="HasDefaultValue">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Arity">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<Property name="Index">
<Type>%Integer</Type>
<Required>1</Required>
</Property>
</Class>


<Class name="Frontier.Authentication.BasicStrategy">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64553,59181.195484</TimeCreated>

<Property name="Realm">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Validator">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Required">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Realm = config.realm
  set ..Validator = config.validator
  set ..Required = config.required
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set found = 0
  set httpStatus = ""
  set authHeader = request.GetCgiEnv("HTTP_AUTHORIZATION")
  
  if authHeader = "" {
    if '..Required set ..Next = 1 return $$$OK
    return $$CreateError("You must be authenticated to access this resource.")
  }
  
  if $extract(authHeader, 1, 5) '= "Basic" {
    return $$CreateError("Malformed authorization header.", "400 Bad Request")
  }

  set credentials = $System.Encryption.Base64Decode($piece(authHeader, " ", 2))
    
  set userName = $piece(credentials, ":")
  set password = $piece(credentials, ":", 2)  
  
  if ..Validator '= "" {
    set class = $piece(..Validator, ":")
    set method = $piece(..Validator, ":", 2)
    try {
      set sc = $classmethod(class, method, userName, password, .found, .httpStatus, .user)
    } catch ex {
      set sc = ex.AsStatus()
    }
  } else {
    return $$CreateError("Credentials validator was not specified", "500 Internal Server Error")
  }
  
  if $$$ISERR(sc) {
    return $$CreateError(sc, httpStatus, 1)
  }
  
  if httpStatus = "" {
    set httpStatus = "500 Internal Server Error"
  }
  
  if 'found {
    return $$CreateError("Unknown user or password.", "403 Forbidden")  
  }  
  
  return sc
  
CreateError(message, status="401 Unauthorized", isStatus=0)
  set response.Status = status
  if 'isStatus return $$$ERROR($$$GeneralError, message) 
  return message
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "Basic realm="""_..Realm_""""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Manager">
<Super>%RegisteredObject</Super>
<TimeCreated>64553,52230.315441</TimeCreated>

<Property name="Strategies">
<Type>Frontier.Authentication.Strategy</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="ScopeSeparator">
<Type>%String</Type>
<InitialExpression>" "</InitialExpression>
</Property>

<Property name="Verified">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  return $$$OK
]]></Implementation>
</Method>

<Method name="ScopeSeparatorSet">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  set i%ScopeSeparator = $get(value, ",")
]]></Implementation>
</Method>

<Method name="AddStrategy">
<FormalSpec>strategy:Frontier.Authentication.Strategy</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Verified = 0
  $$$QuitOnError(..Strategies.Insert(strategy))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Verified = 0
  return ..Strategies.Clear()
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set totalStrategies = ..Strategies.Count()
  set strategy = ""

  try {
    for i=1:1:totalStrategies {
      set strategy = ..Strategies.GetAt(i)
      set sc = strategy.Verify(..Session, ..Request, ..Response, .user, resourceScope)
      if $$$ISOK(sc) {
        if strategy.Next = 1 {
          continue
        } else {
          set ..Verified = 1
          return sc
        }
      } else {
        do SetChallenge(strategy)
        return sc
      }
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  
  if totalStrategies > 0 && (..Verified '= 1) {
    do SetChallenge(strategy)
  }
  
  return sc
  
SetChallenge(strategy)
  do strategy.GetChallenge(..Session, ..Request, ..Response, .challenge)
  do ..Response.SetHeader("WWW-Authenticate", challenge)
  quit
]]></Implementation>
</Method>

<Method name="CheckResourceScope">
<FormalSpec>resourceScope:%String="",authenticationScope:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if resourceScope '= "" return $lf($lfs(authenticationScope, ..ScopeSeparator), resourceScope) > 0
  return 1
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Strategy">
<Super>%RegisteredObject</Super>
<TimeCreated>64553,51285.209032</TimeCreated>

<Property name="Next">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="NextSet">
<FormalSpec>value:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set i%Next = +value
	return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$ERROR($$$MethodNotImplemented, "GetChallenge")
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Context">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,31617.993909</TimeCreated>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="RequestURL">
<Type>%String</Type>
</Property>

<Property name="Method">
<Type>%String</Type>
</Property>

<Property name="ClassName">
<Type>%String</Type>
</Property>

<Property name="ArgumentValues">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Stack">
<Type>%Stream.GlobalCharacter</Type>
<Internal>1</Internal>
</Property>

<Property name="IncludeStack">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Error">
<Type>%Status</Type>
<Internal>1</Internal>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="SQL">
<Type>Frontier.SQL</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ReporterManager">
<Type>Frontier.Reporter.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="AuthenticationManager">
<Type>Frontier.Authentication.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Data">
<Type>%DynamicObject</Type>
</Property>

<Property name="ThrownByApplication">
<Type>%Boolean</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DirectWrite">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="User">
<Type>%DynamicObject</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PropertyFormatter">
<Type>Frontier.PropertyFormatter</Type>
</Property>

<Property name="StrictQueryParameters">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="RouteParameters">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Debug">
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,debug:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  set i%Debug = debug
  set i%SQL = ##class(Frontier.SQL).%New()
  set i%ReporterManager = ##class(Frontier.Reporter.Manager).%New($this)
  set i%AuthenticationManager = ##class(Frontier.Authentication.Manager).%New(..Session, ..Request, ..Response)
  set i%ArgumentValues = 0   
  set ..Data = {} 
  set ..Response.ContentType = "application/json"
  return $$$OK
]]></Implementation>
</Method>

<Method name="Raw">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/plain")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsRaw">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/plain"
]]></Implementation>
</Method>

<Method name="HTML">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/html")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsHTML">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/html"
]]></Implementation>
</Method>

<Method name="JSON">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "application/json")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsJSON">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "application/json"
]]></Implementation>
</Method>

<Method name="Status">
<FormalSpec>statusCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.Status = statusCode
  return $$$OK
]]></Implementation>
</Method>

<Method name="ThrowException">
<FormalSpec>message:%String,httpStatus:%String="500 Internal Server Error",parameters...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(parameters) set parameters = 0
  set args = 2 + parameters
  set args(1) = $$$GeneralError
  set args(2) = message
  
  set ..Response.Status = httpStatus
  
  for i=1:1:parameters set args(2+i) = parameters(i)
  set i%ThrownByApplication = 1
  throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(args...))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.DevTools.FakeAgent">
<Super>%RegisteredObject</Super>
<TimeCreated>64742,52062.176004</TimeCreated>

<Property name="Cache">
<Type>%String</Type>
</Property>

<Property name="Namespace">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Namespace = $namespace
  set ..Cache = "^|"""_..Namespace_"""|Frontier.DevTools.FakeAgent"
  return $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill @i%Cache
  return $$$OK
]]></Implementation>
</Method>

<Method name="EnsureRequestExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*request:Frontier.DevTools.FakeRequest,url:%String,method:%String,payload:%DynamicObject,auth:%String="Basic Zm9vOmJhcg=="</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(%Net.URLParser).Parse(url, .components)
  do ParseQueryString(components("query"), .data)
  
  if '$data(request) || ($data(request) && '$isobject(request)) {
    set request = ##class(Frontier.DevTools.FakeRequest).%New()
  }
  
  set request.URL = components("path")
  set request.CgiEnvs("CONTENT_LENGTH") = 0
  set request.CgiEnvs("CONTENT_TYPE") = "application/json; charset=utf-8"
  set request.CgiEnvs("HTTP_ACCEPT") = "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"
  set request.CgiEnvs("HTTP_ACCEPT_ENCODING") = "gzip, deflate"
  set request.CgiEnvs("HTTP_ACCEPT_LANGUAGE") = "en-US;q=0.8,en;q=0.7"
  set request.CgiEnvs("HTTP_AUTHORIZATION") = auth 
  set request.CgiEnvs("HTTP_HOST") = "localhost:57772" 
  set request.CgiEnvs("HTTP_USER_AGENT") = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36 FakeAgent/1.0"
  set request.CgiEnvs("QUERY_STRING") = $get(components("query"))  
  set request.CgiEnvs("REQUEST_METHOD") = $$$ucase(method)
  set request.CgiEnvs("REQUEST_SCHEME") = "http"
  set request.CgiEnvs("REQUEST_URI") = components("path")  
  set request.CgiEnvs("SERVER_NAME") = "localhost"
  set request.CgiEnvs("SERVER_PORT") = 57772  
  set request.CgiEnvs("SERVER_PROTOCOL") = "HTTP/1.1"
  set request.Content = ##class(%Stream.GlobalCharacter).%New()  
  if $isobject(payload) do request.Content.Write(payload.%ToJSON())  
  if $order(data("")) '= "" merge request.Data = data
  
  return $$$OK
  
ParseQueryString(qs, data)
  if qs = "" quit
  
  set qp = $lfs(qs, "&")
  
  for i=1:1:$ll(qp) {
    set key = $piece($lg(qp, i), "=", 1)
    set value = $piece($lg(qp, i), "=", 2)
    if key '= "" && (value '= "") set data(key, 1) = value
  }  
  quit
]]></Implementation>
</Method>

<Method name="DispatchRequestAndRespondToStream">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>dispatcherClass:%String,url:%String,httpMethod:%String,*str:%Stream.Object</FormalSpec>
<Private>1</Private>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  new %frontier  
  set %frontier = ##class(Frontier.Context).%New(%session, %request, %response, 1)

  new oldMnemonic, alreadyRedirected, sc
  
  set sc = $$$OK
  set isRedirected = 0
  
  set str = ##class(%Stream.GlobalCharacter).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
  set initIO = $io
  
  try {    
    use $io::("^"_$zname)
    
    do ##class(%Device).ReDirectIO(1)
    set isRedirected = 1
    set sc = $classmethod(dispatcherClass, "DispatchRequest", url, httpMethod)
    do str.Rewind()
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }
     
  
  if oldMnemonic '= "" {
    use initIO::(oldMnemonic)
  } else {
    use oldMnemonic
  }
  
  do ##class(%Device).ReDirectIO(alreadyRedirected)  
      
  return sc
  
wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>

<Method name="ForgeRequest">
<FormalSpec>url:%String,method:%String="GET",payload:%DynamicAbstractObject={{}},auth:%String="",*sc:%Status=$$$OK</FormalSpec>
<PublicList>%session,%response</PublicList>
<ReturnType>%Stream.GlobalBinary</ReturnType>
<Implementation><![CDATA[
   
  new %request, %session, %response
  
  // Makes sure that any attempts to change the namespace internally ends up in the original one.
  set fromNamespace = ..Namespace
  set str = "" 
  
  set %session = ##class(%CSP.Session).%New(-1, 0)
  set %response = ##class(%CSP.Response).%New()
      
  try {    
    set urlWithInitialSlash = $select($extract(url) '= "/" : "/"_url, 1: url)
    set appInfo = ..GetApplicationInfoFromUrl(urlWithInitialSlash)
    do ..EnsureRequestExists(.%request, url, method, payload, auth)
    set %request.Application = appInfo.Name
    $$$ThrowOnError(..DispatchRequestAndRespondToStream(appInfo.DispatchClass, %request.URL, method, .str))
  } catch ex {    
    set sc = ex.AsStatus()
    set ^mtempFrontier("err", $i(i)) = sc
    if '$isobject(str) set str = ##class(%Stream.GlobalBinary).%New()
  }
  kill %request, %session, %response
  
  set $namespace = fromNamespace
  
  return str
]]></Implementation>
</Method>

<Method name="GetApplicationInfoFromUrl">
<FormalSpec>url:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
   
  #define APPCACHE @i%Cache
  
  // Cache matches to prevent roundtrips to %SYS.
  if $data($$$APPCACHE) {
    set index = $lf($$$APPCACHE, url)
    if index > 0 return $$ListToJSON(index)
  }
        
  set $namespace = "%SYS"
    
  set result = {}
  
  // Revert the ordering so that longer are considered first, note that the longer the path is higher is similarity with the url.
  set rows = ##class(%SQL.Statement).%ExecDirect(, "SELECT TOP 1 Name, DispatchClass FROM SECURITY.APPLICATIONS WHERE ? %STARTSWITH Name ORDER BY LEN(Name) DESC", url)
  if rows.%Next() {
    set $list($$$APPCACHE, *+1) = url
    set index = $ll($$$APPCACHE)
    set $list($$$APPCACHE, *+1) = rows.%Get("Name")    
    set $list($$$APPCACHE, *+1) = rows.%Get("DispatchClass")
    set result = $$ListToJSON(index)
  }
  
  set $namespace = ..Namespace
  
  return result
  
ListToJSON(urlIndex)
  return {
    "Name": ($lg($$$APPCACHE, urlIndex + 1)),
    "DispatchClass": ($lg($$$APPCACHE, urlIndex + 2))
  }
]]></Implementation>
</Method>

<Method name="Request">
<ClassMethod>1</ClassMethod>
<FormalSpec>url:%String,method:%String="GET",payload:%DynamicAbstractObject={{}},auth:%String="",outputToDevice:%Boolean=0,*sc:%Status=$$$OK</FormalSpec>
<ReturnType>%Stream.GlobalBinary</ReturnType>
<Implementation><![CDATA[
  set agent = ..%New()
  if outputToDevice = 1 {
    set str = agent.ForgeRequest(url, method, payload, auth, .sc)
    do str.OutputToDevice()
  } else {
    return agent.ForgeRequest(url, method, payload, auth, .sc)
  }  
  return str
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.DevTools.FakeRequest">
<Super>%RegisteredObject</Super>
<TimeCreated>64742,52504.324916</TimeCreated>

<Property name="Data">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="CgiEnvs">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="URL">
<Type>%String</Type>
</Property>

<Property name="Method">
<Type>%String</Type>
</Property>

<Property name="Application">
<Type>%String</Type>
</Property>

<Property name="Content">
<Type>%Stream.Object</Type>
</Property>

<Method name="GetCgiEnv">
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $get(i%CgiEnvs(name))
]]></Implementation>
</Method>

<Method name="Get">
<FormalSpec>name:%String,default:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $get(i%Data(name), default)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Marshaller">
<Super>%RegisteredObject</Super>
<TimeCreated>64502,32993.705412</TimeCreated>

<Property name="Cache">
<Type>%DynamicObject</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Properties">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="DropCyclicReferences">
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$OK
]]></Implementation>
</Method>

<Method name="PropertiesSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Properties = $lfs(value)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Marshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicAbstractObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  if $isobject(object) {
    set type = $classname(object)
    if ##class(Frontier.Types).IsCollection(type) return marshaller.MakeDynamicCollection(object, .dynamicObject)
    if ##class(Frontier.Types).IsDynamic(type) return marshaller.MarshallPartial(object, .dynamicObject)
    if ##class(Frontier.Types).IsInstantiable(type) return marshaller.MakeDynamicObject(object, .dynamicObject)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="MarshallPartial">
<FormalSpec>dynamicInstance:%DynamicAbstractObject,marshalledObject:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set iterator = dynamicInstance.%GetIterator()
  set marshalledObject = $System.OBJ.New($classname(dynamicInstance))
  set dynamicValueResult = ""
  
  while iterator.%GetNext(.key, .value) {
    set dynamicValueResult = value
    if $isobject(value) {
      set valueType = $classname(value)
      set isDynamic = ##class(Frontier.Types).IsDynamic(valueType)
      set isStream = ##class(Frontier.Types).IsStream(valueType)
      set isSQLProvider = ##class(Frontier.Types).IsSQLProvider(valueType)
      if isDynamic {
        set sc = ..MarshallPartial(value, .dynamicValueResult)       
      } elseif 'isStream && 'isSQLProvider {
        set sc = ..Marshall(value, .dynamicValueResult)
      }
      if $$$ISERR(sc) return sc
    }
    do marshalledObject.%Set(key, dynamicValueResult)
  }
  return sc
]]></Implementation>
</Method>

<Method name="MarshallCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%RegisteredObject,*dynamicCollection:%DynamicObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  quit marshaller.MakeDynamicCollection(collection, .dynamicCollection)
]]></Implementation>
</Method>

<Method name="MakeDynamicObject">
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicObject="",parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK     
  
  // Temporary table to reuse processed instances.
  if $data(i%Cache(object)) {
    quit $$$OK
  } else {
    set dynamicObject = ##class(%DynamicObject).%New()
    set i%Cache(object) = dynamicObject
  }
    
  set isSameObject = 0
  set affectedProperties = ""
  set classDescriptors = ##class(%Dictionary.CompiledClass).%OpenId($classname(object))
  
  if $lv(..Properties) && (..Properties '= "") {
    set affectedProperties = ##class(%ListOfObjects).%New()
    for i=1:1:classDescriptors.Properties.Count() {
      set propertyDescriptors = classDescriptors.Properties.GetAt(i)
      if $lf(..Properties, propertyDescriptors.Name) {
        set sc = affectedProperties.Insert(propertyDescriptors)
      }
    }
  } else {
    set affectedProperties = classDescriptors.Properties
  }  
    
  for i=1:1:affectedProperties.Count() {    
    set propertyDescriptors = affectedProperties.GetAt(i)    
    if '$isobject(propertyDescriptors) continue    
    if propertyDescriptors.MultiDimensional || propertyDescriptors.Private || propertyDescriptors.Internal || ($extract(propertyDescriptors.Name) = "%") continue    
    if $isobject(parentObject) && ($classname(parentObject) = propertyDescriptors.Type) && 
      (parentKey = propertyDescriptors.Name) && (propertyDescriptors.Cardinality '= "") {
      // Prevents the buffer from overflowing by skipping parent relationship serialization.
      // DO NOT DISABLE THIS FLAG WHEN SERIALIZING TO JSON!
      if '..DropCyclicReferences set $property(dynamicObject, parentKey) = i%Cache(parentObject)
      continue
    }
    set jsonDataFormat = ##class(Frontier.Types).GetJSONDataFormat(propertyDescriptors.Type)
    set value = $property(object, propertyDescriptors.Name)
    if $isobject(value) {
      if value.%IsA("%RelationshipObject") {
        set parentObject = object               
        set parentKey = propertyDescriptors.Inverse
      }
      if propertyDescriptors.Collection = "" {        
        if value.%Extends("%Stream.Object") {
          set dynamicChild = $System.OBJ.New($classname(value))
          set sc = dynamicChild.CopyFrom(value)
          if $$$ISERR(sc) quit
        } else {          
          set sc = ..MakeDynamicObject(value, .dynamicChild)
        }        
      } else {
        set sc = ..MakeDynamicCollection(value, .dynamicChild, parentKey, parentObject)          
      }
      if $$$ISERR(sc) quit      
      //set $property(dynamicObject, propertyDescriptors.Name) = dynamicChild
      if $isobject(dynamicChild) do dynamicObject.%Set(propertyDescriptors.Name, dynamicChild)
      else  do dynamicObject.%Set(propertyDescriptors.Name, "", jsonDataFormat)
    } else {
      set internalValue = $property(object, propertyDescriptors.Name)
      set d = propertyDescriptors.Type
      if jsonDataFormat '= "null" {
        do dynamicObject.%Set(propertyDescriptors.Name, internalValue, jsonDataFormat)
      } else {
        do dynamicObject.%Set(propertyDescriptors.Name, internalValue)
      }
      if ##class(%Dictionary.CompiledMethod).%ExistsId(propertyDescriptors.Type_"||LogicalToDisplay") {                
        set externalValue = $classmethod(propertyDescriptors.Type, "LogicalToDisplay", internalValue)
        if externalValue '= internalValue {
          set $property(dynamicObject, propertyDescriptors.Name_"__x") = externalValue
        }
      }
    }      
  }  
  if object.%Extends("%Persistent") {
    if $lf(..Properties, "__id__") || (..Properties = "") {
      set id = object.%Id()
      if id '= "" set $property(dynamicObject, "__id__") = object.%Id()
    }
  }      
  quit sc
]]></Implementation>
</Method>

<Method name="MakeDynamicCollection">
<FormalSpec>collection:%Collection.Super,*dynamicCollection:%String,parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK   
  set startOffset = 0
  set cyclicReferenceTrap = 0
      
  if collection.%IsA("%Collection.AbstractList") || collection.%IsA("%RelationshipObject") {
    set startOffset = 1
    set dynamicCollection = []
  } else {
    set dynamicCollection = {}
  }
   
  set key = ""
  set item = collection.GetNext(.key)
  
  while key {  
    if $isobject(item) {
      if item.%IsA("%Collection.AbstractIterator") {
        set sc = ..MakeDynamicCollection(item , .value)
      } else {
        set sc = ..MakeDynamicObject(item, .value, parentKey, parentObject)
        set cyclicReferenceTrap = (value = "")
      }
    } else {
      set value = item
    }
    if 'cyclicReferenceTrap do dynamicCollection.%Set(key - startOffset, value)    
    if $$$ISERR(sc) quit
    
    set item = collection.GetNext(.key)
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Serializer">
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64531,58689.528672</TimeCreated>

<Method name="Serialize">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,depth:%String=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set results = ""
  set isArray = ##class(Frontier.Types).IsDynamicArray($classname(dynamic))    
  
  if isArray {
    write "["
  } else {
    write "{"
  }
  
  set iterator = dynamic.%GetIterator()   
  set comma = ""  
  
  while iterator.%GetNext(.key, .value) {   
    write comma
    set comma = ","
    set propertyName = key
    set type = dynamic.%GetTypeOf(key)
    
    if type = "null" && (value = "") {
      set value = "null"
    } elseif type = "boolean" {
      set value = $$$FormatBoolean(value)
    }
    
    if $isobject(propertyFormatter) {
      set propertyName = propertyFormatter.Format(propertyName, depth)
    }
    
    if 'isArray {
      write $$$ZENJSONPROP(propertyName, "s")_":"
    }
    
    if $isobject(value) {
      set type = $classname(value)
      if ##class(Frontier.Types).IsDynamic(type) {         
        set sc = $$$ADDSC(sc, ..Serialize(value, depth, propertyFormatter))
      } elseif ##class(Frontier.Types).IsStream(type) {
        write $c(34)
        do WriteEscaped(value)
        write $c(34)        
      } elseif ##class(Frontier.Types).IsSQLProvider(type) {
        if 'value.StatementExecuted set sc = value.Execute()
        if $$$ISERR(sc) quit
        $$$ThrowOnError(##class(Frontier.SQL.Serializer).Serialize(value.Results, value.Metadata, depth, propertyFormatter))
      }
    } else {
      write ..HandleJSONWord(value)
    }    
  }
  
  $$$QuitOnError(sc)
  
  if isArray write "]"
  else  write "}"
  
  return sc
  
WriteEscaped(v)
  set readCount = 0
  do v.Rewind()
  
  // Instead of using AtEnd, we compare the stream size with the buffer read size.
  // This is because apparently AtEnd doesn't track the position correctly when the device is redirected.
  // This can also be related to how we are dealing with this redirection along with %CSP.REST.
  while readCount < v.Size {
    set buffer = v.Read()
    set readCount = readCount + $length(buffer)
    write $$$ZENJSONESCAPE(buffer,"s")
  }
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Unmarshaller">
<Abstract>1</Abstract>
<TimeCreated>64505,55057.137365</TimeCreated>

<Method name="Unmarshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject="",propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $isobject(dynamicObject) {   
    set dynamicType = $classname(dynamicObject)
    set isCollection = ##class(Frontier.Types).IsCollection(className) || ##class(Frontier.Types).IsDynamicArray(className)    
    
    if ##class(Frontier.Types).IsDynamicArray(dynamicType) {
      return ..MakeCollection(className, dynamicObject, .registeredObject, 1, propertyFormatter)
    } elseif 'isCollection && ##class(Frontier.Types).IsDynamicObject(dynamicType) && ##class(Frontier.Types).IsInstantiable(className) {
      return ..MakeObject(className, dynamicObject, .registeredObject, 1, propertyFormatter)
    }    
  }
  return $$$ERROR($$$GeneralError, "Cannot unmarshall data types.")
]]></Implementation>
</Method>

<Method name="UnmarshallUsingObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject="",propertyFormatter:Frontier.PropertyFormatter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set dynamicObject."__id__" = object.%Id()
  return ..Unmarshall($classname(object), dynamicObject, .registeredObject, propertyFormatter)
]]></Implementation>
</Method>

<Method name="MakeObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*object:%RegisteredObject="",depth:%String=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set object = ""
  set sc = $$$OK
  
  if '$isobject(dynamicObject) || ($isobject(dynamicObject) && 'dynamicObject.%IsA("%DynamicObject")) {
    quit $$$ERROR($$$GeneralError, "dynamicObject must be an instance of %DynamicObject.")
  }
  
  if dynamicObject.%IsDefined("__id__") {
    set object = $System.OBJ.OpenId(className, dynamicObject.%Get("__id__"))
  }
  
  set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(className)
  set properties = descriptor.Properties
  
  if $isobject(propertyFormatter) {
    do propertyFormatter.FormatFromCollection(descriptor.Properties, depth)
  }
  
  set propCount = properties.Count()
  
  set iterator = dynamicObject.%GetIterator()

  while iterator.%GetNext(.key, .value) {
    if key = "__id__" continue        
    set propertyId = className_"||"
    
    if $isobject(propertyFormatter) {
      set propertyId = propertyId_propertyFormatter.Normalize(key, depth)
    } else {
      set propertyId = propertyId_key
    }
    
    set property = ##class(%Dictionary.CompiledProperty).%OpenId(propertyId)    
    if '$isobject(property) continue
    
    if property.Private || property.Calculated || ($extract(property.Name) = "%") continue
    if '$isobject(object) {
      set object = $System.OBJ.New(className)
    }
    
    set dynamicObjectPropertyValue = $property(dynamicObject, key)
    set isDataType = '$isobject(dynamicObjectPropertyValue) && ##class(Frontier.Types).IsDataType(property.Type)
    set isSerial = ##class(Frontier.Types).IsSerial(property.Type)
    
    if 'isDataType {      
      if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%IsA("%DynamicObject") {
        set sc = ..MakeObject(property.Type, dynamicObjectPropertyValue, .dynamicChildInstance, propertyFormatter, depth + 1)          
        quit:$$$ISERR(sc)
        
        set $property(object, property.Name) = dynamicChildInstance
      } elseif ##class(Frontier.Types).IsStream(property.Type) {
        set childStream = $System.OBJ.New(property.Type)
        
        if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%Extends("%Stream.Object") {         
          do childStream.CopyFrom(dynamicObjectPropertyValue)
        } else {          
          do childStream.Write(dynamicObjectPropertyValue)
        }
        set $property(object, property.Name) = childStream
      } elseif isSerial {
        set $property(object, property.Name) = $classmethod(property.Type, "%Open", $lb(dynamicObjectPropertyValue, property.Type))
      } elseif property.Collection '= "" {
        set collectionType = $property(object, property.Name).ElementType
        set dynamicChildInstance = $property(object, property.Name)   
        
        if $isobject(dynamicObjectPropertyValue) {    
          set sc = ..MakeCollection(collectionType, dynamicObjectPropertyValue, .dynamicChildInstance, depth + 1)        
          quit:$$$ISERR(sc)
          set $property(object, property.Name) = dynamicChildInstance
        } elseif dynamicObjectPropertyValue '= "" {
          set value = dynamicObjectPropertyValue         
          set childInstance = $System.OBJ.OpenId(className, value)
          if $isobject(childInstance) {
            set $property(object, property.Name) = $property(childInstance, property.Name)
          }
        }
      } else {
        set childInstance = $System.OBJ.OpenId(property.Type, value)
        if $isobject(childInstance) set $property(object, property.Name) = childInstance                   
      }      
    } else {
      if dynamicObjectPropertyValue = "null" set dynamicObjectPropertyValue = ""  
      if property.Type = "%Library.Boolean" { set logicalValue = $case(value, "true" : 1, "false" : 0, 1 : 1, 0 : 0, : "") }
      elseif property.Type = "%Library.Date" && (dynamicObjectPropertyValue?4N1"-"2N1"-"2N1"T"2N1":"2N1":"2N1"."3N1"Z" = 1) { set logicalValue = $zdateh($piece(dynamicObjectPropertyValue,"T",1),3,,,,,,,dynamicObjectPropertyValue) }
      else {
        if isDataType && (##class(%Dictionary.CompiledMethod).%ExistsId(property.Type_"||IsValid") && ('$classmethod(property.Type, "IsValid", dynamicObjectPropertyValue) = 1)) {
          try {
            set logicalValue = $method(object, property.Name_"DisplayToLogical", dynamicObjectPropertyValue)            
          } catch {
            set logicalValue = dynamicObjectPropertyValue
          }
        } else {
          set logicalValue = dynamicObjectPropertyValue
        }
      }
      set $property(object, property.Name) = logicalValue     
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="MakeCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collectionType:%String,dynamicCollection:%DynamicAbstractObject,*collection:%Collection.Super="",depth:%Integer,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set insertStrategy = "list"
  set hasChildObjects = 0
  set collectionClass = "%ListOfDataTypes"
  set firstItem = dynamicCollection.%Get(0)
  set startOffset = 0  
  
  if collectionType [ "RelationshipObject" {
    set startOffset = 1
  } 
  
  if $isobject(firstItem) {    
    set hasChildObjects = '##class(Frontier.Types).IsDataType($classname(firstItem))   
  }
  
  if dynamicCollection.%IsA("%DynamicObject") {
    set insertStrategy = "Array"
    set collectionClass = $replace(collectionClass, "List", insertStrategy)
  }
  
  if hasChildObjects {
    set collectionClass = $replace(collectionClass, "OfDataTypes", "OfObjects")
  }
  
  // We must check for both occorences: 
  // 1 - When this method is called internally, so we already have the instance and can simply Clear it.
  // 2 - When we are generating it directly from a collection.
  if $isobject(collection) {
    do collection.Clear()
  } else {      
    set collection = $System.OBJ.New(collectionClass)
    set collection.ElementType = collectionType
  }
  
  set iterator = dynamicCollection.%GetIterator()
  set isPersistentItem = ##class(Frontier.Types).IsPersistent(collectionType)
  
  while iterator.%GetNext(.key, .dynamicItem) { 
    set isIdCandidate = '$isobject(dynamicItem) && (dynamicItem '= "")
    set itemClass = $select('isIdCandidate : $classname(dynamicItem), 1: "")
    
    if dynamicItem = "null" && (itemClass '= "") {
      continue      
    }    
    
    if isIdCandidate && isPersistentItem {
      set item = $System.OBJ.OpenId(collectionType, dynamicItem)
    } elseif $isobject(dynamicItem) { 
      set sc = $select(
        dynamicItem.%IsA("%DynamicObject") : ..MakeObject(collectionType, dynamicItem, .item, depth + 1, propertyFormatter),
        dynamicItem.%Extends("%DynamicArray") : ..MakeCollection(itemClass, dynamicItem, .item, depth + 1, propertyFormatter),
        1: $$$ERROR($$$GeneralError, "Cannot unmarshall items that aren't dynamic.")
      )
      if item = "" continue
    } else {
      set item = dynamicItem
    }
        
    if $$$ISERR(sc) quit    
    
    if insertStrategy = "Array" {
      set key = $select($isvalidnum(key) && (startOffset > 0): key + startOffset, 1: key)
      do collection.SetAt(item, key)
    } else {
      do collection.Insert(item)
    } 
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Exception">
<Super>%Exception.StatusException</Super>
<TimeCreated>64225,38503.046031</TimeCreated>

<Method name="CreateFromStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSC:%Status,errorIndex:%Integer=1</FormalSpec>
<ReturnType>Frontier.Exception</ReturnType>
<Implementation><![CDATA[
  #dim tException As %Exception.AbstractException
  #dim tData As %List
  #dim tInfo
  
  Set tException = $$$NULLOREF
  
  Do $SYSTEM.Status.DecomposeStatus(pSC,.tInfo)
  If $DATA(tInfo(1)) {
    // Build the exception object
    Set tData="" For tI=1:1:9 Set tData=tData_$LB(tInfo(errorIndex,"param",tI))
    Set tException = ..%New(tInfo(errorIndex,"code"),tInfo(errorIndex,"code"),$get(tInfo(errorIndex,"caller")),tData)
    
    // If there's an embedded error, construct that also
    If $DATA(tInfo(errorIndex,"embeddedstatus")) {
      Set tException.InnerException = ..CreateFromStatus(tInfo(errorIndex,"embeddedstatus"))
    }
    If $data(tInfo(errorIndex + 1)) Set tException.NextException=..CreateFromStatus(pSC, errorIndex + 1)
  }
  
  Quit tException
]]></Implementation>
</Method>

<Method name="ToDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()
  set graph = ..BuildObjectGraph(exception)
  
  if graph.%IsA("%DynamicObject") {
    set de.error = graph
  } elseif graph.%IsA("%DynamicArray") {
    set de.errors = graph
  }  
  return de
]]></Implementation>
</Method>

<Method name="CreateInfoObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()    
  set de.internalCode = exception.Code
  
  set fullMessage = $System.Status.GetOneStatusText(exception.AsStatus())
  set messageWithoutLF = $piece(fullMessage, $c(13), 1, 1)
  
  set message = $piece(messageWithoutLF, "#:", 1 , 1)
  set de.message = message
  return de
]]></Implementation>
</Method>

<Method name="BuildObjectGraph">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<ReturnType>%DynamicAbstractObject</ReturnType>
<Implementation><![CDATA[
     
  #define SupportsNextException(%ex) ($isobject(%ex) && ##class(%Dictionary.CompiledProperty).%ExistsId($classname(%ex)_"||NextException") && $isobject(%ex.NextException))  
  
  if $$$SupportsNextException(exception) {
    set de = ..CreateInfoObject(exception)
    set ex = exception.NextException
    set de = [ (de) ]
    while ex {
      set sibling = {}
      do TraverseException(.sibling, ex)
      do de.%Push(sibling)
      if $$$SupportsNextException(ex) {
        set ex = ex.NextException           
      } else {
        quit
      }      
    }
    return de
  }
  
  do TraverseException(.de, exception)
  return de

TraverseException(payload, ex)
  set payload = ..CreateInfoObject(ex)
  set supportsInnerException = ##class(%Dictionary.CompiledProperty).%ExistsId($classname()_"||InnerException") 

  if supportsInnerException && $isobject(ex.InnerException) {
    set payload.origin = ..BuildObjectGraph(ex.InnerException)   
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="CaptureStack">
<ClassMethod>1</ClassMethod>
<FormalSpec>*stackText:%Stream.GlobalCharacter="",from:%Integer=($stack  - $estack) + 1,to:%Integer=$stack +1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stackText = ##class(%Stream.GlobalCharacter).%New()
    
  do stackText.WriteLine("Runtime exception")  
  for loop=to:-1:from {
    do stackText.WriteLine(" at "_$stack(loop, "PLACE"))
    do stackText.WriteLine(" "_$stack(loop, "MCODE"))
  }
  do stackText.Rewind()
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Method">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,35961.209604</TimeCreated>

<Property name="DispatchClass">
<Type>%String</Type>
</Property>

<Property name="DispatchMethod">
<Type>%String</Type>
</Property>

<Property name="MethodArguments">
<Type>ArgumentDescription</Type>
<Collection>list</Collection>
</Property>

<Property name="MethodDescriptor">
<Type>%Dictionary.CompiledMethod</Type>
<Private>1</Private>
</Property>

<Property name="ReturnTypeParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ReturnType">
<Type>%String</Type>
</Property>

<Property name="Payload">
<Type>%CacheString</Type>
</Property>

<Property name="HttpMethod">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="Arguments">
<Type>%CacheString</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec><![CDATA[className:%String,methodName:%String,RESTMethodArguments:%String=0,request:%CSP.Request="",propertyFormatter:Frontier.PropertyFormatter="",strictQueryParameters:%Boolean=1,&matches:%String=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set requestQueryParams = 0
  $$$ThrowOnError(..AssertMethodExists(className, methodName))
  
  set ..DispatchClass = className
  set ..DispatchMethod = methodName  
  set ..MethodDescriptor = ##class(%Dictionary.CompiledMethod).%OpenId(className_"||"_methodName)  
  
  $$$ThrowOnError(..DescribeArguments())
  $$$ThrowOnError(..ParseReturnTypeParameters())
  
  if ..MethodDescriptor.ReturnType = "" {
    $$$ThrowOnError($$$ERROR($$$GeneralError, $$$FormatText("Expected a return type for method %1.", methodName)))
  }  
  
  if $isobject(request) {
    set ..Payload = request.Content
    set ..HttpMethod = request.Method
    merge requestQueryParams = request.Data
  }
  
  if matches = "" {
    $$$ThrowOnError(..MergeArguments(.RESTMethodArguments, .requestQueryParams, .mergedArguments, strictQueryParameters)) 
    $$$ThrowOnError(..Sequentialize(.mergedArguments, propertyFormatter))
  } else {
    set i%Arguments = matches
    merge i%Arguments = matches
  }   
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DescribeArguments">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set describedArguments = ##class(%ListOfObjects).%New()
  set formalSpec = ..MethodDescriptor.FormalSpec
  set currentIndex = 0
  set currentPiece = 0
  
  while $$ParseArgument(.parsedArgument) {
    set sc = ..MethodArguments.Insert(parsedArgument)
    if $$$ISERR(sc) return sc
  }
  
  return sc 
 
ParseArgument(parsedArgument)
  set currentIndex = currentIndex + 1
  set currentPiece = currentPiece + 1
  set argument = $piece(formalSpec, ",", currentPiece)
  
  if argument [ "(" {
    while '$find(argument, ")") {
      set currentPiece = currentPiece + 1
      set argument = argument_","_$piece(formalSpec, ",", currentPiece)
    }
  }    
  
  if argument '= "" {
    set parsedArgument = ##class(Frontier.ArgumentDescription).%New()
    if argument [ "..." set parsedArgument.Arity = 1
    set parsedArgument.Name = $piece($replace($piece(argument, ":", 1), "...", ""), "=", 1)       
    set parsedArgument.Index = currentIndex
    set preType = $piece(argument, ":", 2)    
    if preType [ "(" {      
      set parsedArgument.Type = $extract(preType, 1, $find(preType, "(") - 2)
      set maybeDefault = $piece(preType, "=", *)
      if $extract(maybeDefault, *) = ")" set maybeDefault = ""
      set parsedArgument.DefaultValue = $$$trimQuote(maybeDefault)
      set argumentParameters = $extract(preType, $find(preType, "("), $find(preType, ")") - 2)
      if '$find(argumentParameters, ",") set argumentParameters = argumentParameters_","
      for i=1:1:$length(argumentParameters, ",") {
        set argumentParameter = $piece(argumentParameters, ",", i)
        quit:argumentParameter=""
        set parameterName = $piece(argumentParameter, "=")
        set parameterValue = $$$trimQuote($piece(argumentParameter, "=", 2))
        do parsedArgument.Parameters.SetAt(parameterValue, parameterName)
        if parameterName = "ALIAS" set parsedArgument.Alias = parameterValue
      }
    } else {      
      set parsedArgument.Type = $piece(preType, "=", 1)
      set defaultQuotedValue = $piece(preType, "=", 2)
      if defaultQuotedValue '= "" {
        set parsedArgument.DefaultValue = $$$trimQuote(defaultQuotedValue)
        set parsedArgument.HasDefaultValue = 1
      }
    }
    return 1
  }    
  return 0
]]></Implementation>
</Method>

<Method name="FindDescribedArgument">
<Internal>1</Internal>
<FormalSpec>identifier:%String</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.ArgumentDescription</ReturnType>
<Implementation><![CDATA[
  
  for i=1:1:..MethodArguments.Count() {
    set argument = ..MethodArguments.GetAt(i)
    if argument.Name = identifier || (argument.Alias = identifier) return argument
  }
  return ""
]]></Implementation>
</Method>

<Method name="ParseReturnTypeParameters">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set serializedParameters = ..MethodDescriptor.ReturnTypeParams
  if serializedParameters = "" return $$$OK
  set parametersCount = $length(serializedParameters, ",")  
  
  for i=1:1:parametersCount {
    set part = $piece(serializedParameters, ",", i)
    set parameterKey = $piece(part, "=", 1)
    set parameterValue = $piece(part, "=", 2)
    set i%ReturnTypeParameters(parameterKey) = parameterValue
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertMethodExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = className_"||"_methodName
  
  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$ClassDoesNotExist, className)   
  }    
  
  if '##class(%Dictionary.CompiledMethod).%ExistsId(id) {
    return $$$ERROR($$$MethodDoesNotExist, methodName)
  }  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Sequentialize">
<FormalSpec><![CDATA[&mergedArguments=0,propertyFormatter:Frontier.PropertyFormatter=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim methodArgument As Frontier.ArgumentDescription
  #define TriggerPayloadFlag if ..HttpMethod = "POST" || (..HttpMethod = "PUT") || (..HttpMethod = "PATCH") set payloadFound = 1
  #define AssertSinglePayloadParameter throw:payloadFound=1 ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, "Cannot have more than one payload for POST/PUT/PATCH requests."))
  
  set sc = $$$OK  
  
  set argsProcessed = 0  
  set payloadFound = 0
    
  set methodArgumentsLength = ..MethodArguments.Count()
  
  set jsonErrorMessage = "Invalid JSON payload: expected a %1 compatible notation."  
  if $$$ISERR(sc) return sc  
  
  set maxLength = methodArgumentsLength
  if maxLength < mergedArguments set maxLength = mergedArguments
        
  if methodArgumentsLength > 0 {
    for argsProcessed=1:1:maxLength {       
      set methodArgument = $select(argsProcessed > methodArgumentsLength 
        :  ..MethodArguments.GetAt(methodArgumentsLength), 
        1: ..MethodArguments.GetAt(argsProcessed)
      )
      set value = $get(mergedArguments(argsProcessed))
    
      if value = "" {
        if 'methodArgument.Arity set value = methodArgument.DefaultValue
        else  set value = $get(mergedArguments(methodArgument.Index))
      }      
    
      if ##class(Frontier.Types).IsDynamic(methodArgument.Type) {
        if ..Payload = "" return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set unmarshallTo = methodArgument.Parameters.GetAt("UNMARSHALLTO")
        set idFrom = methodArgument.Parameters.GetAt("IDFROM")
        set value = $classmethod(methodArgument.Type, "%FromJSON", ..Payload)
        if unmarshallTo '= "" {
          set instanceId = value."__id__"    
          if idFrom '= "" {
            set value."__id__" = $get(mergedArguments(..FindDescribedArgument(idFrom).Index))
            if value."__id__" = "" set value."__id__" = instanceId
          }
          if value."__id__" = "" && (..HttpMethod = "PUT" || (..HttpMethod = "PATCH")) {
            return $$$ERROR($$$GeneralError, "Cannot unmarshall payload: a PUT/PATCH request requires an identifier.")
          }
          set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshall(unmarshallTo, value, .instance, propertyFormatter)
          if $$$ISERR(sc) return sc
          set value = instance
        } else {
          if value = "" return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
        }
      } elseif ##class(Frontier.Types).IsPersistent(methodArgument.Type) {
        set value = $System.OBJ.OpenId(methodArgument.Type, value)
        if '$isobject(value) set value = ""
      } elseif methodArgument.Type = "%Boolean" {
        // Attempts to convert true to 1 and false to 0, resolve to itself if input is not a boolean candidate.
        set value = $$$BooleanToBinary(value)
      }
      set i%Arguments(argsProcessed) = value
    }
  }
  set i%Arguments = argsProcessed
  return sc
]]></Implementation>
</Method>

<Method name="MergeArguments">
<FormalSpec><![CDATA[&routeArguments:%String=0,&requestArguments:%String=0,*preArguments:%String=0,strictMode:%Boolean=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
     
  // Conformity check:
  // 1 - No weak typing: All arguments must have a type provided.
  // 2 - Default values must be specified if optional.
  // 3 - Arity arguments must follow argumentnameN format, where N is an index.
  // 4 - Payloads must not have default values.
  // 5 - Each method must have only one payloadable type (%DynamicObject or DynamicArray).  
  
  set argumentIndex = routeArguments 
  set nextKeyIndex = 0
  set key = ""
  set preArguments = 0
  set methodArgumentsLength = ..MethodArguments.Count()
  set keysFound = ""

  for {
    set key = $order(requestArguments(key))
    quit:key=""    
    
    set keyGroup = $$$KeyGroup(key)
    set $list(keysFound, *+1) = keyGroup
    set methodArgument = ..FindDescribedArgument(key)
    
    if '$isobject(methodArgument) {
      set methodArgument = ..FindDescribedArgument(keyGroup)
    }
    
    if '$isobject(methodArgument) {
      if strictMode {
        return $$$ERROR($$$GeneralError, keyGroup_" query parameter was not expected.")
      } else {
        continue
      }
    }
    
    // Don't depend on query parameter repeatance, because JavaScript cannot repeat object keys.
    // Instead the parameter should follow the pattern "paramN" which represents a sequence.    
    set value = requestArguments(key, 1)  
    
    // Checks if we have a sequenced query param.
    if key?.A1.2N && (key '= methodArgument.Name) {
      if methodArgument.Arity '= 1 {
        if strictMode {
          return $$$ERROR($$$GeneralError, $$$FormatText("'%1' was NOT expected to be sequential.", keyGroup))
        } else {
          continue
        }
      }               
      if methodArgumentsLength > 1 {     
        set argumentIndex = methodArgumentsLength + nextKeyIndex
      } else {
        set argumentIndex = nextKeyIndex + 1
      }
      
      set nextKeyIndex = nextKeyIndex + 1
      
      if nextKeyIndex '= $$$KeyIndex(key) {
        return $$$ERROR($$$GeneralError, $$$FormatText("'%1' was expected to be sequential.", keyGroup))
      }
    } else {
      set argumentIndex = methodArgument.Index
    }
    set preArguments(argumentIndex) = value  
  }
  
  set missingArguments = ""
  set weaklyTypedArgs = ""
  
  if methodArgumentsLength > 0 {    
    for m=1:1:methodArgumentsLength {
      set methodArgument = ..MethodArguments.GetAt(m)      
      set isPayloadArgument = (methodArgument.Type [ "DynamicObject" || (methodArgument.Type [ "DynamicArray"))
      if methodArgument.Type = "" set $list(weaklyTypedArgs, *+1) = methodArgument.Name
            
      if 'methodArgument.HasDefaultValue && 'isPayloadArgument {
        set queryParameterName = $select(
          methodArgument.Alias '= "" : methodArgument.Alias, 
          1: methodArgument.Name
        )
        
        if methodArgument.Arity {
          set queryParameterName = $$$KeyGroup(queryParameterName)
        }        
        
        if '$lf(keysFound, queryParameterName) && '$data(routeArguments(queryParameterName)) {
          set $list(missingArguments, *+1) = queryParameterName
        }        
      }
    }
  }
  
  if $ll(weaklyTypedArgs) > 0 {
    return $$$ERROR($$$GeneralError, "The following arguments must be strongly typed: "_$lts(weaklyTypedArgs, ", ")_".")
  }  
  
  if $ll(missingArguments) > 0 {
    return $$$ERROR($$$GeneralError, "The following query parameters are missing: "_$lts(missingArguments, ", ")_".")
  } 
    
  // Now we must merge the route arguments back, remember that they always take priority over query parameters.
  set routeKey = ""
  for {
    set routeKey = $order(routeArguments(routeKey), 1, routeValue)
    quit:routeKey=""
    
    set methodArgument =  ..FindDescribedArgument(routeKey)
    
    if '$isobject(methodArgument) {
      return $$$ERROR($$$GeneralError, $$$FormatText("Route parameter '%1' was not specified as an argument in the method '%2'.", routeKey, ..MethodDescriptor.Name))
    }    
    set preArguments(..FindDescribedArgument(routeKey).Index) = routeValue
  }
  set preArguments = argumentIndex
  return $$$OK
]]></Implementation>
</Method>

<Method name="Invoke">
<Internal>1</Internal>
<FormalSpec>*methodReturn="",*stack:%Stream.Object=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  merge methodArguments = ..Arguments
  
  new $estack
  
  try {
    if methodArguments > 0 {
      set methodReturn = $classmethod(..DispatchClass, ..DispatchMethod, methodArguments...)      
    } else {            
      set methodReturn = $classmethod(..DispatchClass, ..DispatchMethod)
    }
  } catch ex {
    do ##class(Frontier.Exception).CaptureStack(.stack)
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter">
<Super>%RegisteredObject</Super>
<TimeCreated>64561,37245.906153</TimeCreated>

<Property name="Properties">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="Format">
<FormalSpec>propertyName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set storedFormatted = $get(i%Properties(depth, propertyName, "F"))
  if storedFormatted return storedFormatted
  
  set formattedName = ..OnFormat(propertyName)
  
  set i%Properties(depth, propertyName, "F") = formattedName
  set i%Properties(depth, formattedName, "N") = propertyName
  return formattedName
]]></Implementation>
</Method>

<Method name="FormatFromCollection">
<Internal>1</Internal>
<FormalSpec>collection:%ListOfObjects,depth:%Integer=1</FormalSpec>
<Implementation><![CDATA[
  for i=1:1:collection.Count() {
    set propertyName = collection.GetAt(i).Name
    if $extract(propertyName) '= "%" {
      do ..Format(collection.GetAt(i).Name, depth)
    }
  }
]]></Implementation>
</Method>

<Method name="OnFormat">
<FormalSpec>propertyName</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return propertyName
]]></Implementation>
</Method>

<Method name="Normalize">
<Final>1</Final>
<FormalSpec>formattedName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return $get(i%Properties(depth, formattedName, "N"))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.CamelCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,42861.513845</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Camelify(propertyName)
]]></Implementation>
</Method>

<Method name="Camelify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	return $$$lcase($extract(propertyName, 1))_$extract(propertyName, 2, *)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.SnakeCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,37293.153787</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Snakeify(propertyName)
]]></Implementation>
</Method>

<Method name="Snakeify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set snakedName = ""
	set nameLength = $length(propertyName)
	for i=1:1:nameLength {
		set c = $extract(propertyName, i)
		set n = $extract(propertyName, i+1)
		if c?1A = 1 && (c = $$$ucase(c) && (n '= $$$ucase(n)) && (i > 1)) set c = "_"_c
		set snakedName = snakedName_c
	}	
	return $$$lcase(snakedName)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter">
<Super>%RegisteredObject</Super>
<TimeCreated>64537,40798.410075</TimeCreated>

<Method name="Setup">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter.Email">
<Description>
This class demonstrates how to create a reporter that sends an e-mail when a request error occurs.
If you want to see it working, create another class extending from this one and fill
the fields that aren't private, or you can instantiate it and change it's values manually.</Description>
<Super>Frontier.Reporter</Super>
<TimeCreated>64538,34157.457443</TimeCreated>

<Property name="Mail">
<Type>%Net.MailMessage</Type>
<Private>1</Private>
</Property>

<Property name="SMTPServer">
<Type>%Net.SMTP</Type>
<Private>1</Private>
</Property>

<Property name="Authenticator">
<Type>%Net.Authenticator</Type>
<Private>1</Private>
</Property>

<Property name="SMTPServerLocation">
<Type>%String</Type>
<InitialExpression>"your smtp server"</InitialExpression>
</Property>

<Property name="SMTPServerPort">
<Type>%Integer</Type>
<InitialExpression>25</InitialExpression>
</Property>

<Property name="SenderEmail">
<Type>%String</Type>
<InitialExpression>"youremail@host.com"</InitialExpression>
</Property>

<Property name="SenderPassword">
<Type>%String</Type>
<InitialExpression>"yourpasssword"</InitialExpression>
</Property>

<Property name="DestinationEmail">
<Type>%String</Type>
<InitialExpression>"dest@host.com"</InitialExpression>
</Property>

<Property name="TemplateLocation">
<Type>%String</Type>
<InitialExpression>"/the/email/template.html"</InitialExpression>
</Property>

<Property name="SSLConfiguration">
<Type>%String</Type>
</Property>

<Property name="UseSTARTTLS">
<Type>%Boolean</Type>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..SMTPServer = ##class(%Net.SMTP).%New()
  set ..Authenticator = ##class(%Net.Authenticator).%New()
  set ..Mail = ##class(%Net.MailMessage).%New()
  set ..Mail.IsHTML = 1
  set ..SMTPServer.authenticator = ..Authenticator
  $$$QuitOnError(..SetupAccount())
  return $$$OK
]]></Implementation>
</Method>

<Method name="Setup">
<Internal>1</Internal>
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(..SetupSMTPServer())
  $$$QuitOnError(..SetupAuthenticator())
  $$$QuitOnError(..SetupMail(context))
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupSMTPServer">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..SMTPServer.smtpserver = ..SMTPServerLocation
  set ..SMTPServer.port = ..SMTPServerPort
  set ..SMTPServer.SSLConfiguration = ..SSLConfiguration
  set ..SMTPServer.UseSTARTTLS = ..UseSTARTTLS
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupAuthenticator">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Authenticator.UserName = ..SenderEmail
  set ..Authenticator.Password = ..SenderPassword
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupMail">
<FormalSpec>context:Frontier.Context</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Mail.From = ..SenderEmail
  do ..Mail.To.Insert(..DestinationEmail)      
  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Mail.Subject = $$$FormatText("[Error Report] - %1", $System.Status.GetErrorText(context.Error))
  $$$QuitOnError(..Mail.TextData.Write(..ReplacePlaceholders(context)))
  return ..SMTPServer.Send(..Mail)
]]></Implementation>
</Method>

<Method name="ReplacePlaceholders">
<FormalSpec>context:Frontier.Context</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set method = ##class(Frontier.Method).%New(context.ClassName, context.Method)  
  set template = ##class(%Stream.FileCharacter).%New()
  
  $$$QuitOnError(template.LinkToFile(..TemplateLocation))  
  
  set formatParameters = 6
  set formatParameters(1) = $System.Status.GetErrorText(context.Error)
  set formatParameters(2) = context.RequestURL
  set formatParameters(3) = context.ClassName
  set formatParameters(4) = context.Method
  if context.ArgumentValues '= 0  {
    for i=1:1:context.ArgumentValues {
      set methodArgument = method.MethodArguments.GetAt(i)
      set argumentName = methodArgument.Name
      set argumentValue = context.ArgumentValues(i)
      set argumentType = methodArgument.Type
      if argumentType = "" set argumentType = "<i>n/a</i>"
      set formatParameters(5) = $$$FormatText("%1 %2:%3: %4<br>", $get(formatParameters(5)), argumentName, argumentType, argumentValue)
    }
  } else {
    set formatParameters(5) = "<i>none</i>"
  }
  set formatParameters(6) = $replace(context.Stack, $c(10), "<br>")
  return $$$FormatText(template.Read(), formatParameters...)
]]></Implementation>
</Method>

<Method name="SetupAccount">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter.Manager">
<Super>%RegisteredObject</Super>
<TimeCreated>64538,33046.39632</TimeCreated>

<Property name="Reporters">
<Type>Frontier.Reporter</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Context">
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddReporter">
<FormalSpec>reporter:Frontier.Reporter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(reporter.Setup(..Context))
  $$$QuitOnError(..Reporters.Insert(reporter))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if $$$ISOK(..Context.Error) return $$$OK
  
  try {
    for i=1:1:..Reporters.Count() {
      set reporter = ..Reporters.GetAt(i)
      set sc = $$$ADDSC(sc, reporter.Report(..Context))
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="SetupReporters">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  for i=1:1:..Reporters.Count() {
    set reporter = ..Reporters.GetAt(i)
    set sc = $$$ADDSC(reporter.Setup(..Context), sc)
  }  
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Router">
<IncludeCode>%occErrors,%occStatus,frontier</IncludeCode>
<Super>%CSP.REST</Super>
<TimeCreated>64492,32085.189445</TimeCreated>

<Parameter name="CHARSET">
<Default>utf-8</Default>
</Parameter>

<Parameter name="CONTENTTYPE">
<Default>application/json</Default>
</Parameter>

<Parameter name="CONVERTINPUTSTREAM">
<Default>1</Default>
</Parameter>

<Method name="Page">
<ClassMethod>1</ClassMethod>
<FormalSpec>skipheader:%Boolean=1</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  new %frontier
  set %frontier = ##class(Frontier.Context).%New(%session, %request, %response)
  set %session.Data("%frontier") = %frontier
  $$$QuitOnError(##super(skipheader))
  return $$$OK
]]></Implementation>
</Method>

<Method name="DispatchMap">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>index:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
     
  // Don't try to generate patterns if the target class is Frontier.Router.
  if %compiledclass.Name = "Frontier.Router" return $$$OK   
  
  $$$ThrowOnError(##class(Frontier.Schema.Util).Parse(%compiledclass.Name, .routes))
  $$$ThrowOnError(##class(Frontier.Schema.Util).GeneratePatterns(routes, %compiledclass.Name, .patterns))  
  
  set patternIndex = ""
  
  for {
    set patternIndex = $order(patterns(patternIndex), 1, pattern)
    quit:patternIndex=""
    
    set patternString = ""
    set patternType = $lg(pattern, 1)
    
    for i=1:1:$ll(pattern) {
      set item = $lg(pattern, i)      
      if patternType = "M" {
        if i = 4 set $list(patternString, *+1) = "$lfs("_$$MakeString(item)_")"
        else  set $list(patternString, *+1) = """"_$lg(pattern, i)_""""
      } elseif patternType = "R" {
        if i = 6 set $list(patternString, *+1) = "$lfs("_$$MakeString(item)_")"
        else  set $list(patternString, *+1) = """"_$lg(pattern, i)_""""
      }
    }
    
    do %code.WriteLine("  if index = "_patternIndex_ " return $lb("_$lts(patternString)_")")
  }
  
  // Prevents the dispatch from throwing <OBJECT DISPATCH> if route is not defined.
  // This will make the engine return "Resource not found" instead.
  do %code.WriteLine("  return """"")  
  return $$$OK
  
MakeString(list)
  set stringList = ""
  for li=1:1:$ll(list) {
    set item = $lg(list, li)
    set $piece(stringList, ",", li) = ""_item_""
  }
  return """"_stringList_""""
]]></Implementation>
</Method>

<Method name="DispatchRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[url:%String,httpMethod:%String,forwarded:%Boolean="",routeParameters:%String=0,&matches:%String="",parentIsStrict:%Boolean=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set httpStatus = $case(httpMethod, "POST": ..#HTTP201CREATED, : ..#HTTP200OK)
  set isResourceMatch = 0
  set isHttpMethodMatch = 0
  
  set %frontier.Method = "DispatchRequest"
  
  // Makes sure the http method is following specs.
  set httpMethod = $$$ucase(httpMethod)  
  
  try {    
    set resolvedUrl = $$ResolveUrl(url)  
    
    while $$NextDispatchMap(.index, .mapEntry) {
      set matchType = $list(mapEntry, 1)
      set urlExpression = $list(mapEntry, 2)      
      set matcher = ##class(%Regex.Matcher).%New(urlExpression)      
      
      // If there's no match, skip to the next candidate.
      if matcher.Match(resolvedUrl) {      
        set isResourceMatch = 1
        set resourceScope = $lg(mapEntry, 7)
        set strictRouteParameters = $case(matchType, "R": $lg(mapEntry, 9), : $lg(mapEntry, 5))        
                
        set %frontier.RequestURL = %request.URL
        set %frontier.ClassName = $classname()        
        
        set %frontier.Method = "OnDataSet"
        $$$ThrowOnError(..OnDataSet(%frontier.Data))        
                 
        set %frontier.Method = "OnSetup"
        $$$ThrowOnError(..OnSetup())                
        
        if parentIsStrict '= "" && (parentIsStrict '= strictRouteParameters) {
          $$$ThrowOnError($$$ERROR($$$GeneralError, "Cannot use route with mixed Strict definition."))
        }           
        
        if matcher.GroupCount {
          do FetchRouteParameters(.routeParameters)
        }        
        
        // This is our final router. Search for the dispatch method and prepare it to be called.
        if matchType = "R" {
          set shouldQuit = 0
          set requiresCors = $list(mapEntry, 5)
          set useAuth = $lg(mapEntry, 8)                                           
          
          if httpMethod = "OPTIONS" do HandleOptionsRequest(url, requiresCors, .shouldQuit)
          // Don't continue if we hit this point, let the agent do the rest.
          if shouldQuit return $$$OK                       
                  
          if httpMethod '= $list(mapEntry, 3) continue              
          
          $$$ThrowOnError(..ProcessCorsRequest(url, requiresCors))
                   
          if useAuth {
            // Run pending authentication strategies. If one passes, then the implementation
            // is responsible for filling the user object.
            $$$ThrowOnError(%frontier.AuthenticationManager.Verify(.user, resourceScope))
            
            if '%frontier.AuthenticationManager.Verified {
              set %response.Status = ..#HTTP401UNAUTHORIZED
              $$$ThrowOnError($$$ERROR($$$GeneralError, "You must be authenticated to access this resource."))
            }
            
            set %frontier.User = user                       
          
            // Don't let the user access this resource if this request doesn't match it.           
            if '%frontier.AuthenticationManager.CheckResourceScope(resourceScope, user.scope) {
              if %response.Status = ..#HTTP200OK || (%response.Status = ..#HTTP201CREATED) {
                set %response.Status = ..#HTTP403FORBIDDEN
              }
              $$$ThrowOnError($$$ERROR($$$GeneralError, "This account has not enough privilege to access this resource."))
            }                                            
          }                                                
          
          set dispatchMethod = $listget(mapEntry, 4)
          set dispatchClass = $classname()
          
          // If the Call has : then it's calling a method outside this router.
          if dispatchMethod [ ":" {
            set dispatchClass = $piece(dispatchMethod, ":", 1) 
            set dispatchMethod = $piece(dispatchMethod, ":", 2)         
          }
          
          // Parse dispatchMethod retrieving its metadata.
          set publicMethod = ##class(Method).%New(dispatchClass, dispatchMethod, .routeParameters, %request, %frontier.PropertyFormatter, %frontier.StrictQueryParameters, .matches)                   
          merge methodArguments = publicMethod.Arguments
          
          if matches = "" merge %frontier.RouteParameters = routeParameters
          else  merge %frontier.RouteParameters = matches
          
          set %frontier.Method = dispatchMethod
          merge %frontier.ArgumentValues = publicMethod.Arguments
          
          // Executes the method and retrives its value. The method MUST return a value or a 
          // <COMMAND> will be issued.
          set sc = publicMethod.Invoke(.methodReturn, .stack)
          set %frontier.Stack = stack
          
          $$$ThrowOnError(sc)
          
          // Now we serialize and output the result back to the agent.
          $$$ThrowOnError(..DispatchResponse(methodReturn, .tReturnParameters))
          
          // Finishes the request.
          return $$$OK
        } elseif matchType = "M" {
          // We're reading a map, Map patterns already include everything needed to forward the
          // correct URL part, as long as we always consider targeting its the last match.
          set forwardingClass = $listget(mapEntry, 3)
          
          if forwardingClass = $classname() {
            $$$ThrowOnError($$$ERROR($$$GeneralError, $$$FormatText("Dispatcher class %1 is attempting to forward %2 to itself.", forwardingClass, resolvedUrl)))
          }          
          
          set resolvedUrl = "/"_matcher.Group(matcher.GroupCount)                    
          set parentIsStrict = strictRouteParameters                    
                    
          // Re-invoke this method using the class that this map forwards the request to. 
          $$$ThrowOnError($classmethod(forwardingClass, "DispatchRequest", resolvedUrl, httpMethod, 1, .routeParameters, .matches, strictRouteParameters))
          // Maps are also a match, so abort everything else and let the forwarding class handle the rest.
          return $$$OK
        }
      }      
    }
    
    // Didn't have a match for the resource, report not found.
    if isResourceMatch '= 1 || (isHttpMethodMatch '= 1) {
      set %response.Status = ..#HTTP404NOTFOUND
      $$$ThrowOnError($$$ERROR($$$GeneralError, "Resource not found."))
    }
    
    return $$$OK       
  } catch ex {    
    set exceptionPayload = ..HandleException(ex)
    if %frontier.Debug = 1 {
      do ##class(Frontier.Dynamic.Serializer).Serialize(exceptionPayload, 1, %frontier.PropertyFormatter)
    } else {
      do ##class(Frontier.Dynamic.Serializer).SerializeToStream(.stream, exceptionPayload, 1, %frontier.PropertyFormatter)
      do stream.OutputToDevice()
    }    
  }
  return $$$OK
  
ResolveUrl(url)
  if 'forwarded return "/"_$extract(url, $length(%request.Application)+1,*)
  return url
  
NextDispatchMap(index=0, mapEntry="", dispatchClass="")  
  set index = index + 1
  set mapEntry = ..DispatchMap(index)
  return (mapEntry '= "")  
  
FetchRouteParameters(routeParameters=0)  
  if matchType = "R" {
    if httpMethod '= $lg(mapEntry, 3) quit
    set max = $ll($lg(mapEntry,6))
    set storedUrl = $lg(mapEntry, 10) 
  } elseif matchType = "M" { 
    set max = $ll($lg(mapEntry,4))
    set storedUrl = $lg(mapEntry, 6) 
  }
  
  if strictRouteParameters { 
    for p=1:1:max {
      if matchType = "R" {
        set routeParameterName = $lg($lg(mapEntry,6), p)
        if '$data(routeParameters(routeParameterName)) {
          set routeParameters(routeParameterName) = matcher.Group(p)
          set routeParameters = routeParameters + 1
        }
      } elseif matchType = "M" {      
        set routeParameterName = $lg($lg(mapEntry, 4), p)      
        set routeParameters(routeParameterName) = $piece(matcher.Group(p), "/")
        set routeParameters = routeParameters + 1
      }
    }
  } else {
    set storedUrlMatcher = ##class(%Regex.Matcher).%New(storedUrl)
    set storedUrlMatcher.Text = resolvedUrl
    do storedUrlMatcher.Locate()
    for p=1:1:storedUrlMatcher.GroupCount {
      set matchIndex = $order(matches(""), -1) + 1    
      set matches(matchIndex) = storedUrlMatcher.Group(p)
      set matches = matchIndex
    }
  }
  quit
 
HandleOptionsRequest(url, requireCors, shouldQuit)
 if httpMethod = "OPTIONS" {
   set isHttpMethodMatch = 1 
   $$$ThrowOnError(..OnHandleOptionsRequest(resolvedUrl))        
                      
   // As we got options, we imply that it's a CORS request.
   $$$ThrowOnError(..ProcessCorsRequest(url, requireCors))
   set shouldQuit = 1
 }
 quit
]]></Implementation>
</Method>

<Method name="HandleException">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:%Exception.AbstractException</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set responseCode = $piece(%response.Status, " ")
    
  // There might have cases where we get a success HTTP status, we need to normalize forcing it to be a 500 error.
  if responseCode < 300 {
    set %response.Status = ..#HTTP500INTERNALSERVERERROR
    set responseCode = 500
  }
    
  set exceptionJSON = ##class(Exception).ToDynamicObject(exception)
  set exceptionJSON.responseCode = responseCode
  set sc = exception.AsStatus()
  set stack = %frontier.Stack  
    
  if '%frontier.ThrownByApplication && ($$$GETERRORCODE(sc) '= $$$GeneralError) {
    set %frontier.Error = sc
  }  
  
  if stack '= "" && (%frontier.IncludeStack = 1) {    
    set exceptionJSON.stack = %frontier.Stack
  }
    
  set %response.OutputSessionToken = 0
  return exceptionJSON
]]></Implementation>
</Method>

<Method name="DispatchResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[returnedData:%CacheString,method:Frontier.Router,warnings:%DynamicObject="",&returnTypeParams=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  set response = {}  
  
  if $isobject(returnedData) {
    set type = $classname(returnedData)
    set isCollection = ##class(Types).IsCollection(type)
    set isSQLProvider = ##class(Types).IsSQLProvider(type)
    set isStream = ##class(Types).IsStream(type)
    set isDynamic = ##class(Types).IsDynamic(type)
    set isSystemType = ($extract(type) = "%")
    set isMarshallable = isCollection || isDynamic || isStream || isSQLProvider || ('isSystemType && ##class(Types).IsInstantiable(type))
    if isMarshallable {
      if isStream {
        set stream = returnedData set returnedData = response
        set response.content = stream
      } elseif isSQLProvider {
        set provider = returnedData
        set response.results = provider
      } else {      
        $$$QuitOnError(##class(Frontier.Dynamic.Marshaller).Marshall(returnedData, .response))
      }
    } else {
      return $$$ERROR($$$GeneralError, "Cannot serialize system class instances.")
    }
  } elseif %frontier.IsJSON() {
    set response.result = returnedData
  } else {
    write returnedData
    return $$$OK
  }  
  
  // We must use a custom serializer because the current %ToJSON implementation cannot serialize
  // mixed instances.
  if %frontier.DirectWrite = 1 || (%frontier.Debug = 1) {
    return ##class(Frontier.Dynamic.Serializer).Serialize(response, 1, %frontier.PropertyFormatter)
  } else {
    $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(.stream, response, 1, %frontier.PropertyFormatter))
    do stream.OutputToDevice()
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="OnDataSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<XData name="Schema">
<Description>
This is the Schema which defines the form of the dispatch map</Description>
<Internal>1</Internal>
<Data><![CDATA[
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" >

<xs:element name="Routes">
<xs:complexType>
<xs:choice  minOccurs="0" maxOccurs="unbounded">
<xs:element name="Route">
<xs:complexType>
<xs:attribute name="Url"    type="string" use="required"/>
<xs:attribute name="Method" type="string" use="required"/>
<xs:attribute name="Call" type="call" use="required"/>
<xs:attribute name="Cors" type="xs:boolean" use="optional" default="false"/>
<xs:attribute name="Scope" type="string" use="optional" default="false"/>
<xs:attribute name="UseAuth" type="xs:boolean" use="optional" default="true"/>
<xs:attribute name="Strict" type="xs:boolean" use="optional" default="true"/>
</xs:complexType>
</xs:element>
<xs:element name="Map">
<xs:complexType>
<xs:attribute name="Prefix" type="string" use="required"/>
<xs:attribute name="Forward" type="forward" use="required"/>
<xs:attribute name="Strict" type="xs:boolean" use="optional" default="true"/>
</xs:complexType>
</xs:element>
</xs:choice>
</xs:complexType>
</xs:element>

<xs:simpleType name="call">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*:)?[%]?[a-zA-Z][a-zA-Z0-9]*"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="forward">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*)"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="string">
<xs:restriction base="xs:string">
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>

</xs:schema>
]]></Data>
</XData>
</Class>


<Class name="Frontier.SQL">
<Super>%RegisteredObject</Super>
<TimeCreated>64531,35746.997056</TimeCreated>

<Method name="Prepare">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Implementation><![CDATA[  return ##class(Frontier.SQL.Provider).%New(SQLExpression)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Provider">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64531,36463.732591</TimeCreated>

<Property name="QueryClass">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="SQL">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Mode">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Error">
<Type>%Status</Type>
<Internal>1</Internal>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="StatementExecuted">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Results">
<Type>%SQL.StatementResult</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Metadata">
<Type>%SQL.StatementMetadata</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>statement:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  $$$ThrowOnError(..HandleSQLExpression(statement))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Parameters">
<FormalSpec>params...:%String</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..SetQueryParameters(params...))
  return $this
]]></Implementation>
</Method>

<Method name="Mode">
<FormalSpec>selectMode:%Integer=1</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set ..Mode = selectMode
  return $this
]]></Implementation>
</Method>

<Method name="Execute">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..StatementExecuted = 1
  return ..CreateAndExecute()
]]></Implementation>
</Method>

<Method name="HandleSQLExpression">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $length(SQLExpression, ":") = 2 {   
    set ..QueryClass = $piece(SQLExpression, ":")
    set ..QueryName = $piece(SQLExpression, ":", 2)
  } elseif $extract($$$ucase($$$trim(SQLExpression)), 1, 6) = "SELECT" {
    set ..SQL = SQLExpression
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetQueryParameters">
<FormalSpec>parameters...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if parameters '= 0 && 'parameters?.N && ($order(parameters(""), -1) '= parameters) {
    return $$$ERROR($$$GeneralError, "Invalid parameter spec.")
  }
  
  kill i%QueryParameters
  set i%QueryParameters = parameters
  
  merge i%QueryParameters = parameters
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateAndExecute">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  merge parameters = ..QueryParameters
  
  set statement = ##class(%SQL.Statement).%New()
  set statement.%SelectMode = ..Mode  
  
  if ..QueryClass '= "" && (..QueryName '= "") {
    set sc = statement.%PrepareClassQuery(..QueryClass, ..QueryName)    
  } elseif ..SQL '= "" {
    set sc = statement.%Prepare(..SQL)
  }
  
  set i%Metadata = statement.%Metadata 
  
  $$$QuitOnError(sc)
  set results = statement.%Execute(parameters...)
  
  if results.%SQLCODE '= 0 {
    set sc = ##class(%Exception.SQL).CreateFromSQLCODE(results.%SQLCODE, results.%Message).AsStatus()
  }
  set i%Results = results
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Serializer">
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64539,50921.256251</TimeCreated>

<Method name="Serialize">
<ClassMethod>1</ClassMethod>
<FormalSpec>results:%SQL.Statement,metadata:%SQL.StatementMetadata,depth:%Integer=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set sc = $$$OK
  $$$QuitOnError(..FetchColumnNames(metadata, .columnNames))  
  
  set data = ##class(%Stream.GlobalCharacter).%New()
  
  write "["
  
  set itemComma = ""
  set propertyComma = ""
  
  try {               
    while results.%Next(.sc) {
      $$$ThrowOnError(sc)
      
      write itemComma
      
      set itemComma = ","
      set propertyComma = ""
      
      write "{"         
      
      for c=1:1:columnNames {
        set columnName = columnNames(c)
        set columnType = columnNames(c, "type")
        set value = results.%Get(columnName)
        set jsonDataFormat = ##class(Frontier.Types).GetJSONDataFormat(columnType)       
        
        if value = "" && (jsonDataFormat = "null") {
          set value = jsonDataFormat
        } elseif jsonDataFormat = "boolean" {
          set value = $$$FormatBoolean(value)
        }
        
        if $isobject(propertyFormatter) {
          set columnName = propertyFormatter.Format(columnName, depth)
        }
        
        write propertyComma        
        
        write $$$ZENJSONPROP(columnName, "s")_":"                
        write ..HandleJSONWord(value)
        
        set propertyComma = ","
      }
      write "}"
    }   
    write "]"
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="FetchColumnNames">
<ClassMethod>1</ClassMethod>
<FormalSpec>metadata:%SQL.StatementMetadata,*columnNames:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set columns = metadata.columns
  set columnNames = columns.Count()
  for i=1:1:columnNames {
    set column = columns.GetAt(i)
    set columnNames(i) = column.label
    if $isobject(column.typeClass) {
      set columnNames(i, "type") = column.typeClass.Name
    } else {
      set columnNames(i, "type") = ""
    }
  }  
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Schema.Map">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36886.274558</TimeCreated>

<Property name="Prefix">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Forward">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Strict">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Route">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36903.793612</TimeCreated>

<Property name="Url">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Method">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Call">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cors">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Scope">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="UseAuth">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Strict">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Routes">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36920.7862</TimeCreated>

<Parameter name="XMLPROJECTION">
<Default>WRAPPED</Default>
</Parameter>

<Property name="Route">
<Type>Frontier.Schema.Route</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Map">
<Type>Frontier.Schema.Map</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="Frontier.Schema.Util">
<Abstract>1</Abstract>
<TimeCreated>64552,36997.083393</TimeCreated>

<Method name="Parse">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>targetClass:%String,*routes:Frontier.Schema.Routes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set xdataId = targetClass_"||UrlMap"
  
  if '##class(%Dictionary.CompiledXData).%ExistsId(xdataId) {
    return $$$ERROR($$$XDataBlockMissing, targetClass, "UrlMap")
  }
  
  try {
    set reader = ##class(%XML.Reader).%New()
    set xdata = ##class(%Dictionary.CompiledXData).%OpenId(xdataId).Data   
    set resolver = ##class(%XML.SAX.XDataEntityResolver).%New(targetClass)
    set reader.EntityResolver = resolver
    $$$ThrowOnError(reader.OpenStream(xdata))
    do reader.Correlate("Routes", "Frontier.Schema.Routes")
    do reader.Next(.routes, .sc)
    $$$ThrowOnError(sc)
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="GeneratePatterns">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>routes:Frontier.Schema.Routes,targetClass:%String,*patterns:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim route As Frontier.Schema.Route
  #dim map as Frontier.Schema.Map
  
  set totalRoutes = routes.Route.Count()
  set totalMaps = routes.Map.Count()
  set k = 0
  set p = 0
  
  set lowPriorityPatterns = 0
  
  if totalRoutes > 0 {
    set resourceType = "R"
    for i=1:1:totalRoutes {
      set route = routes.Route.GetAt(i)
      set pattern = $$WritePattern(route.Url, .placeholders)
      set routePattern = $lb(resourceType, pattern, route.Method, route.Call, route.Cors, placeholders, route.Scope, route.UseAuth, route.Strict, route.Url)
      if placeholders = "" && (pattern '= "/") {
        set patterns($increment(p)) = routePattern
      } else {
        set lowPriorityPatterns($increment(k)) = routePattern
        set lowPriorityPatterns = k
      }
    }    
  } 
  
  if totalMaps > 0 {
    set resourceType = "M"
    for j=1:1:totalMaps {
      set map = routes.Map.GetAt(j)
      set pattern = $$WritePattern(map.Prefix, .placeholders)
      set routePattern = $lb(resourceType, pattern, map.Forward, placeholders, map.Strict, map.Prefix)
      if placeholders = "" && (pattern '= "/") {
        set patterns($increment(p)) = routePattern
      } else {
        set lowPriorityPatterns($increment(k)) = routePattern
        set lowPriorityPatterns = k
      }
    }
  }
  
  for i=1:1:lowPriorityPatterns {
    set patterns(p + i) = lowPriorityPatterns(i)
  }  
  
  return $$$OK
  
WritePattern(resource, placeholders)
  #define GetPlaceholder(%exp) $piece(%exp, ":", 2) 
  #define AddPlaceholderIfNotDefined(%placeholder)  ##continue
  if '$lf(placeholders, %placeholder) { ##continue
    set $list(placeholders, *+1) = $$$GetPlaceholder(%placeholder) ##continue 
  }
    
  
  set pattern = ""
  set placeholders = ""
  set shouldCloseParenthesis = 0
  
  if $extract(resource) = ":" {
    $$$AddPlaceholderIfNotDefined($piece(resource, "/", 1))
  }
  
  set resourcePartsLength = $length(resource,"/")
  
  for resourceIndex=2:1:resourcePartsLength {
    set resourcePart = $piece(resource,"/", resourceIndex)
    if $extract(resourcePart) = ":" {
      $$$AddPlaceholderIfNotDefined(resourcePart) 
      set pattern = pattern_"/([^\/]+?)"
    } else {      
      set pattern = pattern_"/"_resourcePart
    }   
  }
  return $case(resourceType, "M" : pattern_"(?:(?:/(?=.*))(.*)|/?$)", : pattern)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SessionEvents">
<Super>%CSP.SessionEvents</Super>
<TimeCreated>64594,37362.115919</TimeCreated>

<Method name="OnEndRequest">
<Description>
Called when we have finished processing this request</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set frontier = %session.Data("%frontier")
  return frontier.ReporterManager.Report()
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Types">
<Abstract>1</Abstract>
<IncludeCode>frontier</IncludeCode>
<TimeCreated>64502,35492.335596</TimeCreated>

<Method name="IsInstantiable">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%RegisteredObject")
]]></Implementation>
</Method>

<Method name="IsPersistent">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Persistent")
]]></Implementation>
</Method>

<Method name="IsDataType">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%DataType")
]]></Implementation>
</Method>

<Method name="IsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Stream.Object")
]]></Implementation>
</Method>

<Method name="IsCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Collection.AbstractIterator")
]]></Implementation>
</Method>

<Method name="IsSerial">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%SerialObject")
]]></Implementation>
</Method>

<Method name="IsDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicAbstractObject")
]]></Implementation>
</Method>

<Method name="IsDynamicArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicArray")
]]></Implementation>
</Method>

<Method name="IsDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicObject")
]]></Implementation>
</Method>

<Method name="IsZENProxyObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%ZEN.proxyObject")
]]></Implementation>
</Method>

<Method name="IsSQLProvider">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "Frontier.SQL.Provider")
]]></Implementation>
</Method>

<Method name="IsTypeOf">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,expectedType:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   
  if className = "" quit 0
  
  $$$NormalizeClassName(className)
  $$$NormalizeClassName(expectedType)  
  
  if className = expectedType return 1
  
  // Uses default %Extends method to check for common cases and improve performance.
  return ##class(%Dictionary.CompiledClass).%ExistsId(className) && $classmethod(className, "%Extends", expectedType)
]]></Implementation>
</Method>

<Method name="GetJSONDataFormat">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>cacheType:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  $$$NormalizeClassName(cacheType)
  
  if ..IsDataType(cacheType) {
    set type = $case(cacheType,
      "%Library.Boolean": "boolean",
      "%Library.Double": "number",
      "%Library.BigInt": "number",
      "%Library.TinyInt": "number",
      "%Library.Decimal": "number",
      "%Library.Integer": "number",
      "%Library.Float": "number",
      "%Library.Date": "number",
      "%Library.Time": "number",
      "%Library.DateTime": "number",
      "%Library.TimeStamp": "number",
      : "string")
  } else {
    set type = "null"
  }
  return type
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Authentication.DummyStrategy">
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64560,50335.046682</TimeCreated>

<Property name="ShouldPass">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  if ..ShouldPass = 1 || (..Next = 1) return $$$OK
  set response.Status = "401 Unauthorized"
  return $$$ERROR($$$GeneralError, "Requested to fail")
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "realm=""Tests"""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Class">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34585.6306</TimeCreated>

<Property name="Plate">
<Type>%String</Type>
</Property>

<Property name="Students">
<Type>Student</Type>
<Cardinality>many</Cardinality>
<Inverse>Class</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.Fix50C.ClassD</DataLocation>
<DefaultData>ClassDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.Fix50C.ClassD</IdLocation>
<IndexLocation>^Frontier.UnitTest.Fix50C.ClassI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.Fix50C.ClassS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="ClassDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Plate</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Plate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>4.9</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Student">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34683.761379</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Class">
<Type>Class</Type>
<Cardinality>one</Cardinality>
<Inverse>Students</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="BirthDate">
<Type>%Date</Type>
</Property>

<Property name="SomeValue">
<Type>%String</Type>
<InitialExpression>"0032323"</InitialExpression>
</Property>

<Query name="PaginatedStudents">
<Type>%SQLQuery</Type>
<FormalSpec>offset:%Integer,limit:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>  
  SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN :offset AND :limit</SqlQuery>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.F50C.StudentD</DataLocation>
<DefaultData>StudentDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.F50C.StudentD</IdLocation>
<IndexLocation>^Frontier.UnitTest.F50C.StudentI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.F50C.StudentS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="StudentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Class</Value>
</Value>
<Value name="4">
<Value>BirthDate</Value>
</Value>
<Value name="5">
<Value>SomeValue</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="BirthDate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>12.5000%</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Name">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>16.6</AverageFieldSize>
</Property>
<Property name="SomeValue">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>7</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Reporter.Email">
<Super>Frontier.Reporter.Email</Super>
<TimeCreated>64538,36222.588241</TimeCreated>

<Method name="SetupAccount">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // If you want to test this reporter you need to configure the following properties.
  set ..SMTPServerLocation = "smtp.youremailhost.com" 
  set ..SMTPServerPort = 25 // Your SMTP server port
  set ..SenderEmail = "sender_email@email.com"
  set ..SenderPassword = "sender_password"
  set ..DestinationEmail = "destination@email.com"
  set ..TemplateLocation = "/InterSystems/Cache/CSP/user/email-template.html"
  set ..SSLConfiguration = "SSL Configuration name"
  set ..UseSTARTTLS = 1 // 1, "" or 0
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Reporter.Mock">
<Super>Frontier.Reporter</Super>
<TimeCreated>64540,40870.642496</TimeCreated>

<Property name="ExpectedSetupStatus">
<Type>%Status</Type>
</Property>

<Property name="ExpectedReportStatus">
<Type>%Status</Type>
</Property>

<Method name="Setup">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier.UnitTest.Spy("Setup", $this) = context
  return ..ExpectedSetupStatus
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier.UnitTest.Spy("Report", $this) = context
  return ..ExpectedReportStatus
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router">
<Super>Frontier.Router</Super>
<TimeCreated>64503,35090.481271</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/route-params/:class" Method="GET" Call="TestGETRouteParams"/>
<Route Url="/query-params" Method="GET" Call="TestGETOneQueryParameter"/>
<Route Url="/rest-params" Method="GET" Call="TestGETRestParametersSum"/>
<Route Url="/sql/dynamic" Method="GET" Call="TestGETDynamicSQLResult"/>
<Route Url="/sql/query" Method="GET" Call="TestGETQuerySQLResult"/>
<Route Url="/raw" Method="GET" Call="TestGETRawMode"/>
<Route Url="/shared_data" Method="GET" Call="TestGETData"/>
<Route Url="/stream" Method="GET" Call="TestGETStream"/>
<Route Url="/alias" Method="GET" Call="TestGETAliasedQueryParameter"/>
<Route Url="/payload/single-object" Method="POST" Call="TestPOSTObjectPayloadSingle"/>
<Route Url="/payload/object-with-query-params" Method="POST" Call="TestPOSTObjectPayloadQueryParams"/>  
<Route Url="/payload/single-array" Method="POST" Call="TestPOSTArrayPayloadSingle"/>
<Route Url="/payload/array-with-query-params" Method="POST" Call="TestPOSTArrayPayloadQueryParams"/>
<Route Url="/payload/invalid" Method="POST" Call="TestPOSTInvalidPayload"/>
<Route Url="/mixed/object" Method="GET" Call="TestGETMixedDynamicObject"/>
<Route Url="/mixed/array" Method="GET" Call="TestGETMixedDynamicArray"/>
<Route Url="/mixed/rest" Method="POST" Call="TestPOSTMixedRestParametersSum"/>
<Route Url="/unmarshall" Method="POST" Call="TestPOSTUnmarshallToClass"/>
<Route Url="/unmarshall/:classId" Method="PUT" Call="TestPUTUnmarshallToClass"/>
<Route Url="/user-info" Method="GET" Call="TestGETSessionUserInfo"/>
<Route Url="/errors/siblings" Method="GET" Call="TestGETMultipleSiblingErrors"/>
<Route Url="/arguments/no-weakly-typed" Method="GET" Call="TestGETNoWeaklyTypedArgs"/>
<Route Url="/methods/no-weakly-typed" Method="GET" Call="TestGETNoWeaklyTypedMethods" />
<Map Prefix="/map/A/:param1" Forward="Frontier.UnitTest.Router.Map.A" />
<Map Prefix="/map/B/:param1/:param2" Forward="Frontier.UnitTest.Router.Map.B" />
<Map Prefix="/map/C" Forward="Frontier.UnitTest.Router.Map.C" />
<Map Prefix="/map/D/:paramA/fixed/:paramB" Forward="Frontier.UnitTest.Router.Map.D"/> 
<Map Prefix="/map/E/(match)" Strict="false" Forward="Frontier.UnitTest.Router.Map.E"/>
</Routes>
]]></Data>
</XData>

<Method name="OnDataSet">
<Description>
Use this method to share data between methods.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  /// This 'data' object is shared between all methods. Accessible using %frontier.Data.
  set data.Message = "This 'Message' is shared between all methods."
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<Description>
This method is reserved for setting up configurations.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  // Reporters should be used to signal the developer about request errors.   
  // $$$QuitOnError(%frontier.ReporterManager.AddReporter(##class(MyReporter.Email).%New()))  
  
  // Asks the user for a Basic + Base64(username:password) encoded Authorization header.
  set basicStrategy = ##class(Frontier.Authentication.BasicStrategy).%New({
    "realm": "tests", 
    "validator": ($classname()_":ValidateCredentials")
  })  
  
  // This provides a way to check if the current user is authenticated using Basic scheme.
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(basicStrategy))  
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Description>
Whenever a parameter is typed of %Persistent and a valid id is provided, the parameter will be instantiated.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/route-params/6' 
{"Plate":"O5397","Students":[{"Name":"Drabek,Peter T.","__id__":"20"}],"__id__":"6"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return class
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Description>
Query parameters are also supported and are fetched if the parameter name matches the URL query name.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/query-params?msg=hello'
{result":"hello"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "hello"
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Description><![CDATA[
Rest parameters are sequential query parameters. They can have flexible arity and have the format parameterN.
This request takes that number of parameters and sum them.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/rest-params?n1=10&n2=20&n3=30']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n...:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set sum = 0
  for i=1:1:n  set sum = sum + n(i)
  return sum
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Description><![CDATA[
Dynamic SQL queries can be returned as long as the Frontier SQL API is used.
For SQL, the usage of Prepare() from frontier.SQL API is required.
Call example:
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/dynamic?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows
  
  return %frontier.SQL.Prepare(
    "SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?"
  ).Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Description><![CDATA[
The same applies for named (cached) SQL queries. Notice that they can be called by providing
the class:queryname instead of a dynamic SQL.
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/query?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows     
    
  return %frontier.SQL.Prepare("Frontier.UnitTest.Fixtures.Student:PaginatedStudents").Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Description>
There can be cases where the response should not be a JSON.
This method shows how to output a text in plain format.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/raw</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  return "hello raw response"
]]></Implementation>
</Method>

<Method name="TestGETData">
<Description>
This method uses the data object provided on Setup method.
The idea is to demonstrate how to access shared data.
Call example: 
/// curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/shared_data' </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return %frontier.Data
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Description>
This method demonstrates how %Stream.Object based instances are treated.
Call example: 
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/stream'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  set stream = ##class(%Stream.GlobalCharacter).%New()
  do stream.Write("This line is from a stream.")
  
  return stream
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Description>
If the request is a POST/PUT/PATCH method, it can receive a payload that's represented by a parameter typed of %DynamicObject instances.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/single-object'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Description>
Request can have a payload along with a query parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/object-with-query-params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String="",payload:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return {
    "msg": (msg),
    "payload": (payload)
  }
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Description>
Payloads can also be an array.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/single-array'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Description>
Requests with array payloads also support query parameters.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/array-with-query-params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject,msg:%String=""</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (msg), (payload) ]
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Description>
This demonstrates payload validation, as browsers can receive one payload per request
a classmethod that expects more than one is considered invalid and will throw an exception.
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/invalid'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payloadA:%DynamicArray,payloadB:%DynamicObject</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return payloadA
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Description>
Normally %Dynamic instances cannot serialize childrens that aren't dynamic as well. (%ToJSON would thrown an exception).
Frontier fixes it by marshalling irregular to %Dynamic instances beforehand and making it compatible.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/object?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "class": (class)
  }
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Description>
Also supported for %DynamicArray.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/array?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (class) ]
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Description><![CDATA[
It's possible to mix multiple parameter types as you could when calling a method.
The example below illustrates the usage of a method that receives a 'msg' query parameter along with a payload and a rest parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/mixed/rest?n1=10&n2=20&msg=hello']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,data:%DynamicObject,n...:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 
  set parameters = []  
  set sum = 0
  for i=1:1:n  set sum = sum + n(i) do parameters.%Push(n(i))
  return {
    "sum": (sum),
    "data": (data),
    "params": (parameters),
    "msg": (msg)
  }
  return sum
]]></Implementation>
</Method>

<Method name="TestGETAliasedQueryParameter">
<Description>
For compability with existing clients that use query parameters with symbols. For such cases
ALIAS can be used to make it compatible. If the expected alias is not found then Frontier will 
fall back to using the argument name instead.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String(ALIAS="aliased_key")</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return msg
]]></Implementation>
</Method>

<Method name="TestPOSTUnmarshallToClass">
<Description>
It's also possible to save from a payload directly to a %Persistent instance as long as the payload
has the same format as the %Persistent class. Just define the the parameter UNMARSHALLTO with the class you want
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshall'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%DynamicObject(UNMARSHALLTO="Frontier.UnitTest.Fixtures.Class")</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="TestPUTUnmarshallToClass">
<Description>
You can also edit the entity just by providing the property "__id__" along with the new payload data. If you want the id to be read from the URL,
add a new parameter and map the unmarshaller to use it as id by specifying the IDCOLUMN. If the named IDCOLUMN is not
found, the id will be searched inside the payload. Note that when the id is not found, an exception will be thrown regarding  the
incorrect PUT usage.
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshall/15'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%DynamicObject(UNMARSHALLTO="Frontier.UnitTest.Fixtures.Class",IDFROM="classId"),classId:%Integer</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="TestGETSessionUserInfo">
<Description>
This method depends on the authorization header sent by the client and validated with the validator method.
The validator method is also responsible for defining the user object.
Call example:
curl -H "Authorization: Basic Zm9vOmJhcg==" 'http://localhost:57772/api/frontier/test/user'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return %frontier.User
]]></Implementation>
</Method>

<Method name="TestGETMultipleSiblingErrors">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc1 = $$$ERROR($$$GeneralError, "First")  
  
  set sc2 = $$$ERROR($$$GeneralError, "Second")
  set sc3 = $$$ERROR($$$GeneralError, "Third") 
  set sc3 = $$$EMBEDSC(sc3, $$$ERROR($$$QueryNameTooLong, "Child")) 
  set sc1 = $$$ADDSC(sc1, sc2)
  set sc1 = $$$ADDSC(sc1, sc3)
  $$$ThrowOnError(sc1)
]]></Implementation>
</Method>

<Method name="TestGETNoWeaklyTypedArgs">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%String="",b="",c,d:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETNoWeaklyTypedMethods">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="ValidateCredentials">
<ClassMethod>1</ClassMethod>
<FormalSpec>login:%String,password:%String,found:%Boolean=1,*httpStatus:%String,*user:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set useScope = 0
  if login = "foo" && (password = "bar") set found = 1  
  if login = "admin" && (password = "admin") set found = 1 set useScope = 1
  if found set httpStatus = ..#HTTP200OK
  else  set httpStatus = ..#HTTP403FORBIDDEN
  
  set user = { 
    "login": (login)
  }
  
  if useScope {
    set user.scope = "admin"
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.A">
<Super>Frontier.Router</Super>
<TimeCreated>64573,30152.808473</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
   <Route Url="/route-parameter-not-specified" Method="GET" Call="TestGETRouteParameterNotSpecified" />
   <Route Url="/pass-route-param-to-child" Method="GET" Call="TestGETPassRouteParamToChild" />
   <Route Url="/prioritize-route-parameter" Method="GET" Call="TestGETPrioritizeRouteParameter" />
 </Routes>
]]></Data>
</XData>

<Method name="TestGETRouteParameterNotSpecified">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "this wont be returned"
]]></Implementation>
</Method>

<Method name="TestGETPassRouteParamToChild">
<ClassMethod>1</ClassMethod>
<FormalSpec>param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1
]]></Implementation>
</Method>

<Method name="TestGETPrioritizeRouteParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec>param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.B">
<Super>Frontier.Router</Super>
<TimeCreated>64573,34962.694117</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
    <Route Url="/" Method="GET" Call="TestGETMultipleRouteParameters" />
    <Route Url="/something_(up|down)" Strict="false" Method="GET" Call="TestMe" />
  </Routes>
]]></Data>
</XData>

<Method name="TestMe">
<ClassMethod>1</ClassMethod>
<FormalSpec>matches:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return matches
]]></Implementation>
</Method>

<Method name="TestGETMultipleRouteParameters">
<ClassMethod>1</ClassMethod>
<FormalSpec>param2:%String,param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1_" "_param2
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.C">
<Super>Frontier.Router</Super>
<TimeCreated>64573,35614.836117</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
 <Map Prefix="/no-self-forwarding" Forward="Frontier.UnitTest.Router.Map.C" />
 <Route Url="/" Method="GET" Call="TestGETRouteWithoutParameters" />
 <Route Url="/:id" Method="GET" Call="TestGETRouteWithoutParametersA" />
 <Route Url="/scoped" Method="GET" Scope="admin" Call="TestGETScopedResponse" />
 <Route Url="/auth/bypass" Method="GET" UseAuth="false" Call="TestGETBypassAuth" />
</Routes>
]]></Data>
</XData>

<Method name="TestGETRouteWithoutParameters">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "Hello from a simple but mapped route!"
]]></Implementation>
</Method>

<Method name="TestGETRouteWithoutParametersA">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return id
]]></Implementation>
</Method>

<Method name="TestGETScopedResponse">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $$$FormatText("Hello %1! If you're seeing this, then you have enough privilege for that!", %frontier.User.login)
]]></Implementation>
</Method>

<Method name="TestGETBypassAuth">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 
  return "This is an unprotected resource!"
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.D">
<Super>Frontier.Router</Super>
<TimeCreated>64573,37233.838307</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
 <Route Url="/parent-sparse-params/:operation" Method="GET" Call="TestGETParentSparseParams"/>
</Routes>
]]></Data>
</XData>

<Method name="TestGETParentSparseParams">
<ClassMethod>1</ClassMethod>
<FormalSpec>operation:%String,paramA:%Integer,paramB:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  if operation = "sum" return paramA + paramB
  if operation = "subtract" return paramA - paramB
  if operation = "divide" return paramA / paramB
  if operation = "multiply" return paramA * paramB
  return 0
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.E">
<Super>Frontier.Router</Super>
<TimeCreated>64574,39559.82603</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/get-parent-and-(this)-(group)" Strict="false" Method="GET" Call="TestGETMultipleRegexMatches" />
</Routes>
]]></Data>
</XData>

<Method name="TestGETMultipleRegexMatches">
<ClassMethod>1</ClassMethod>
<FormalSpec>matches...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return [ (matches(1)), (matches(2)), (matches(3)) ]
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64503,34684.599157</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Method name="CreateWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set targetNamespace = $namespace
  
  new $namespace  
  set $namespace = "%SYS"
  
  write !, ">> Creating demo web application using namespace "_targetNamespace_" ..."
  if ##class(Security.Applications).Exists(..#NAME) {
    write !, ">> Application already exists, skipping ..."
    return $$$OK
  }
  
  set properties("CookiePath") = ..#NAME
  set properties("DispatchClass") = "Frontier.UnitTest.Router"
  set properties("EventClass") = "Frontier.SessionEvents"
  set properties("NameSpace") = targetNamespace
  set properties("UseCookies") = 2
  set properties("AutheEnabled") = 64
  
  $$$QuitOnError(##class(Security.Applications).Create(..#NAME, .properties))
  write !, ">> Application /api/frontier/test has been created."
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  
  if '##class(Security.Applications).Exists(..#NAME) return $$$OK
  write !, ">> Deleting demo web application "_..#NAME_" ..."
  
  $$$QuitOnError(##class(Security.Applications).Delete(..#NAME))
  write !, ">> Web application has been deleted with success."
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="MergeErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec>errors:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  for i=0:1:(errors.%Size() - 1) {
    set errorObject = errors.%Get(i)
    set sc = $$$ADDSC(sc, $$$ERROR(errorObject.code, errorObject.params.%Get(0)))
  }
  
  return sc
]]></Implementation>
</Method>

<Method name="MarshallSQLResult">
<ClassMethod>1</ClassMethod>
<FormalSpec>SQLResult:%IResultSet,*dynamicArray:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set dynamicArray = []
  set columnInfo = ""
  
  set columnsCount = SQLResult.%ResultColumnCount
  for c = 1:1:columnsCount {
    set columnInfo(c,"name") = SQLResult.%GetMetadata().columns.GetAt(c).label
  }  
  
  while (SQLResult.%Next(.sc)) {
    quit:$$$ISERR(sc)
    set node = {}
    for c = 1:1:SQLResult.%ResultColumnCount {
      set value = SQLResult.%GetData(c)
        
      if ($isvalidnum(value) && ($e(value) '= 0)) do node.%Set($get(columnInfo(c,"name")),$num(value),"number")
      else  do node.%Set($get(columnInfo(c,"name")),value)
    }
    Do dynamicArray.%Push(node)
  }
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplicationInstaller">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64530,35966.171067</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Projection name="Installer">
<Type>Frontier.UnitTest.WebApplicationInstaller</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).Populate())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).Populate())  
  return ##class(Frontier.UnitTest.Util).CreateWebApplication()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())  
  return ##class(Frontier.UnitTest.Util).RemoveWebApplication()
]]></Implementation>
</Method>
</Class>


<CSP name="email-template.html" application="/csp/dev/" default="1"><![CDATA[
<!DOCTYPE html>
<html>
<body style="font-family: monospace, 'Courier New', Verdana, sans-serif;">
  <table border=0>
    <thead>
      <tr>
        <th colspan="2" style="font-size: 16px; width: 560px; text-align: center; background-color: #c11b1b; color: #fff9f9;">
          REQUEST ERROR REPORT
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Description</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%1</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">URL</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%2</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Class</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%3</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Method</th>
        <td align="left">%4</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Arguments</th>
        <td align="left">%5</td>
      </tr>
      <tr>
        <th style="text-align: center; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Stack</th>
        <td align="left">%6</td>
      </tr>
 </body>
 </html>
  </tbody>
</table>
]]></CSP>


<Routine name="frontier" type="INC"><![CDATA[
#include %ZEN.Utils

#define ltrim(%str)       $zstrip(%str, "<W")
#define rtrim(%str)       $zstrip(%str, ">W")
#define trim(%str)        $zstrip(%str, "<>W")
#define trimQuote(%str)   $zstrip(%str, "<>", $c(34))
#define IsSQLQuery(%str)  ($$$ucase($extract($$$trim(%str), 6)) = "SELECT")
#define KeyGroup(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "=>N")
#define KeyIndex(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "<=A")
#define FormatBoolean(%value) $case(%value, 1: "true", 0: "false", : %value)
#define BooleanToBinary(%value) $case(%value, "true": 1, "false": 0, : %value)
#define NormalizeClassName(%cn) if $l(%cn, ".") = 1 && ($e(%cn) = "%") set %cn = "%Library."_$e(%cn, 2, *)
]]></Routine>
</Export>
