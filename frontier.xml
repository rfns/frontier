<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Frontier.AbstractSerializer">
<Abstract>1</Abstract>
<TimeCreated>64553,37866.500056</TimeCreated>

<Method name="SerializeToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,*str:%Stream.Object="",propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new oldMnemonic, alreadyRedirected, sc, className
  
  set sc = $$$OK
  set isRedirected = 0
  
  set str = ##class(%Stream.TmpBinary).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
  set initIO = $io
  
  try {    
    use $io::("^"_$zname)
    
    do ##class(%Device).ReDirectIO(1)
    set isRedirected = 1
    set className = $classname()
    set sc = ..Serialize(dynamic, 1, propertyFormatter)
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }
  
  do str.Rewind()  
  
  if oldMnemonic '= "" {
    use initIO::(oldMnemonic)
  } else {
    use oldMnemonic
  }
  
  do ##class(%Device).ReDirectIO(alreadyRedirected)  
      
  return sc
  
wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.ArgumentDescription">
<Super>%RegisteredObject</Super>
<TimeCreated>64492,37806.502663</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Alias">
<Type>%String</Type>
</Property>

<Property name="DefaultValue">
<Type>%String</Type>
</Property>

<Property name="HasDefaultValue">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Arity">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<Property name="Index">
<Type>%Integer</Type>
<Required>1</Required>
</Property>
</Class>


<Class name="Frontier.Authentication.BasicStrategy">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64553,59181.195484</TimeCreated>

<Property name="Realm">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Validator">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Realm = config.realm
  set ..Validator = config.validator
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set found = 0
  set httpStatus = ""
  set authHeader = request.GetCgiEnv("HTTP_AUTHORIZATION")
  
  if authHeader = "" {
	  set ..Next = 1
    return $$CreateError("You must be authenticated to access this resource.")
  }
  
  if $extract(authHeader, 1, 5) '= "Basic" {
	  set ..Next = 1
    return $$CreateError("Malformed authorization header.", "400 Bad Request")
  }

  set credentials = $System.Encryption.Base64Decode($piece(authHeader, " ", 2))
    
  set userName = $piece(credentials, ":")
  set password = $piece(credentials, ":", 2)  
  
  if ..Validator '= "" {
    set class = $piece(..Validator, ":")
    set method = $piece(..Validator, ":", 2)
    try {
      set sc = $classmethod(class, method, userName, password, .found, .httpStatus, .user)
    } catch ex {
      set sc = ex.AsStatus()
    }
  } else {
    return $$CreateError("Credentials validator was not specified", "500 Internal Server Error")
  }
  
  if httpStatus = "" {
    set httpStatus = "500 Internal Server Error"
  }
  
  if 'found {
    return $$CreateError("Unknown user or password.", "403 Forbidden")  
  }  
  
  return sc
  
CreateError(message, status="401 Unauthorized", isStatus=0)
  set response.Status = status
  if 'isStatus return $$$ERROR($$$GeneralError, message) 
  return message
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "Basic realm="""_..Realm_""""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Manager">
<Super>%RegisteredObject</Super>
<TimeCreated>64553,52230.315441</TimeCreated>

<Property name="Strategies">
<Type>Frontier.Authentication.Strategy</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="ScopeSeparator">
<Type>%String</Type>
<InitialExpression>" "</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  return $$$OK
]]></Implementation>
</Method>

<Method name="ScopeSeparatorSet">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	set i%ScopeSeparator = $get(value, ",")
]]></Implementation>
</Method>

<Method name="AddStrategy">
<FormalSpec>strategy:Frontier.Authentication.Strategy</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  $$$QuitOnError(..Strategies.Insert(strategy))  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set totalStrategies = ..Strategies.Count()
  set strategy = "" 
  
  try {
    for i=1:1:totalStrategies {
      set strategy = ..Strategies.GetAt(i)
      set sc = strategy.Verify(..Session, ..Request, ..Response, .user, resourceScope)
      if $$$ISOK(sc) {
	      quit
      } elseif 'strategy.Next {
		    set challengeSC = strategy.GetChallenge(..Session, ..Request, ..Response, .challenge)
				if $$$ISOK(challengeSC) do ..Response.SetHeader("WWW-Authenticate", challenge)
				quit		    
      }
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="CheckResourceScope">
<FormalSpec>resourceScope:%String="",authenticationScope:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if resourceScope '= "" return $lf($lfs(authenticationScope, ..ScopeSeparator), resourceScope) > 0
  return 1
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Strategy">
<Super>%RegisteredObject</Super>
<TimeCreated>64553,51285.209032</TimeCreated>

<Property name="Next">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="NextSet">
<FormalSpec>value:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set i%Next = +value
	return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$ERROR($$$MethodNotImplemented, "GetChallenge")
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.StrategyCombiner">
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64555,31799.710747</TimeCreated>

<Property name="Strategies">
<Type>Frontier.Authentication.Strategy</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Method name="Combine">
<FormalSpec>strategies...:Frontier.Authentication.Strategy</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  for i=1=1:strategies {
    set strategy = strategies(i)
    set sc = ..Strategies.Insert(strategy)
    if $$$ISERR(sc) return sc
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  for i=1:1:..Strategies.Count() {
    set sc = ..Strategies.Verify(session, request, response, .user)
    if $$$ISERR(sc) return sc
  }
  
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Util">
<Abstract>1</Abstract>
<TimeCreated>64555,36131.383877</TimeCreated>

<Method name="GenerateRandomString">
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer,caseType:%String="uppercase",extras:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set key = ""
  set alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  if caseType = "mixed" set alpha = alpha_$$$lcase(alpha)
  if caseType = "lower" set alpha = $$$lcase(alpha)
  if extras '= "" set alpha = alpha_extras
  
  while $length(key) < size {
    set next = $select($random(2) = 1 : $extract(alpha, $random($length(alpha))), 1: $random(9))
    set key = key_next
  }
  return key
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Context">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,31617.993909</TimeCreated>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="CharSet">
<Type>%String</Type>
<InitialExpression>"utf-8"</InitialExpression>
</Property>

<Property name="RequestURL">
<Type>%String</Type>
</Property>

<Property name="Method">
<Type>%String</Type>
</Property>

<Property name="ClassName">
<Type>%String</Type>
</Property>

<Property name="ArgumentValues">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Stack">
<Type>%String</Type>
<Internal>1</Internal>
</Property>

<Property name="Error">
<Type>%Status</Type>
<Internal>1</Internal>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="SQL">
<Type>Frontier.SQL</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ReporterManager">
<Type>Frontier.Reporter.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="AuthenticationManager">
<Type>Frontier.Authentication.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Data">
<Type>%DynamicObject</Type>
</Property>

<Property name="ThrownByApplication">
<Type>%Boolean</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DirectWrite">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="User">
<Type>%DynamicObject</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PropertyFormatter">
<Type>Frontier.PropertyFormatter</Type>
</Property>

<Property name="StrictQueryParameters">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  set i%SQL = ##class(Frontier.SQL).%New()
  set i%ReporterManager = ##class(Frontier.Reporter.Manager).%New($this)
  set i%AuthenticationManager = ##class(Frontier.Authentication.Manager).%New(..Session, ..Request, ..Response)
  set i%ArgumentValues = 0  
  set ..Data = ##class(%DynamicObject).%New()
  do ..Response.SetHeader("Content-Type", "application/json")
  set ..CharSet = "utf-8"  
  return $$$OK
]]></Implementation>
</Method>

<Method name="CharSetSet">
<FormalSpec>charset:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.CharSet = charset
  set ..Response.HeaderCharSet = charset  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Raw">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/plain")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsRaw">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/plain"
]]></Implementation>
</Method>

<Method name="HTML">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/html")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsHTML">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/html"
]]></Implementation>
</Method>

<Method name="JSON">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "application/json")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsJSON">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "application/json"
]]></Implementation>
</Method>

<Method name="Status">
<FormalSpec>statusCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.Status = statusCode
  return $$$OK
]]></Implementation>
</Method>

<Method name="ThrowException">
<FormalSpec>message:%String,statusCode:%Integer=$$$GeneralError,parameters...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(parameters) set parameters = 0
  set args = 2 + parameters
  set args(1) = statusCode
  set args(2) = message
  
  for i=1:1:parameters set args(2+i) = parameters(i)
  set i%ThrownByApplication = 1
  throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(args...))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Marshaller">
<Super>%RegisteredObject</Super>
<TimeCreated>64502,32993.705412</TimeCreated>

<Property name="Cache">
<Type>%DynamicObject</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Properties">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="DropCyclicReferences">
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$OK
]]></Implementation>
</Method>

<Method name="PropertiesSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Properties = $lfs(value)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Marshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicAbstractObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  if $isobject(object) {
    set type = $classname(object)
    if ##class(Frontier.Types).IsCollection(type) return marshaller.MakeDynamicCollection(object, .dynamicObject)
    if ##class(Frontier.Types).IsDynamic(type) return marshaller.MarshallPartial(object, .dynamicObject)
    if ##class(Frontier.Types).IsInstantiable(type) return marshaller.MakeDynamicObject(object, .dynamicObject)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="MarshallPartial">
<FormalSpec>dynamicInstance:%DynamicAbstractObject,marshalledObject:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set iterator = dynamicInstance.%GetIterator()
  set marshalledObject = $System.OBJ.New($classname(dynamicInstance))
  set dynamicValueResult = ""
  
  while iterator.%GetNext(.key, .value) {
    set dynamicValueResult = value
    if $isobject(value) {
      set valueType = $classname(value)
      set isDynamic = ##class(Frontier.Types).IsDynamic(valueType)
      set isStream = ##class(Frontier.Types).IsStream(valueType)
      set isSQLProvider = ##class(Frontier.Types).IsSQLProvider(valueType)
      if isDynamic {
        set sc = ..MarshallPartial(value, .dynamicValueResult)       
      } elseif 'isStream && 'isSQLProvider {
        set sc = ..Marshall(value, .dynamicValueResult)
      }
      if $$$ISERR(sc) return sc
    }
    do marshalledObject.%Set(key, dynamicValueResult)
  }
  return sc
]]></Implementation>
</Method>

<Method name="MarshallCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%RegisteredObject,*dynamicCollection:%DynamicObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  quit marshaller.MakeDynamicCollection(collection, .dynamicCollection)
]]></Implementation>
</Method>

<Method name="MakeDynamicObject">
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicObject="",parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK     
  
  // Temporary table to reuse processed instances.
  if $data(i%Cache(object)) {
    quit $$$OK
  } else {
    set dynamicObject = ##class(%DynamicObject).%New()
    set i%Cache(object) = dynamicObject
  }
    
  set isSameObject = 0
  set affectedProperties = ""
  set classDescriptors = ##class(%Dictionary.CompiledClass).%OpenId($classname(object))
  
  if $lv(..Properties) && (..Properties '= "") {
    set affectedProperties = ##class(%ListOfObjects).%New()
    for i=1:1:classDescriptors.Properties.Count() {
      set propertyDescriptors = classDescriptors.Properties.GetAt(i)
      if $lf(..Properties, propertyDescriptors.Name) {
        set sc = affectedProperties.Insert(propertyDescriptors)
      }
    }
  } else {
    set affectedProperties = classDescriptors.Properties
  }  
    
  for i=1:1:affectedProperties.Count() {    
    set propertyDescriptors = affectedProperties.GetAt(i)    
    if '$isobject(propertyDescriptors) continue    
    if propertyDescriptors.Private || propertyDescriptors.Internal || ($extract(propertyDescriptors.Name) = "%") continue    
    if $isobject(parentObject) && ($classname(parentObject) = propertyDescriptors.Type) && 
      (parentKey = propertyDescriptors.Name) && (propertyDescriptors.Cardinality '= "") {
      // Prevents the buffer from overflowing by skipping parent relationship serialization.
      // DO NOT DISABLE THIS FLAG WHEN SERIALIZING TO JSON!
      if '..DropCyclicReferences set $property(dynamicObject, parentKey) = i%Cache(parentObject)
      continue
    }    
    set value = $property(object, propertyDescriptors.Name)
    if $isobject(value) {
      if value.%IsA("%RelationshipObject") {
        set parentObject = object               
        set parentKey = propertyDescriptors.Inverse
      }
      if propertyDescriptors.Collection = "" {        
        if value.%Extends("%Stream.Object") {
          set dynamicChild = $System.OBJ.New($classname(value))
          set sc = dynamicChild.CopyFrom(value)
          if $$$ISERR(sc) quit
        } else {          
          set sc = ..MakeDynamicObject(value, .dynamicChild)
        }        
      } else {
        set sc = ..MakeDynamicCollection(value, .dynamicChild, parentKey, parentObject)          
      }
      if $$$ISERR(sc) quit
      set $property(dynamicObject, propertyDescriptors.Name) = dynamicChild                  
    } else {
      set internalValue = $property(object, propertyDescriptors.Name)
      set $property(dynamicObject, propertyDescriptors.Name) = internalValue
      if ##class(%Dictionary.CompiledMethod).%ExistsId(propertyDescriptors.Type_"||LogicalToDisplay") {                
        set externalValue = $classmethod(propertyDescriptors.Type, "LogicalToDisplay", internalValue)
        if externalValue '= internalValue {
          set $property(dynamicObject, propertyDescriptors.Name_"__x") = externalValue
        }
      }
    }      
  }  
  if object.%Extends("%Persistent") {
    if $lf(..Properties, "__id__") || (..Properties = "") {
      set id = object.%Id()
      if id '= "" set $property(dynamicObject, "__id__") = object.%Id()
    }
  }      
  quit sc
]]></Implementation>
</Method>

<Method name="MakeDynamicCollection">
<FormalSpec>collection:%Collection.Super,*dynamicCollection:%String,parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK   
  set startOffset = 0
  set cyclicReferenceTrap = 0
      
  if collection.%IsA("%Collection.AbstractList") || collection.%IsA("%RelationshipObject") {
    set startOffset = 1
    set dynamicCollection = []
  } else {
    set dynamicCollection = {}
  }
   
  set key = ""
  set item = collection.GetNext(.key)
  
  while key {  
    if $isobject(item) {
      if item.%IsA("%Collection.AbstractIterator") {
        set sc = ..MakeDynamicCollection(item , .value)
      } else {
        set sc = ..MakeDynamicObject(item, .value, parentKey, parentObject)
        set cyclicReferenceTrap = (value = "")
      }
    } else {
      set value = item
    }
    if 'cyclicReferenceTrap do dynamicCollection.%Set(key - startOffset, value)    
    if $$$ISERR(sc) quit
    
    set item = collection.GetNext(.key)
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Serializer">
<IncludeCode>frontier,%ZEN.Utils</IncludeCode>
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64531,58689.528672</TimeCreated>

<Method name="Serialize">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,depth:%String=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set results = ""
  set isArray = ##class(Frontier.Types).IsDynamicArray($classname(dynamic))    
  
  if isArray {
    write "["
  } else {
    write "{"
  }
  
  set iterator = dynamic.%GetIterator()   
  set comma = ""  
  
  while iterator.%GetNext(.key, .value) {   
    write comma
    set comma = ","
    set propertyName = key
    
    if $isobject(propertyFormatter) {
      set propertyName = propertyFormatter.Format(propertyName, depth)
    }
    
    if 'isArray {
      write $$$ZENJSONPROP(propertyName, "s")_":"
    }
    
    if $isobject(value) {
      set type = $classname(value)
      if ##class(Frontier.Types).IsDynamic(type) {         
        set sc = $$$ADDSC(sc, ..Serialize(value, depth, propertyFormatter))
      } elseif ##class(Frontier.Types).IsStream(type) {
        write $c(34)
        do WriteEscaped(value)
        write $c(34)        
      } elseif ##class(Frontier.Types).IsSQLProvider(type) {
        if 'value.StatementExecuted set sc = value.Execute()
        if $$$ISERR(sc) quit
        $$$ThrowOnError(##class(Frontier.SQL.Serializer).Serialize(value.Results, depth, propertyFormatter))
      }
    } else {
      write $$$ZENJSONVALUE(value, "s")
    }    
  }
  
  $$$QuitOnError(sc)
  
  if isArray write "]"
  else  write "}"
  
  return sc
  
WriteEscaped(v)
  set readCount = 0
  do v.Rewind()
  
  // Instead of using AtEnd, we compare the stream size with the buffer read size.
  // This is because apparently AtEnd doesn't track the position correctly when the device is redirected.
  // This can also be related to how we are dealing with this redirection along with %CSP.REST.
  while readCount < v.Size {
    set buffer = v.Read()
    set readCount = readCount + $length(buffer)
    write $$$ZENJSONESCAPE(buffer,"s")
  }
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Unmarshaller">
<Abstract>1</Abstract>
<TimeCreated>64505,55057.137365</TimeCreated>

<Method name="Unmarshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject="",propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $isobject(dynamicObject) {   
    set dynamicType = $classname(dynamicObject)
    set isCollection = ##class(Frontier.Types).IsCollection(className) || ##class(Frontier.Types).IsDynamicArray(className)    
    
    if ##class(Frontier.Types).IsDynamicArray(dynamicType) {
      return ..MakeCollection(className, dynamicObject, .registeredObject, 1, propertyFormatter)
    } elseif 'isCollection && ##class(Frontier.Types).IsDynamicObject(dynamicType) && ##class(Frontier.Types).IsInstantiable(className) {
      return ..MakeObject(className, dynamicObject, .registeredObject, 1, propertyFormatter)
    }    
  }
  return $$$ERROR($$$GeneralError, "Cannot unmarshall data types.")
]]></Implementation>
</Method>

<Method name="MakeObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*object:%RegisteredObject="",depth:%String=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set object = ""
  set sc = $$$OK
  
  if '$isobject(dynamicObject) || ($isobject(dynamicObject) && 'dynamicObject.%IsA("%DynamicObject")) {
    quit $$$ERROR($$$GeneralError, "dynamicObject must be an instance of %DynamicObject.")
  }
  
  if dynamicObject.%IsDefined("__id__") {
    set object = $System.OBJ.OpenId(className, dynamicObject.%Get("__id__"))
  }
  
  set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(className)
  set properties = descriptor.Properties
  
  if $isobject(propertyFormatter) {
    do propertyFormatter.FormatFromCollection(descriptor.Properties, depth)
  }
  
  set propCount = properties.Count()
  
  set iterator = dynamicObject.%GetIterator()

  while iterator.%GetNext(.key, .value) {
    if key = "__id__" continue        
    set propertyId = className_"||"
    
    if $isobject(propertyFormatter) {
      set propertyId = propertyId_propertyFormatter.Normalize(key, depth)
    } else {
      set propertyId = propertyId_key
    }
    
    set property = ##class(%Dictionary.CompiledProperty).%OpenId(propertyId)    
    if '$isobject(property) continue
    
    if property.Private || property.Calculated || ($extract(property.Name) = "%") continue
    if '$isobject(object) {
      set object = $System.OBJ.New(className)
    }
    
    set dynamicObjectPropertyValue = $property(dynamicObject, key)
    set isDataType = '$isobject(dynamicObjectPropertyValue) && ##class(Frontier.Types).IsDataType(property.Type)
    set isSerial = ##class(Frontier.Types).IsSerial(property.Type)
    
    if 'isDataType {      
      if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%IsA("%DynamicObject") {
        set sc = ..MakeObject(property.Type, dynamicObjectPropertyValue, .dynamicChildInstance, propertyFormatter, depth + 1)          
        quit:$$$ISERR(sc)
        
        set $property(object, property.Name) = dynamicChildInstance
      } elseif ##class(Frontier.Types).IsStream(property.Type) {
        set childStream = $System.OBJ.New(property.Type)
        
        if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%Extends("%Stream.Object") {         
          do childStream.CopyFrom(dynamicObjectPropertyValue)
        } else {          
          do childStream.Write(dynamicObjectPropertyValue)
        }
        set $property(object, property.Name) = childStream
      } elseif isSerial {
        set $property(object, property.Name) = $classmethod(property.Type, "%Open", $lb(dynamicObjectPropertyValue, property.Type))
      } elseif property.Collection '= "" {
        set collectionType = $property(object, property.Name).ElementType
        set dynamicChildInstance = $property(object, property.Name)   
        
        if $isobject(dynamicObjectPropertyValue) {    
          set sc = ..MakeCollection(collectionType, dynamicObjectPropertyValue, .dynamicChildInstance, depth + 1)        
          quit:$$$ISERR(sc)
          set $property(object, property.Name) = dynamicChildInstance
        } elseif dynamicObjectPropertyValue '= "" {
          set value = dynamicObjectPropertyValue         
          set childInstance = $System.OBJ.OpenId(className, value)
          if $isobject(childInstance) {
            set $property(object, property.Name) = $property(childInstance, property.Name)
          }
        }
      } else {
        set childInstance = $System.OBJ.OpenId(property.Type, value)
        if $isobject(childInstance) set $property(object, property.Name) = childInstance                   
      }      
    } else {
      if dynamicObjectPropertyValue = "null" set dynamicObjectPropertyValue = ""  
      if property.Type = "%Library.Boolean" { set logicalValue = $case(value, "true" : 1, "false" : 0, 1 : 1, 0 : 0, : "") }
      elseif property.Type = "%Library.Date" && (dynamicObjectPropertyValue?4N1"-"2N1"-"2N1"T"2N1":"2N1":"2N1"."3N1"Z" = 1) { set logicalValue = $zdateh($piece(dynamicObjectPropertyValue,"T",1),3,,,,,,,dynamicObjectPropertyValue) }
      else {
        if isDataType && (##class(%Dictionary.CompiledMethod).%ExistsId(property.Type_"||IsValid") && ('$classmethod(property.Type, "IsValid", dynamicObjectPropertyValue) = 1)) {
          try {
            set logicalValue = $method(object, property.Name_"DisplayToLogical", dynamicObjectPropertyValue)            
          } catch {
            set logicalValue = dynamicObjectPropertyValue
          }
        } else {
          set logicalValue = dynamicObjectPropertyValue
        }
      }
      set $property(object, property.Name) = logicalValue     
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="MakeCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collectionType:%String,dynamicCollection:%DynamicAbstractObject,*collection:%Collection.Super="",depth:%Integer,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set insertStrategy = "list"
  set hasChildObjects = 0
  set collectionClass = "%ListOfDataTypes"
  set firstItem = dynamicCollection.%Get(0)
  set startOffset = 0  
  
  if collectionType [ "RelationshipObject" {
    set startOffset = 1
  } 
  
  if $isobject(firstItem) {    
    set hasChildObjects = '##class(Frontier.Types).IsDataType($classname(firstItem))   
  }
  
  if dynamicCollection.%IsA("%DynamicObject") {
    set insertStrategy = "Array"
    set collectionClass = $replace(collectionClass, "List", insertStrategy)
  }
  
  if hasChildObjects {
    set collectionClass = $replace(collectionClass, "OfDataTypes", "OfObjects")
  }
  
  // We must check for both occorences: 
  // 1 - When this method is called internally, so we already have the instance and can simply Clear it.
  // 2 - When we are generating it directly from a collection.
  if $isobject(collection) {
    do collection.Clear()
  } else {      
    set collection = $System.OBJ.New(collectionClass)
    set collection.ElementType = collectionType
  }
  
  set iterator = dynamicCollection.%GetIterator()
  set isPersistentItem = ##class(Frontier.Types).IsPersistent(collectionType)
  
  while iterator.%GetNext(.key, .dynamicItem) { 
    set isIdCandidate = '$isobject(dynamicItem) && (dynamicItem '= "")
    set itemClass = $select('isIdCandidate : $classname(dynamicItem), 1: "")
    
    if dynamicItem = "null" && (itemClass '= "") {
      continue      
    }    
    
    if isIdCandidate && isPersistentItem {
      set item = $System.OBJ.OpenId(collectionType, dynamicItem)
    } elseif $isobject(dynamicItem) { 
      set sc = $select(
        dynamicItem.%IsA("%DynamicObject") : ..MakeObject(collectionType, dynamicItem, .item, depth + 1, propertyFormatter),
        dynamicItem.%Extends("%DynamicArray") : ..MakeCollection(itemClass, dynamicItem, .item, depth + 1, propertyFormatter),
        1: $$$ERROR($$$GeneralError, "Cannot unmarshall items that aren't dynamic.")
      )
      if item = "" continue
    } else {
      set item = dynamicItem
    }
        
    if $$$ISERR(sc) quit    
    
    if insertStrategy = "Array" {
      set key = $select($isvalidnum(key) && (startOffset > 0): key + startOffset, 1: key)
      do collection.SetAt(item, key)
    } else {
      do collection.Insert(item)
    } 
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Exception">
<Super>%Exception.StatusException</Super>
<TimeCreated>64225,38503.046031</TimeCreated>

<Method name="CreateFromStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSC:%Status,errorIndex:%Integer=1</FormalSpec>
<ReturnType>Frontier.Exception</ReturnType>
<Implementation><![CDATA[
  #dim tException As %Exception.AbstractException
  #dim tData As %List
  #dim tInfo
  
  Set tException = $$$NULLOREF
  
  Do $SYSTEM.Status.DecomposeStatus(pSC,.tInfo, "pt-br")
  If $DATA(tInfo(1)) {
    // Build the exception object
    Set tData="" For tI=1:1:9 Set tData=tData_$LB(tInfo(errorIndex,"param",tI))
    Set tException = ..%New(tInfo(errorIndex,"code"),tInfo(errorIndex,"code"),$get(tInfo(errorIndex,"caller")),tData)
    
    // If there's an embedded error, construct that also
    If $DATA(tInfo(errorIndex,"embeddedstatus")) {
      Set tException.InnerException = ..CreateFromStatus(tInfo(errorIndex,"embeddedstatus"))
    }
    If $data(tInfo(errorIndex + 1)) Set tException.NextException=..CreateFromStatus(pSC, errorIndex + 1)
  }
  
  Quit tException
]]></Implementation>
</Method>

<Method name="ToDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()
  set de.error = ..BuildObjectGraph(exception)
  return de
]]></Implementation>
</Method>

<Method name="CreateInfoObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()    
  set de.internalCode = exception.Code
  
  set unfilteredErrorMessage = $System.Status.GetOneStatusText(exception.AsStatus(), 1)
  set errorMessage = $select(unfilteredErrorMessage [ $char(13, 10) : $extract(unfilteredErrorMessage, 1, $find(unfilteredErrorMessage, $c(13,10)) - 3), 1: unfilteredErrorMessage)
  if errorMessage?.ANPE1" > ".ANPE set errorMessage = $extract(errorMessage, 1, $find(errorMessage, " > ") - 2)
  set de.message = errorMessage
  return de
]]></Implementation>
</Method>

<Method name="BuildObjectGraph">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ..CreateInfoObject(exception)  
  
  if $isobject(exception.InnerException) {
    set de.from = ..ToDynamicObject(exception.InnerException)
  }
  
  if $isobject(exception) && ##class(%Dictionary.CompiledProperty).%ExistsId($classname(exception)_"||NextException") && $isobject(exception.NextException) {
    set nextExceptions = ##class(%ListOfObjects).%New()
    set de.next = nextExceptions
    
    set ex = exception.NextException
    while ex {
      do de.next.Insert(..CreateInfoObject(ex, 0))
      set ex = ex.NextException
    }
  }
  
  return de
]]></Implementation>
</Method>

<Method name="CaptureStack">
<ClassMethod>1</ClassMethod>
<FormalSpec>*stackText:%Stream.GlobalCharacter=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set stackText = ##class(%Stream.GlobalCharacter).%New()
    
  do stackText.WriteLine("Runtime exception ")
  set max = $stack(-1)
  for loop=max:-1:1 {
    set sc  = stackText.WriteLine($char(9)_"     at "_$stack(loop, "PLACE")_$stack(loop, "MCODE")_" (LV: "_loop_")")
    if $$$ISERR(sc) return sc
  }   
  return stackText.Read()
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Method">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,35961.209604</TimeCreated>

<Property name="MethodArguments">
<Type>ArgumentDescription</Type>
<Collection>list</Collection>
</Property>

<Property name="MethodDescriptor">
<Type>%Dictionary.CompiledMethod</Type>
<Private>1</Private>
</Property>

<Property name="ReturnTypeParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Payload">
<Type>%CacheString</Type>
</Property>

<Property name="HttpMethod">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="Arguments">
<Type>%CacheString</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>className:%String,methodName:%String,RESTMethodArguments:%String=0,request:%CSP.Request="",propertyFormatter:Frontier.PropertyFormatter="",strictMode:%Boolean=1</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set requestQueryParams = 0
  $$$ThrowOnError(..AssertMethodExists(className, methodName))
  
  set ..MethodDescriptor = ##class(%Dictionary.CompiledMethod).%OpenId(className_"||"_methodName)  
  
  $$$ThrowOnError(..DescribeArguments())
  $$$ThrowOnError(..ParseReturnTypeParameters())
  
  if $isobject(request) {
    set ..Payload = request.Content
    set ..HttpMethod = request.Method
    merge requestQueryParams = request.Data
  }
  
  $$$ThrowOnError(..MergeArguments(.RESTMethodArguments, .requestQueryParams, .mergedArguments, strictMode))    
  $$$ThrowOnError(..Sequentialize(.mergedArguments, propertyFormatter))
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DescribeArguments">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set describedArguments = ##class(%ListOfObjects).%New()
  set formalSpec = ..MethodDescriptor.FormalSpec
  set currentIndex = 0
  set currentPiece = 0
  
  while $$ParseArgument(.parsedArgument) {
    set sc = ..MethodArguments.Insert(parsedArgument)
    if $$$ISERR(sc) return sc
  }
  
  return sc 
 
ParseArgument(parsedArgument)
  set currentIndex = currentIndex + 1
  set currentPiece = currentPiece + 1
  set argument = $piece(formalSpec, ",", currentPiece)
  
  if argument [ "(" {
    while '$find(argument, ")") {
      set currentPiece = currentPiece + 1
      set argument = argument_","_$piece(formalSpec, ",", currentPiece)
    }
  }    
  
  if argument '= "" {
    set parsedArgument = ##class(Frontier.ArgumentDescription).%New()
    if argument [ "..." set parsedArgument.Arity = 1
    set parsedArgument.Name = $piece($replace($piece(argument, ":", 1), "...", ""), "=", 1)       
    set parsedArgument.Index = currentIndex
    set preType = $piece(argument, ":", 2)
    if preType [ "(" {      
      set parsedArgument.Type = $extract(preType, 1, $find(preType, "(") - 2)
      set maybeDefault = $piece(preType, "=", *)
      if $extract(maybeDefault, *) = ")" set maybeDefault =""
      set parsedArgument.DefaultValue = $$$trimQuote(maybeDefault)
      set argumentParameters = $extract(preType, $find(preType, "("), $find(preType, ")") - 2)
      if '$find(argumentParameters, ",") set argumentParameters = argumentParameters_","
      for i=1:1:$length(argumentParameters, ",") {
        set argumentParameter = $piece(argumentParameters, ",", i)
        quit:argumentParameter=""
        set parameterName = $piece(argumentParameter, "=")
        set parameterValue = $$$trimQuote($piece(argumentParameter, "=", 2))
        do parsedArgument.Parameters.SetAt(parameterValue, parameterName)
        if parameterName = "ALIAS" set parsedArgument.Alias = parameterValue
      }
    } else {      
      set parsedArgument.Type = $piece(preType, "=", 1)
      set defaultQuotedValue = $piece(preType, "=", 2)
      set parsedArgument.DefaultValue = $$$trimQuote(defaultQuotedValue)
      if defaultQuotedValue '= "" set parsedArgument.HasDefaultValue = 1
    }
    return 1
  }    
  return 0
]]></Implementation>
</Method>

<Method name="FindDescribedArgument">
<Internal>1</Internal>
<FormalSpec>identifier:%String</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.ArgumentDescription</ReturnType>
<Implementation><![CDATA[
  
  for i=1:1:..MethodArguments.Count() {
    set argument = ..MethodArguments.GetAt(i)
    if argument.Name = identifier || (argument.Alias = identifier) return argument
  }
  return ""
]]></Implementation>
</Method>

<Method name="ParseReturnTypeParameters">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set serializedParameters = ..MethodDescriptor.ReturnTypeParams
  if serializedParameters = "" return $$$OK
  set parametersCount = $length(serializedParameters, ",")  
  
  for i=1:1:parametersCount {
    set part = $piece(serializedParameters, ",", i)
    set parameterKey = $piece(part, "=", 1)
    set parameterValue = $piece(part, "=", 2)
    set i%ReturnTypeParameters(parameterKey) = parameterValue
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertMethodExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = className_"||"_methodName
  
  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$ClassDoesNotExist, className)   
  }    
  
  if '##class(%Dictionary.CompiledMethod).%ExistsId(id) {
    return $$$ERROR($$$MethodDoesNotExist, methodName)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Sequentialize">
<FormalSpec><![CDATA[&mergedArguments=0,propertyFormatter:Frontier.PropertyFormatter=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim methodArgument As Frontier.ArgumentDescription
  #define TriggerPayloadFlag if ..HttpMethod = "POST" || (..HttpMethod = "PUT") || (..HttpMethod = "PATCH") set payloadFound = 1
  #define AssertSinglePayloadParameter throw:payloadFound=1 ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, "Cannot have more than one payload for POST/PUT/PATCH requests."))
  
  set sc = $$$OK  
  
  set argsProcessed = 0  
  set payloadFound = 0
    
  set methodArgumentsLength = ..MethodArguments.Count()
  
  set jsonErrorMessage = "Invalid JSON format, expected a %1 compatible notation."  
  if $$$ISERR(sc) return sc  
  
  set maxLength = methodArgumentsLength
  if maxLength < mergedArguments set maxLength = mergedArguments
        
  if methodArgumentsLength > 0 {
    for argsProcessed=1:1:maxLength {       
      set methodArgument = $select(argsProcessed > methodArgumentsLength 
        :  ..MethodArguments.GetAt(methodArgumentsLength), 
        1: ..MethodArguments.GetAt(argsProcessed)
      )
      set value = $get(mergedArguments(argsProcessed))
    
      if value = "" {
        if 'methodArgument.Arity set value = methodArgument.DefaultValue
        else  set value = $get(mergedArguments(methodArgument.Index))
      }      
    
      if ##class(Frontier.Types).IsDynamic(methodArgument.Type) {
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set unmarshallTo = methodArgument.Parameters.GetAt("UNMARSHALLTO")
        set idColumn = methodArgument.Parameters.GetAt("IDCOLUMN")
        set value = $classmethod(methodArgument.Type, "%FromJSON", ..Payload)
        if unmarshallTo '= "" {
          set instanceId = value."__id__"    
          if idColumn '= "" {
            set value."__id__" = $get(mergedArguments(..FindDescribedArgument(idColumn).Index))
            if value."__id__" = "" set value."__id__" = instanceId
          }
          if value."__id__" = "" && (..HttpMethod = "PUT" || (..HttpMethod = "PATCH")) {
            return $$$ERROR($$$GeneralError, "Cannot unmarshall payload: a PUT/PATCH request requires an identifier.")
          }
          set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshall(unmarshallTo, value, .instance, propertyFormatter)
          if $$$ISERR(sc) return sc
          set value = instance
        } else {
          if value = "" return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
        }
      } elseif ##class(Frontier.Types).IsPersistent(methodArgument.Type) {
        set value = $System.OBJ.OpenId(methodArgument.Type, value)
        if '$isobject(value) set value = ""
      }
      set i%Arguments(argsProcessed) = value      
    }
  }
  set i%Arguments = argsProcessed
  return sc
]]></Implementation>
</Method>

<Method name="MergeArguments">
<FormalSpec><![CDATA[&routeArguments:%String=0,&requestArguments:%String=0,*preArguments:%String=0,strictMode:%Boolean=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set argumentIndex = routeArguments 
  set nextKeyIndex = 0
  set key = ""
  set preArguments = 0
  set methodArgumentsLength = ..MethodArguments.Count()
  set keysFound = ""

  for {
    set key = $order(requestArguments(key))
    quit:key=""    
    
    set keyGroup = $$$KeyGroup(key)
    set $list(keysFound, *+1) = keyGroup
    set methodArgument = ..FindDescribedArgument(keyGroup)
    
    if '$isobject(methodArgument) {
      if strictMode {
        return $$$ERROR($$$GeneralError, keyGroup_" query parameter was not expected.")
      } else {
        continue
      }
    }
    
    // Don't depend on query parameter repeatance, because JavaScript cannot repeat object keys.
    // Instead the parameter should follow the pattern "paramN" which represents a sequence.    
    set value = requestArguments(key, 1)  
    
    // Checks if we have a sequenced query param.
    if key?.A1.2N {
      if methodArgument.Arity '= 1 {
        if strictMode {
          return $$$ERROR($$$GeneralError, keyGroup_" was NOT expected to be sequential.")
        } else {
          continue
        }
      }               
      if methodArgumentsLength > 1 {     
        set argumentIndex = methodArgumentsLength + nextKeyIndex
      } else {
        set argumentIndex = nextKeyIndex + 1
      }
      
      set nextKeyIndex = nextKeyIndex + 1
      
      if nextKeyIndex '= $$$KeyIndex(key) {
        return $$$ERROR($$$GeneralError, keyGroup_" was expected to be sequential.")
      }
    } else {
      set argumentIndex = methodArgument.Index
    }
    set preArguments(argumentIndex) = value  
  }
  
  set missingArguments = ""
  
  // Check if the current request is sending all the required query parameters.
  if methodArgumentsLength > 0 {    
    for m=1:1:methodArgumentsLength {
      set methodArgument = ..MethodArguments.GetAt(m)
      set isPayloadArgument = (methodArgument.Type [ "DynamicObject" || (methodArgument.Type [ "DynamicArray"))
      
      if 'methodArgument.HasDefaultValue && 'isPayloadArgument {
        set queryParameterName = $select(
          methodArgument.Alias '= "" : methodArgument.Alias, 
          1: methodArgument.Name
        )
        
        set queryParameterName = $$$KeyGroup(queryParameterName)
        
        if '$lf(keysFound, queryParameterName) && '$data(routeArguments(queryParameterName)) {
          set $list(missingArguments, *+1) = queryParameterName
        }
      }
    }
  }
  
  if $ll(missingArguments) > 0 {
    return $$$ERROR($$$GeneralError, "The following query parameters are missing: "_$lts(missingArguments, ", ")_".")
  }
  
  // Now we must merge the route arguments back, remember that they always take priority over query parameters.
  set routeKey = ""
  for {
    set routeKey = $order(routeArguments(routeKey), 1, routeValue)
    quit:routeKey=""
    
    set methodArgument =  ..FindDescribedArgument(routeKey)
    
    if '$isobject(methodArgument) {
      return $$$ERROR($$$GeneralError, "Route parameter not specified: "_routeKey_".")
    }
    
    set preArguments(..FindDescribedArgument(routeKey).Index) = routeValue
  }
  set preArguments = argumentIndex
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter">
<Super>%RegisteredObject</Super>
<TimeCreated>64561,37245.906153</TimeCreated>

<Property name="Properties">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="Format">
<FormalSpec>propertyName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set storedFormatted = $get(i%Properties(depth, propertyName, "F"))
  if storedFormatted return storedFormatted
  
  set formattedName = ..OnFormat(propertyName)
  
  set i%Properties(depth, propertyName, "F") = formattedName
  set i%Properties(depth, formattedName, "N") = propertyName
  return formattedName
]]></Implementation>
</Method>

<Method name="FormatFromCollection">
<Internal>1</Internal>
<FormalSpec>collection:%ListOfObjects,depth:%Integer=1</FormalSpec>
<Implementation><![CDATA[
  for i=1:1:collection.Count() {
    set propertyName = collection.GetAt(i).Name
    if $extract(propertyName) '= "%" {
      do ..Format(collection.GetAt(i).Name, depth)
    }
  }
]]></Implementation>
</Method>

<Method name="OnFormat">
<FormalSpec>propertyName</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return propertyName
]]></Implementation>
</Method>

<Method name="Normalize">
<Final>1</Final>
<FormalSpec>formattedName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return $get(i%Properties(depth, formattedName, "N"))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.CamelCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,42861.513845</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Camelify(propertyName)
]]></Implementation>
</Method>

<Method name="Camelify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	return $$$lcase($extract(propertyName, 1))_$extract(propertyName, 2, *)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.SnakeCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,37293.153787</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Snakeify(propertyName)
]]></Implementation>
</Method>

<Method name="Snakeify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set snakedName = ""
	set nameLength = $length(propertyName)
	for i=1:1:nameLength {
		set c = $extract(propertyName, i)
		set n = $extract(propertyName, i+1)
		if c = $$$ucase(c) && (n '= $$$ucase(n)) && (i > 1) set c = "_"_c
		set snakedName = snakedName_c
	}	
	return $$$lcase(snakedName)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter">
<Super>%RegisteredObject</Super>
<TimeCreated>64537,40798.410075</TimeCreated>

<Method name="Setup">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter.Email">
<Description>
This class demonstrates how to create a reporter that sends an e-mail when a request error occurs.
If you want to see it working, create another class extending from this one and fill
the fields that aren't private, or you can instantiate it and change it's values manually.</Description>
<Super>Frontier.Reporter</Super>
<TimeCreated>64538,34157.457443</TimeCreated>

<Property name="Mail">
<Type>%Net.MailMessage</Type>
<Private>1</Private>
</Property>

<Property name="SMTPServer">
<Type>%Net.SMTP</Type>
<Private>1</Private>
</Property>

<Property name="Authenticator">
<Type>%Net.Authenticator</Type>
<Private>1</Private>
</Property>

<Property name="SMTPServerLocation">
<Type>%String</Type>
<InitialExpression>"your smtp server"</InitialExpression>
</Property>

<Property name="SMTPServerPort">
<Type>%Integer</Type>
<InitialExpression>25</InitialExpression>
</Property>

<Property name="SenderEmail">
<Type>%String</Type>
<InitialExpression>"youremail@host.com"</InitialExpression>
</Property>

<Property name="SenderPassword">
<Type>%String</Type>
<InitialExpression>"yourpasssword"</InitialExpression>
</Property>

<Property name="DestinationEmail">
<Type>%String</Type>
<InitialExpression>"dest@host.com"</InitialExpression>
</Property>

<Property name="TemplateLocation">
<Type>%String</Type>
<InitialExpression>"/the/email/template.html"</InitialExpression>
</Property>

<Property name="SSLConfiguration">
<Type>%String</Type>
</Property>

<Property name="UseSTARTTLS">
<Type>%Boolean</Type>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..SMTPServer = ##class(%Net.SMTP).%New()
  set ..Authenticator = ##class(%Net.Authenticator).%New()
  set ..Mail = ##class(%Net.MailMessage).%New()
  set ..Mail.IsHTML = 1
  set ..SMTPServer.authenticator = ..Authenticator
  $$$QuitOnError(..SetupAccount())
  return $$$OK
]]></Implementation>
</Method>

<Method name="Setup">
<Internal>1</Internal>
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(..SetupSMTPServer())
  $$$QuitOnError(..SetupAuthenticator())
  $$$QuitOnError(..SetupMail(context))
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupSMTPServer">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..SMTPServer.smtpserver = ..SMTPServerLocation
  set ..SMTPServer.port = ..SMTPServerPort
  set ..SMTPServer.SSLConfiguration = ..SSLConfiguration
  set ..SMTPServer.UseSTARTTLS = ..UseSTARTTLS
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupAuthenticator">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Authenticator.UserName = ..SenderEmail
  set ..Authenticator.Password = ..SenderPassword
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetupMail">
<FormalSpec>context:Frontier.Context</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Mail.From = ..SenderEmail
  do ..Mail.To.Insert(..DestinationEmail)      
  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Mail.Subject = $$$FormatText("[Error Report] - %1", $System.Status.GetErrorText(context.Error))
  $$$QuitOnError(..Mail.TextData.Write(..ReplacePlaceholders(context)))
  return ..SMTPServer.Send(..Mail)
]]></Implementation>
</Method>

<Method name="ReplacePlaceholders">
<FormalSpec>context:Frontier.Context</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set method = ##class(Frontier.Method).%New(context.ClassName, context.Method)  
  set template = ##class(%Stream.FileCharacter).%New()
  
  $$$QuitOnError(template.LinkToFile(..TemplateLocation))  
  
  set formatParameters = 6
  set formatParameters(1) = $System.Status.GetErrorText(context.Error)
  set formatParameters(2) = context.RequestURL
  set formatParameters(3) = context.ClassName
  set formatParameters(4) = context.Method
  if context.ArgumentValues '= 0  {
    for i=1:1:context.ArgumentValues {
      set methodArgument = method.MethodArguments.GetAt(i)
      set argumentName = methodArgument.Name
      set argumentValue = context.ArgumentValues(i)
      set argumentType = methodArgument.Type
      if argumentType = "" set argumentType = "<i>n/a</i>"
      set formatParameters(5) = $$$FormatText("%1 %2:%3: %4<br>", $get(formatParameters(5)), argumentName, argumentType, argumentValue)
    }
  } else {
    set formatParameters(5) = "<i>none</i>"
  }
  set formatParameters(6) = $replace(context.Stack, $c(10), "<br>")
  return $$$FormatText(template.Read(), formatParameters...)
]]></Implementation>
</Method>

<Method name="SetupAccount">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter.Manager">
<Super>%RegisteredObject</Super>
<TimeCreated>64538,33046.39632</TimeCreated>

<Property name="Reporters">
<Type>Frontier.Reporter</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Context">
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddReporter">
<FormalSpec>reporter:Frontier.Reporter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(reporter.Setup(..Context))
  $$$QuitOnError(..Reporters.Insert(reporter))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Report">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if $$$ISOK(..Context.Error) return $$$OK
  
  try {
    for i=1:1:..Reporters.Count() {
      set reporter = ..Reporters.GetAt(i)
      set sc = $$$ADDSC(sc, reporter.Report(..Context))
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="SetupReporters">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  for i=1:1:..Reporters.Count() {
    set reporter = ..Reporters.GetAt(i)
    set sc = $$$ADDSC(reporter.Setup(..Context), sc)
  }  
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Router">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>%CSP.REST</Super>
<TimeCreated>64492,32085.189445</TimeCreated>

<Method name="Page">
<ClassMethod>1</ClassMethod>
<FormalSpec>skipheader:%Boolean=1</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new %frontier
  set %frontier = ##class(Frontier.Context).%New(%session, %request, %response)  
  $$$QuitOnError(##super(skipheader))
  do ..OnPostHTTP()
  return $$$OK
]]></Implementation>
</Method>

<Method name="DispatchMap">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>index:%Integer,dispatchClass:%String=$classname()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  // Don't generate patterns if target class is super.
  if %compiledclass.Name = "Frontier.Router" return $$$OK
  
  // Kills remaining data, so that we can prevent using obsolete patterns.
  kill ^Frontier.Patterns(%compiledclass.Name)
  
  $$$ThrowOnError(##class(Frontier.Schema.Util).Parse(%compiledclass.Name, .routes))
  $$$ThrowOnError(##class(Frontier.Schema.Util).GeneratePatterns(routes, %compiledclass.Name, .patterns))  
  merge ^Frontier.Patterns(%compiledclass.Name) = patterns
  do %code.WriteLine("  return $get(^Frontier.Patterns(dispatchClass, index))")
  return $$$OK
]]></Implementation>
</Method>

<Method name="DispatchRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>url:%String,httpMethod:%String,forwarded:%Boolean="",routeParameters:%String=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set httpStatus = $case(httpMethod, "POST": ..#HTTP201CREATED, : ..#HTTP200OK)
  set isResourceMatch = 0
  set isHttpMethodMatch = 0
  
  // Makes sure the http method is following specs.
  set httpMethod = $$$ucase(httpMethod)
  
  try {    
    set resolvedUrl = $$ResolveUrl(url)    
    
    while $$NextDispatchMap(.index, .mapEntry, $classname()) {
      set matchType = $list(mapEntry, 1)
      set urlExpression = $list(mapEntry, 2)      
      set matcher = ##class(%Regex.Matcher).%New(urlExpression)      
      
      // If there's no match, skip to the next candidate.
      if matcher.Match(resolvedUrl) {      
        set isResourceMatch = 1
        set resourceScope = $lg(mapEntry, 7)
        set useAuth = $lg(mapEntry, 8)       
                
        set %frontier.RequestURL = %request.URL
        set %frontier.ClassName = $classname()
                 
        $$$ThrowOnError(..OnSetup())
        $$$ThrowOnError(..OnDataSet(%frontier.Data))        
        
        if matcher.GroupCount {
          do FetchRouteParameters(.routeParameters, matcher, mapEntry, matchType)                      
        }        
        
        // This is our final router. Search for the dispatch method and prepare it to be called.
        if matchType = "R" {
          set shouldQuit = 0
          set requiresCors = $list(mapEntry, 5)
                                    
          
          if httpMethod = "OPTIONS" do HandleOptionsRequest(url, requiresCors, .shouldQuit)
          // Don't continue if we hit this point, let the agent do the rest.
          if shouldQuit return $$$OK
                  
          if httpMethod '= $list(mapEntry, 3) continue
          
          $$$ThrowOnError(..ProcessCorsRequest(url, requiresCors))
                   
          if useAuth '= "false" {
            // Run pending authentication strategies. If one passes, then the implementation
            // is responsible for filling the user object.
            $$$ThrowOnError(%frontier.AuthenticationManager.Verify(.user, resourceScope))
            set %frontier.User = user
          
          // Don't let the user access this resource if this request doesn't match it somehow.           
            if '%frontier.AuthenticationManager.CheckResourceScope(resourceScope, user.scope) {
              set %response.Status = ..#HTTP403FORBIDDEN
              $$$ThrowOnError($$$ERROR($$$GeneralError, "This account has not enough privilege to execute this action."))
            }                                            
          }                                                
          
          set dispatchMethod = $listget(mapEntry, 4)
          set dispatchClass = $classname()
          
          // If the Call has : then it's calling a method outside this router.
          if dispatchMethod [ ":" {
            set dispatchClass = $piece(dispatchMethod, ":", 1) 
            set dispatchMethod = $piece(dispatchMethod, ":", 2)         
          }
          
          // Parse dispatchMethod retrieving its metadata.
          set tPublicMethod = ##class(Method).%New(dispatchClass, dispatchMethod, .routeParameters, %request, %frontier.PropertyFormatter, %frontier.StrictQueryParameters)
          merge methodArguments = tPublicMethod.Arguments
          
          // Executes the method and retrives its value. The method MUST return a value or a 
          // <COMMAND> will be issued.
          $$$ThrowOnError($$CallDispatchMethod(.methodArguments, dispatchClass, dispatchMethod, .methodReturn))
          
          // Now we serialize and output the result back to the agent.
          $$$ThrowOnError(..DispatchResponse(methodReturn, .tReturnParameters))
          
          // Finishes the request.
          return $$$OK
        } elseif matchType = "M" {
          set g1 = matcher.Group(matcher.GroupCount - 1)
          // We're reading a map, substracts the url to find the remaining unmatched part.
          set resolvedUrl = $piece(resolvedUrl, matcher.Group(matcher.GroupCount - 1), 2, *)          
          
          // If we got empty, reset it back to "/". So that it matches "/" Url attribute.
          if resolvedUrl = "" set resolvedUrl = "/"
          set forwardingClass = $listget(mapEntry, 3)
          set (isResourceMatch, isHttpMethodMatch) = 1
                    
          // Re-invoke this method from the mapped class. 
          $$$ThrowOnError($classmethod(forwardingClass,"DispatchRequest", resolvedUrl, httpMethod, 1, .routeParameters))
          return $$$OK
        }
      }      
    }
    
    // Didn't have a match for the resource, report not found.
    if isResourceMatch '= 1 || (isHttpMethodMatch '= 1) {
      set %response.Status = ..#HTTP404NOTFOUND
      $$$ThrowOnError($$$ERROR($$$GeneralError, "Resource not found."))
    }
    
    return $$$OK       
  } catch ex {    
    set exceptionPayload = ..HandleException(ex)
    set s = exceptionPayload.%ToJSON()
    do ##class(Frontier.Dynamic.Serializer).Serialize(exceptionPayload, 1, %frontier.PropertyFormatter)
  }
  return $$$OK
  
ResolveUrl(url)
  if 'forwarded return "/"_$extract(url, $length(%request.Application)+1,*)
  return url
  
NextDispatchMap(index=0, mapEntry="", dispatchClass="")  
  set index = index + 1
  if dispatchClass = "" set dispatchClass = $classname()
  set mapEntry = ..DispatchMap(index, dispatchClass)
  return (mapEntry '= "")
  
FetchRouteParameters(routeParameters=0, matcher, mapEntry, matchType)
  if matchType = "R" && (httpMethod '= $list(mapEntry, 3)) quit  
  if matchType = "R" { set max = $ll($lg(mapEntry,6)) }
  elseif matchType = "M" { set max = $ll($lg(mapEntry,4)) }
  
  for p=1:1:max {
    if matchType = "R" {
      set routeParameterName = $lg($lg(mapEntry,6), p)
      if '$data(routeParameters(routeParameterName)) {
        set routeParameters(routeParameterName) = matcher.Group(p)
        set routeParameters = routeParameters + 1
      }
    } elseif matchType = "M" {      
      set routeParameterName = $lg($lg(mapEntry, 4), p)      
      set routeParameters(routeParameterName) = $piece(matcher.Group(p), "/")
      set routeParameters = routeParameters + 1
    }
  }
  quit
 
HandleOptionsRequest(url, requireCors, shouldQuit)
 if httpMethod = "OPTIONS" {
   set isHttpMethodMatch = 1 
   $$$ThrowOnError(..OnHandleOptionsRequest(resolvedUrl))                
                      
   #; Dispatch CORS
   $$$ThrowOnError(..ProcessCorsRequest(url, requireCors))
   set shouldQuit = 1
 }
 quit
 
CallDispatchMethod(methodArguments, dispatchClass, dispatchMethod, methodReturn)
  set methodReturn = ""
  try {
    if methodArguments > 0 {
      merge %frontier.ArgumentValues = tMethodArguments
      set methodReturn = $classmethod(dispatchClass, dispatchMethod, methodArguments...)      
    } else {            
      set methodReturn = $classmethod(dispatchClass, dispatchMethod)
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="HandleException">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:%Exception.AbstractException</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set responseCode = $piece(%response.Status, " ")
    
  // There might have cases where we get a success HTTP status, we need to normalize forcing it to be a 500 error.
  if responseCode < 300 {
    set %response.Status = ..#HTTP500INTERNALSERVERERROR
    set responseCode = 500
  }
    
  set exceptionJSON = ##class(Exception).ToDynamicObject(exception)
  set exceptionJSON.error.responseCode = responseCode    
  set sc = exception.AsStatus()
    
  if '%frontier.ThrownByApplication || ($$$GETERRORCODE(sc) '= $$$GeneralError) {
    set %frontier.Error = sc
    set %frontier.Stack = ##class(Exception).CaptureStack()
  }
    
  set %response.OutputSessionToken = 0
  return exceptionJSON
]]></Implementation>
</Method>

<Method name="DispatchResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[returnedData:%CacheString,method:Frontier.Router,&returnTypeParams=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  set response = {}  
  
  if $isobject(returnedData) {
    set type = $classname(returnedData)
    set isCollection = ##class(Types).IsCollection(type)
    set isSQLProvider = ##class(Types).IsSQLProvider(type)
    set isStream = ##class(Types).IsStream(type)
    set isDynamic = ##class(Types).IsDynamic(type)
    set isSystemType = ($extract(type) = "%")
    set isMarshallable = isCollection || isDynamic || isStream || isSQLProvider || ('isSystemType && ##class(Types).IsInstantiable(type))
    if isMarshallable {
      if isStream {
        set stream = returnedData set returnedData = response
        set response.content = stream
      } elseif isSQLProvider {
        set provider = returnedData
        set response.results = provider
      } else {      
        $$$QuitOnError(##class(Frontier.Dynamic.Marshaller).Marshall(returnedData, .response))
      }
    } else {
      return $$$ERROR($$$GeneralError, "Cannot serialize system class instances.")
    }
  } elseif %frontier.IsJSON() {
    set response.result = returnedData
  } else {
    write returnedData
    return $$$OK
  }
  // We must use a custom serializer because the current %ToJSON implementation cannot serialize
  // mixed instances.
  if %frontier.DirectWrite = 1 {
    return ##class(Frontier.Dynamic.Serializer).Serialize(response, 1, %frontier.PropertyFormatter)
  } else {
    $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(response, .stream, %frontier.PropertyFormatter))
    do stream.OutputToDevice()
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="OnDataSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="OnPostHTTP">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  do %frontier.ReporterManager.Report() 
  kill %frontier
]]></Implementation>
</Method>

<XData name="Schema">
<Description>
This is the Schema which defines the form of the dispatch map</Description>
<Internal>1</Internal>
<Data><![CDATA[
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" >

<xs:element name="Routes">
<xs:complexType>
<xs:choice  minOccurs="0" maxOccurs="unbounded">
<xs:element name="Route">
<xs:complexType>
<xs:attribute name="Url"    type="string" use="required"/>
<xs:attribute name="Method" type="string" use="required"/>
<xs:attribute name="Call" type="call" use="required"/>
<xs:attribute name="Cors" type="xs:boolean" use="optional" default="false"/>
<xs:attribute name="Scope" type="string" use="optional" default="false"/>
<xs:attribute name="UseAuth" type="string" use="optional" default="true"/>
</xs:complexType>
</xs:element>
<xs:element name="Map">
<xs:complexType>
<xs:attribute name="Prefix" type="string" use="required"/>
<xs:attribute name="Forward" type="forward" use="required"/>
</xs:complexType>
</xs:element>
</xs:choice>
</xs:complexType>
</xs:element>

<xs:simpleType name="call">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*:)?[%]?[a-zA-Z][a-zA-Z0-9]*"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="forward">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*)"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="string">
<xs:restriction base="xs:string">
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>

</xs:schema>
]]></Data>
</XData>
</Class>


<Class name="Frontier.SQL">
<Super>%RegisteredObject</Super>
<TimeCreated>64531,35746.997056</TimeCreated>

<Method name="Prepare">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Implementation><![CDATA[  return ##class(Frontier.SQL.Provider).%New(SQLExpression)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Provider">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64531,36463.732591</TimeCreated>

<Property name="QueryClass">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="SQL">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Mode">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Error">
<Type>%Status</Type>
<Internal>1</Internal>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="StatementExecuted">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Results">
<Type>%SQL.StatementResult</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>statement:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  $$$ThrowOnError(..HandleSQLExpression(statement))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Parameters">
<FormalSpec>params...:%String</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..SetQueryParameters(params...))
  return $this
]]></Implementation>
</Method>

<Method name="Mode">
<FormalSpec>selectMode:%Integer=1</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set ..Mode = selectMode
  return $this
]]></Implementation>
</Method>

<Method name="Execute">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..StatementExecuted = 1
  return ..CreateAndExecute()
]]></Implementation>
</Method>

<Method name="HandleSQLExpression">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $length(SQLExpression, ":") = 2 {   
    set ..QueryClass = $piece(SQLExpression, ":")
    set ..QueryName = $piece(SQLExpression, ":", 2)
  } elseif $extract($$$ucase($$$trim(SQLExpression)), 1, 6) = "SELECT" {
    set ..SQL = SQLExpression
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetQueryParameters">
<FormalSpec>parameters...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if parameters '= 0 && 'parameters?.N && ($order(parameters(""), -1) '= parameters) {
    return $$$ERROR($$$GeneralError, "Invalid parameter spec.")
  }
  
  kill i%QueryParameters
  set i%QueryParameters = parameters
  
  merge i%QueryParameters = parameters
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateAndExecute">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  merge parameters = ..QueryParameters
  
  set statement = ##class(%SQL.Statement).%New()
  set statement.%SelectMode = ..Mode  
  
  if ..QueryClass '= "" && (..QueryName '= "") {    
    set sc = statement.%PrepareClassQuery(..QueryClass, ..QueryName)    
  } elseif ..SQL '= "" {
    set sc = statement.%Prepare(..SQL)
  }  
  
  $$$QuitOnError(sc)
  set results = statement.%Execute(parameters...)
  
  if results.%SQLCODE '= 0 {
    set sc = ##class(%Exception.SQL).CreateFromSQLCODE(results.%SQLCODE, results.%Message).AsStatus()
  }
  set i%Results = results
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Serializer">
<IncludeCode>frontier,%ZEN.Utils</IncludeCode>
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64539,50921.256251</TimeCreated>

<Method name="Serialize">
<ClassMethod>1</ClassMethod>
<FormalSpec>results:%SQL.Statement,depth:%Integer=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  #define WriteThrowable(%expr) $$$ThrowOnError(data.Write(%expr))
  
  set sc = $$$OK
  set metadata = results.%GetMetadata()
  $$$QuitOnError(..FetchColumnNames(metadata, .columnNames))
  
  set data = ##class(%Stream.GlobalCharacter).%New()
  
  $$$WriteThrowable("[")
  
  set itemComma = ""
  set propertyComma = ""
  
  try {               
    while results.%Next(.sc) {
      $$$WriteThrowable(itemComma)
      
      set itemComma = ","
      set propertyComma = ""
      
      $$$WriteThrowable("{")
      $$$ThrowOnError(sc)      
      
      for c=1:1:columnNames {
        set columnName = columnNames(c)
        set value = results.%Get(columnName)        
        
        if $isobject(propertyFormatter) {
          set columnName = propertyFormatter.Format(columnName, depth)
        }
        
        $$$WriteThrowable(propertyComma)
        
        if $listvalid(value) && ($listlength(value) > 0) {
          set arrayComma = ""
          
          $$$WriteThrowable("[")
          
          for i=1:$listlength(value) {
            $$$WriteThrowable($$$ZENJSONVALUE(value, "s"))
            $$$WriteThrowable(arrayComma)
            set arrayComma = ","
          }
          
          $$$WriteThrowable("]")
        }
        $$$WriteThrowable($$$ZENJSONPAIR(columnName, value, "s"))
        set propertyComma = ","
      }
      $$$WriteThrowable("}")
    }   
    $$$WriteThrowable("]")
    $$$ThrowOnError(data.OutputToDevice())    
  } catch ex {
    write "null"
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="FetchColumnNames">
<ClassMethod>1</ClassMethod>
<FormalSpec>metadata:%SQL.StatementMetadata,*columnNames:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set columns = metadata.columns
  set columnNames = columns.Count()
  for i=1:1:columnNames {
    set columnNames(i) = columns.GetAt(i).label
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Schema.Map">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36886.274558</TimeCreated>

<Property name="Prefix">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Forward">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Route">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36903.793612</TimeCreated>

<Property name="Url">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Method">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Call">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cors">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Scope">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="UseAuth">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Routes">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36920.7862</TimeCreated>

<Parameter name="XMLPROJECTION">
<Default>WRAPPED</Default>
</Parameter>

<Property name="Route">
<Type>Frontier.Schema.Route</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Map">
<Type>Frontier.Schema.Map</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="Frontier.Schema.Util">
<Abstract>1</Abstract>
<TimeCreated>64552,36997.083393</TimeCreated>

<Method name="Parse">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>targetClass:%String,*routes:Frontier.Schema.Routes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set xdataId = targetClass_"||UrlMap"
  
  if '##class(%Dictionary.CompiledXData).%ExistsId(xdataId) {
    return $$$ERROR($$$XDataBlockMissing, targetClass, "UrlMap")
  }
  
  try {
    set reader = ##class(%XML.Reader).%New()
    set xdata = ##class(%Dictionary.CompiledXData).%OpenId(xdataId).Data   
    set resolver = ##class(%XML.SAX.XDataEntityResolver).%New(targetClass)
    set reader.EntityResolver = resolver
    $$$ThrowOnError(reader.OpenStream(xdata))
    do reader.Correlate("Routes", "Frontier.Schema.Routes")
    do reader.Next(.routes, .sc)
    $$$ThrowOnError(sc)
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="GeneratePatterns">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>routes:Frontier.Schema.Routes,targetClass:%String,*patterns:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim route As Frontier.Schema.Route
  #dim map as Frontier.Schema.Map
  
  set totalRoutes = routes.Route.Count()
  set totalMaps = routes.Map.Count()
  set i = ""
  
  if totalRoutes > 0 {
    set resourceType = "R"
    for i=1:1:totalRoutes {
      set route = routes.Route.GetAt(i)
      set pattern = $$WritePattern(route.Url, .placeholders)
      set patterns(i) = $lb(resourceType, pattern, route.Method, route.Call, route.Cors, placeholders, route.Scope, route.UseAuth)
    }    
  } 
  if totalMaps > 0 {
    set resourceType = "M"
    for j=1:1:totalMaps {
      set map = routes.Map.GetAt(j)
      set pattern = $$WritePattern(map.Prefix, .placeholders)
      set patterns(i + j) = $lb(resourceType, pattern, map.Forward, placeholders)
    }
  }
  
  return $$$OK
  
WritePattern(resource, placeholders)
  #define GetPlaceholder(%exp) $piece(%exp, ":", 2) 
  
  set pattern = ""
  set placeholders = ""
  
  if $extract(resource) = ":" {
    set $list(placeholders, *+1) = $$$GetPlaceholder($piece(resource, "/", 1))
  }
  
  for resourceIndex=2:1:$length(resource,"/") {
    set resourcePart = $piece(resource,"/", resourceIndex)
    if $extract(resourcePart) = ":" {
      set $list(placeholders, *+1) = $$$GetPlaceholder(resourcePart)
      if resourceType = "R" {
        set pattern = pattern_"/?([^"_$char(0)_"]+)?+"        
      } else {        
        set pattern = pattern_"/([A-Za-z0-9-._~:]+"
      }
    } else {      
      set pattern = pattern_"/"_resourcePart
      if resourceType = "M" {
        if pattern [ "/([A-Za-z0-9-._~:]+" set pattern = pattern_")"
        else  set pattern = "("_pattern_")"
      }
    }
  }
  if resourceType = "R" return $translate(pattern, $char(0), "/")
  return pattern_"/?(.*)"
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Types">
<Abstract>1</Abstract>
<TimeCreated>64502,35492.335596</TimeCreated>

<Method name="IsInstantiable">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%RegisteredObject")
]]></Implementation>
</Method>

<Method name="IsPersistent">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Persistent")
]]></Implementation>
</Method>

<Method name="IsDataType">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%DataType")
]]></Implementation>
</Method>

<Method name="IsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Stream.Object")
]]></Implementation>
</Method>

<Method name="IsCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Collection.AbstractIterator")
]]></Implementation>
</Method>

<Method name="IsSerial">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%SerialObject")
]]></Implementation>
</Method>

<Method name="IsDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicAbstractObject")
]]></Implementation>
</Method>

<Method name="IsDynamicArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicArray")
]]></Implementation>
</Method>

<Method name="IsDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicObject")
]]></Implementation>
</Method>

<Method name="IsZENProxyObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%ZEN.proxyObject")
]]></Implementation>
</Method>

<Method name="IsSQLProvider">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "Frontier.SQL.Provider")
]]></Implementation>
</Method>

<Method name="IsTypeOf">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,expectedType:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  #define NormalizeClassName(%cn) if $l(%cn, ".") = 1 && ($e(%cn) = "%") set %cn = "%Library."_$e(%cn, 2, *)   
  if className = "" quit 0
  
  $$$NormalizeClassName(className)
  $$$NormalizeClassName(expectedType)  
  
  if className = expectedType return 1
  
  // Uses default %Extends method to check for common cases and improve performance.
  return ##class(%Dictionary.CompiledClass).%ExistsId(className) && $classmethod(className, "%Extends", expectedType)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Authentication.DummyStrategy">
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64560,50335.046682</TimeCreated>

<Property name="ShouldPass">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  if ..ShouldPass return $$$OK
  set response.Status = "401 Unauthorized"
  return $$$ERROR($$$GeneralError, "Requested to fail")
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "realm=""Tests"""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Class">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34585.6306</TimeCreated>

<Property name="Plate">
<Type>%String</Type>
</Property>

<Property name="Students">
<Type>Student</Type>
<Cardinality>many</Cardinality>
<Inverse>Class</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.Fix50C.ClassD</DataLocation>
<DefaultData>ClassDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.Fix50C.ClassD</IdLocation>
<IndexLocation>^Frontier.UnitTest.Fix50C.ClassI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.Fix50C.ClassS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="ClassDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Plate</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Plate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>4.9</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Student">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34683.761379</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Class">
<Type>Class</Type>
<Cardinality>one</Cardinality>
<Inverse>Students</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="BirthDate">
<Type>%Date</Type>
</Property>

<Property name="SomeValue">
<Type>%String</Type>
<InitialExpression>"0032323"</InitialExpression>
</Property>

<Query name="PaginatedStudents">
<Type>%SQLQuery</Type>
<FormalSpec>offset:%Integer,limit:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>  
  SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN :offset AND :limit</SqlQuery>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.F50C.StudentD</DataLocation>
<DefaultData>StudentDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.F50C.StudentD</IdLocation>
<IndexLocation>^Frontier.UnitTest.F50C.StudentI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.F50C.StudentS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="StudentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Class</Value>
</Value>
<Value name="4">
<Value>BirthDate</Value>
</Value>
<Value name="5">
<Value>SomeValue</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="BirthDate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>14.2857%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="Name">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>15.4</AverageFieldSize>
</Property>
<Property name="SomeValue">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>7</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Reporter.Email">
<Super>Frontier.Reporter.Email</Super>
<TimeCreated>64538,36222.588241</TimeCreated>

<Method name="SetupAccount">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // If you want to test this reporter you need to configure the following properties.
  set ..SMTPServerLocation = "smtp.youremailhost.com" 
  set ..SMTPServerPort = 25 // Your SMTP server port
  set ..SenderEmail = "sender_email@email.com"
  set ..SenderPassword = "sender_password"
  set ..DestinationEmail = "destination@email.com"
  set ..TemplateLocation = "/InterSystems/Cache/CSP/user/email-template.html"
  set ..SSLConfiguration = "SSL Configuration name"
  set ..UseSTARTTLS = 1 // 1, "" or 0
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Reporter.Mock">
<Super>Frontier.Reporter</Super>
<TimeCreated>64540,40870.642496</TimeCreated>

<Property name="ExpectedSetupStatus">
<Type>%Status</Type>
</Property>

<Property name="ExpectedReportStatus">
<Type>%Status</Type>
</Property>

<Method name="Setup">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier.UnitTest.Spy("Setup", $this) = context
  return ..ExpectedSetupStatus
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier.UnitTest.Spy("Report", $this) = context
  return ..ExpectedReportStatus
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router">
<Super>Frontier.Router</Super>
<TimeCreated>64503,35090.481271</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
  <Route Url="/route_params/:class" Method="GET" Call="TestGETRouteParams"/>
  <Route Url="/query_params" Method="GET" Call="TestGETOneQueryParameter"/>
  <Route Url="/rest_params" Method="GET" Call="TestGETRestParametersSum"/>
  <Route Url="/sql/dynamic" Method="GET" Call="TestGETDynamicSQLResult"/>
  <Route Url="/sql/query" Method="GET" Call="TestGETQuerySQLResult"/>
  <Route Url="/raw" Method="GET" Call="TestGETRawMode"/>
  <Route Url="/shared_data" Method="GET" Call="TestGETData"/>
  <Route Url="/stream" Method="GET" Call="TestGETStream"/>
  <Route Url="/alias" Method="GET" Call="TestGETAliasedQueryParameter"/>
  <Route Url="/payload/single_object" Method="POST" Call="TestPOSTObjectPayloadSingle"/>
  <Route Url="/payload/object_with_query_params" Method="POST" Call="TestPOSTObjectPayloadQueryParams"/>  
  <Route Url="/payload/single_array" Method="POST" Call="TestPOSTArrayPayloadSingle"/>
  <Route Url="/payload/array_with_query_params" Method="POST" Call="TestPOSTArrayPayloadQueryParams"/>
  <Route Url="/payload/invalid" Method="POST" Call="TestPOSTInvalidPayload"/>
  <Route Url="/mixed/object" Method="GET" Call="TestGETMixedDynamicObject"/>
  <Route Url="/mixed/array" Method="GET" Call="TestGETMixedDynamicArray"/>
  <Route Url="/mixed/rest" Method="POST" Call="TestPOSTMixedRestParametersSum"/>
  <Route Url="/unmarshall" Method="POST" Call="TestPOSTUnmarshallToClass"/>
  <Route Url="/unmarshall/:classId" Method="PUT" Call="TestPUTUnmarshallToClass"/>
  <Route Url="/user" Method="GET" Call="GetUserInfo"/>
 </Routes>
]]></Data>
</XData>

<Method name="OnDataSet">
<Description>
Use this method to share data between methods.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  /// This 'data' object is shared between all methods. Accessible using %frontier.Data.
  set data.Message = "This 'Message' is shared between all methods."
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<Description>
This method is reserved for setting up configurations.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // Reporters should be used to signal the developer about request errors.   
  // $$$QuitOnError(%frontier.ReporterManager.AddReporter(##class(MyReporter.Email).%New()))
  
  // Asks the user for a Basic + Base64(username:password) encoded Authorization header.
  set basicStrategy = ##class(Frontier.Authentication.BasicStrategy).%New({
    "realm": "tests", 
    "validator": ($classname()_":ValidateCredentials")
  })
  
  // This provides a way to check if the current user is authenticated using Basic scheme.
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(basicStrategy))  
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Description>
Whenever a parameter is typed of %Persistent and a valid id is provided, the parameter will be instantiated.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/route_params/6' 
{"Plate":"O5397","Students":[{"Name":"Drabek,Peter T.","__id__":"20"}],"__id__":"6"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return class
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Description>
Query parameters are also supported and are fetched if the parameter name matches the URL query name.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/query_params?msg=hello'
{result":"hello"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return "hello"
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Description><![CDATA[
Rest parameters are sequential query parameters. They can have flexible arity and have the format parameterN.
This request takes that number of parameters and sum them.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/rest_params?n1=10&n2=20&n3=30']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n...:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set sum = 0
  for i=1:1:n  set sum = sum + n(i)
  return sum
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Description><![CDATA[
Dynamic SQL queries can be returned as long as the Frontier SQL API is used.
For SQL, the usage of Prepare() from frontier.SQL API is required.
Call example:
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/dynamic?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows
  
  return %frontier.SQL.Prepare(
    "SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?"
  ).Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Description><![CDATA[
The same applies for named (cached) SQL queries. Notice that they can be called by providing
the class:queryname instead of a dynamic SQL.
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/query?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows     
    
  return %frontier.SQL.Prepare("Frontier.UnitTest.Fixtures.Student:PaginatedStudents").Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Description>
There can be cases where the response should not be a JSON.
This method shows how to output a text in plain format.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/raw</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  return "hello raw response"
]]></Implementation>
</Method>

<Method name="TestGETData">
<Description>
This method uses the data object provided on Setup method.
The idea is to demonstrate how to access shared data.
Call example: 
/// curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/shared_data' </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return %frontier.Data
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Description>
This method demonstrates how %Stream.Object based instances are treated.
Call example: 
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/stream'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  set stream = ##class(%Stream.GlobalCharacter).%New()
  do stream.Write("This line is from a stream.")
  
  return stream
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Description>
If the request is a POST/PUT/PATCH method, it can receive a payload that's represented by a parameter typed of %DynamicObject instances.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/single_object'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Description>
Request can have a payload along with a query parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/object_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String="",payload:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return {
    "msg": (msg),
    "payload": (payload)
  }
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Description>
Payloads can also be an array.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/single_array'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Description>
Requests with array payloads also support query parameters.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/array_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject,msg:%String=""</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (msg), (payload) ]
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Description>
This demonstrates payload validation, as browsers can receive one payload per request
a classmethod that expects more than one is considered invalid and will throw an exception.
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/invalid'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payloadA:%DynamicArray,payloadB:%DynamicObject</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return payloadA
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Description>
Normally %Dynamic instances cannot serialize childrens that aren't dynamic as well. (%ToJSON would thrown an exception).
Frontier fixes it by marshalling irregular to %Dynamic instances beforehand and making it compatible.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/object?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "class": (class)
  }
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Description>
Also supported for %DynamicArray.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/array?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (class) ]
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Description><![CDATA[
It's possible to mix multiple parameter types as you could when calling a method.
The example below illustrates the usage of a method that receives a 'msg' query parameter along with a payload and a rest parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/mixed/rest?n1=10&n2=20&msg=hello']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,data:%DynamicObject,n...:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 
  set parameters = []  
  set sum = 0
  for i=1:1:n  set sum = sum + n(i) do parameters.%Push(n(i))
  return {
    "sum": (sum),
    "data": (data),
    "params": (parameters),
    "msg": (msg)
  }
  return sum
]]></Implementation>
</Method>

<Method name="TestGETAliasedQueryParameter">
<Description>
For compability with existing clients that use query parameters with symbols. For such cases
ALIAS can be used to make it compatible. If the expected alias is not found then Frontier will 
fall back to using the argument name instead.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String(ALIAS="aliased_key")</FormalSpec>
<Implementation><![CDATA[  return msg
]]></Implementation>
</Method>

<Method name="TestPOSTUnmarshallToClass">
<Description>
It's also possible to save from a payload directly to a %Persistent instance as long as the payload
has the same format as the %Persistent class. Just define the the parameter UNMARSHALLTO with the class you want
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshall'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%DynamicObject(UNMARSHALLTO="Frontier.UnitTest.Fixtures.Class")</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="TestPUTUnmarshallToClass">
<Description>
You can also edit the entity just by providing the property "__id__" along with the new payload data. If you want the id to be read from the URL,
add a new parameter and map the unmarshaller to use it as id by specifying the IDCOLUMN. If the named IDCOLUMN is not
found, the id will be searched inside the payload. Note that when the id is not found, an exception will be thrown regarding  the
incorrect PUT usage.
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshall/15'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%DynamicObject(UNMARSHALLTO="Frontier.UnitTest.Fixtures.Class",IDCOLUMN="classId"),classId:%Integer</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="GetUserInfo">
<Description>
This method depends on the authorization header sent by the client and validated with the validator method.
The validator method is also responsible for defining the user object.
Call example:
curl -H "Authorization: Basic Zm9vOmJhcg==" 'http://localhost:57772/api/frontier/test/user'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return %frontier.User
]]></Implementation>
</Method>

<Method name="ValidateCredentials">
<ClassMethod>1</ClassMethod>
<FormalSpec>login:%String,password:%String,found:%Boolean=1,*httpStatus:%String,*user:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set found = (login = "foo" && (password = "bar"))
  if found set httpStatus = ..#HTTP200OK
  else  set httpStatus = ..#HTTP403FORBIDDEN
  
  set user = { 
    "user": (login) 
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64503,34684.599157</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Method name="CreateWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set targetNamespace = $namespace
  
  new $namespace  
  set $namespace = "%SYS"
  
  write !, ">> Creating demo web application using namespace "_targetNamespace_" ..."
  if ##class(Security.Applications).Exists(..#NAME) {
    write !, ">> Application already exists, skipping ..."
    return $$$OK
  }
  
  set properties("CookiePath") = ..#NAME
  set properties("DispatchClass") = "Frontier.UnitTest.Router"
  set properties("NameSpace") = targetNamespace
  set properties("UseCookies") = 2
  set properties("AutheEnabled") = 64
  
  $$$QuitOnError(##class(Security.Applications).Create(..#NAME, .properties))
  write !, ">> Application /api/frontier/test has been created."
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  
  if '##class(Security.Applications).Exists(..#NAME) return $$$OK
  write !, ">> Deleting demo web application "_..#NAME_" ..."
  
  $$$QuitOnError(##class(Security.Applications).Delete(..#NAME))
  write !, ">> Web application has been deleted with success."
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="MergeErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec>errors:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  for i=0:1:(errors.%Size() - 1) {
    set errorObject = errors.%Get(i)
    set sc = $$$ADDSC(sc, $$$ERROR(errorObject.code, errorObject.params.%Get(0)))
  }
  
  return sc
]]></Implementation>
</Method>

<Method name="MarshallSQLResult">
<ClassMethod>1</ClassMethod>
<FormalSpec>SQLResult:%IResultSet,*dynamicArray:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set dynamicArray = []
  set columnInfo = ""
  
  set columnsCount = SQLResult.%ResultColumnCount
  for c = 1:1:columnsCount {
    set columnInfo(c,"name") = SQLResult.%GetMetadata().columns.GetAt(c).label
  }  
  
  while (SQLResult.%Next(.sc)) {
    quit:$$$ISERR(sc)
    set node = {}
    for c = 1:1:SQLResult.%ResultColumnCount {
      set value = SQLResult.%GetData(c)
        
      if ($isvalidnum(value) && ($e(value) '= 0)) do node.%Set($get(columnInfo(c,"name")),$num(value),"number")
      else  do node.%Set($get(columnInfo(c,"name")),value)
    }
    Do dynamicArray.%Push(node)
  }
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplicationInstaller">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64530,35966.171067</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Projection name="Installer">
<Type>Frontier.UnitTest.WebApplicationInstaller</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).Populate())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).Populate())  
  return ##class(Frontier.UnitTest.Util).CreateWebApplication()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())  
  return ##class(Frontier.UnitTest.Util).RemoveWebApplication()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Authentication.Manager">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64560,42325.952774</TimeCreated>

<Property name="AuthenticationManager">
<Type>Frontier.Authentication.Manager</Type>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
</Property>

<Property name="Session">
<Type>%CSP.Session</Type>
</Property>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = ##class(%CSP.Session).%New("t3st1ng")
  set ..Request = ##class(%CSP.Request).%New()
  set ..Response = ##class(%CSP.Response).%New()
  set context = ##class(Frontier.Context).%New(..Session, ..Request, ..Response)
  set ..AuthenticationManager = context.AuthenticationManager  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ..Request = ""
	set ..Response = ""
	set ..Session = ""
	set ..AuthenticationManager = ""
	return $$$OK
]]></Implementation>
</Method>

<Method name="TestVerify">
<Implementation><![CDATA[
	// This will fail but move to the next strategy. The Next flag indicates that there
	// isn't enough info about the authentication method to decide a strategy thus making the manager ignores it.
	set dummyStrategy1 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
	set dummyStrategy1.ShouldPass = 0
	set dummyStrategy1.Next = 1
	
	// Same here.
	set dummyStrategy2 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
	set dummyStrategy2.ShouldPass = 0
	set dummyStrategy2.Next = 1
	
	// If the flag is not set, then it'll validate the input.
	// Luckly, we're informing our dummy strategy that it should allow the access.
	set dummyStrategy3 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
	set dummyStrategy3.ShouldPass = 1
	
	//do $$$AssertStatusOK(..AuthenticationManager.AddStrategy(dummyStrategy1), "can add strategy")
	do ..AuthenticationManager.AddStrategy(dummyStrategy1)
	
	do ..AuthenticationManager.AddStrategy(dummyStrategy2)
	do ..AuthenticationManager.AddStrategy(dummyStrategy3)
	
	set sc = ..AuthenticationManager.Verify(.user)	
	
	do $$$AssertStatusOK(sc, "allows access")
	
	do $$$AssertTrue(..Response.GetHeader("WWW-Authenticate") = "", "doesn't output the WWW-Authenticate if one strategy works.")
	
	set dummyStrategy4 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
	set dummyStrategy4.ShouldPass = 0
	
	do ..AuthenticationManager.AddStrategy(dummyStrategy4)	
	
	set sc = ..AuthenticationManager.Verify(.user)
	do $$$AssertStatusOK(sc, "skips pending strategies if one works")
	
	// This time we're forcing our passing strategy to fail, and there's no Next flag
	// so assume that the user sent us a valid authentication but the credentials are
	// not what we expected.
	set dummyStrategy3.ShouldPass = 0
	
	set sc = ..AuthenticationManager.Verify(.user)
	
	do $$$AssertEquals(user.name, "", "always return an user object even if empty")
	do $$$AssertStatusNotOK(sc, "returns the last strategy error")
	
	// Now we have the WWW-Authenticate header set.
	do $$$AssertTrue(..Response.GetHeader("WWW-Authenticate") '= "", "outputs the WWW-Authenticate when neither of the provided strategies succeed.")
]]></Implementation>
</Method>

<Method name="T">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	set t = ..%New(##class(Port.UnitTest.Manager).%New())
	do t.OnBeforeOneTest()
	do t.TestVerify()
	do t.OnBeforeOneTest()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Reporter.Manager">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64540,38890.678512</TimeCreated>

<Property name="Context">
<Type>Frontier.Context</Type>
</Property>

<Property name="ReporterManager">
<Type>Frontier.Reporter.Manager</Type>
</Property>

<Property name="SetupStatuses">
<Type>%Status</Type>
<InitialExpression>$lb(1, ..CreateError(), 1, 1, ..CreateError(), ..CreateError())</InitialExpression>
</Property>

<Property name="ReportStatuses">
<Type>%Status</Type>
<InitialExpression>$lb(..CreateError(), ..CreateError(), ..CreateError(), 1, 1)</InitialExpression>
</Property>

<Property name="MockIds">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set session = ##class(%CSP.Session).%New("t3st1ng")
  set request = ##class(%CSP.Request).%New()
  set response = ##class(%CSP.Response).%New()
  set ..Context = ##class(Frontier.Context).%New(session, request, response)
  set ..Context.Error = ..CreateError()
  set ..ReporterManager = ..Context.ReporterManager
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateError">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$ERROR($$$GeneralError, "dummy error")
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..ReporterManager = ""
  set ..Context = ""
  kill ..MockIds
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestAddReporter">
<FormalSpec>skipAssertion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  for i=1:1:$ll(..SetupStatuses) {
    set expectedSetupStatus = $lg(..SetupStatuses, i)
    set expectedReportStatus = $lg(..ReportStatuses, i)
    set mockReporter = ##class(Frontier.UnitTest.Reporter.Mock).%New()
    set ..MockIds(i) = mockReporter
    set mockReporter.ExpectedSetupStatus = expectedSetupStatus
    set mockReporter.ExpectedReportStatus = expectedReportStatus
    set returnedStatus = ..ReporterManager.AddReporter(mockReporter)
    set matchInstance = (^||Frontier.UnitTest.Spy("Setup", ..MockIds(i)) '= "")
    if 'skipAssertion {
      if (returnedStatus '= expectedSetupStatus) return $$$AssertTrue(0, "returns each reporter's Setup status")      
      if 'matchInstance return $$$AssertTrue(matchInstance, "Report received context.")
    }
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestReport">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = ..TestAddReporter(1)
  if $$$ISERR(sc) return $$$AssertSkipped("failed to add dummy reporters")
  
  set sc = ..ReporterManager.Report()
  set errorCount = $$$GETERRORCOUNT(sc)
  
  // 2 because Setup failures nullifies reporters so they never can be used.
  // We actually have only 2 reporters added.
  if errorCount '= 2 do $$$AssertTrue(errorCount '= 2, "appends reporter errors.")
  
  for i=1:1:$ll(..ReportStatuses) {
    
    // Skip reports that couldn't be added. We only need to know about reporters ready to call the Report method.
    // Even if the Report method fails itself.
    if $data(^||Frontier.UnitTest.Spy("Report", ..MockIds(i))) {
      set matchInstance = (^||Frontier.UnitTest.Spy("Report", ..MockIds(i)) '= "")
      if 'matchInstance return $$$AssertTrue(matchInstance, "Report received context.")
    }
  }
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Router">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64499,42651.978954</TimeCreated>

<Parameter name="TESTSERVER">
<Default>localhost</Default>
</Parameter>

<Parameter name="TESTSERVERPORT">
<Default>57772</Default>
</Parameter>

<Property name="Request">
<Type>%Net.HttpRequest</Type>
</Property>

<Property name="Class">
<Type>Frontier.UnitTest.Fixtures.Class</Type>
</Property>

<Property name="Student">
<Type>Frontier.UnitTest.Fixtures.Student</Type>
</Property>

<Property name="WebApplicationName">
<Type>%String</Type>
<InitialExpression>$e(##class(Frontier.UnitTest.WebApplicationInstaller).#NAME, 2, *)</InitialExpression>
</Property>

<Method name="OnBeforeAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  &sql(SELECT TOP 1 ID INTO :classId FROM FRONTIER_UNITTEST_FIXTURES.CLASS)
  &sql(SELECT TOP 1 ID INTO :studentId FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  
  set ..Class = ##class(Frontier.UnitTest.Fixtures.Class).%OpenId(classId)
  set ..Student = ##class(Frontier.UnitTest.Fixtures.Student).%OpenId(studentId)
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Request = ##class(%Net.HttpRequest).%New()
  do ..Request.SetHeader("Content-Type", "application/json; charset=utf-8")
  set ..Request.Server = ..#TESTSERVER
  set ..Request.Port = ..#TESTSERVERPORT
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertRequest">
<FormalSpec>resource:%String,expected:%DynamicAbstractObject="",method:%String="GET",payload:%DynamicAbstractObject="",authHeader:%String="Basic Zm9vOmJhcg=="</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $isobject(payload) {
    $$$QuitOnError(..Request.SetHeader("Content-Type", "application/json; charset=utf-8"))
    $$$QuitOnError(..Request.EntityBody.Write(payload.%ToJSON()))
  }
  
  // Default is Basic foo:bar. Refer to the ValidateCredentials method defined in the Frontier.UnitTest.Router class.
  $$$QuitOnError(..Request.SetHeader("Authorization", authHeader))
  
  $$$QuitOnError(..Request.Send(method, resource))
  set response = ..Request.HttpResponse.Data
  set responseText = response.Read()
  set expectedText = expected
  
  set firstByte = $extract(responseText)
  
  if $extract(firstByte)?1(1"{",1"[") {
    set response = ##class(%DynamicObject).%FromJSON(responseText)    
    if $isobject(response) {
      if ##class(Frontier.Types).IsDynamicObject(response) && (response.errors '= ""){        
        return ##class(Frontier.UnitTest.Util).MergeErrors(response.errors)
      } elseif ##class(Frontier.Types).IsDynamic($classname(expected)) {
        $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(expected, .str))
        set expectedText = str.Read()
      }
    }
  }
  
  if responseText '= expectedText {
    return $$$ERROR($$$GeneralError, $$$FormatText("The received content mismatches with the expected one: %1%2 '= %3%2", $c(10,13), responseText, $c(10,13), expectedText))
  }  
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1route_params/%2", ..WebApplicationName, ..Class.%Id())
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .expected)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Implementation><![CDATA[
  set expected = { "result": "hello" }  
  set resource = $$$FormatText("%1query_params?msg=%2", ..WebApplicationName, "hello")
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Implementation><![CDATA[
  set expected = { "result": 60 }
  set resource = $$$FormatText("%1rest_params?n1=10&n2=20&n3=30", ..WebApplicationName)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/rest?n1=10&n2=20&msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"sum":30,"data":{"username":"xyz","password":"xyz"},"params":["10","20"],"msg":"hello"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_object", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/object_with_query_params?msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"msg":"hello","payload":(payload)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_array", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/array_with_query_params?msg=hello", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = ["hello",(payload)]
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/invalid", ..WebApplicationName)
  set payload = [{"username":"xyz","password":"xyz"}]
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */, "POST", payload), "returns an error if more than one payload is formally expected")
]]></Implementation>
</Method>

<Method name="TestGETInvalidRestSequence">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1rest_params?n1=&n4=10", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if rest argument index is not sequential")
]]></Implementation>
</Method>

<Method name="TestGETUnspecifiedArgument">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1query_params?unknown=1", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if an unknown argument is provided")
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/object?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = {"class":(class)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/array?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = [ (class) ]
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1raw", ..WebApplicationName)
  set expected = "hello raw response"
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1stream", ..WebApplicationName)
  set expected = {"content":"This line is from a stream."}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETAliasedQueryParameter">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1alias?aliased_key=whatever", ..WebApplicationName)
  set expected = {"result":"whatever"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/dynamic", ..WebApplicationName)
  
  set sd = ##class(%SQL.Statement).%New()
  set sd.%SelectMode = 2
  do sd.%Prepare("SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?")
  set rd = sd.%Execute(1, 5)
  
  do $$$AssertStatusOK(##class(Frontier.UnitTest.Util).MarshallSQLResult(rd, .array), "can read SQL result")
  set expected = {"results":(array)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/query", ..WebApplicationName)
  
  set sd = ##class(%SQL.Statement).%New()
  set sd.%SelectMode = 2
  do sd.%PrepareClassQuery("Frontier.UnitTest.Fixtures.Student", "PaginatedStudents")
  set rd = sd.%Execute(1, 5)
  
  do $$$AssertStatusOK(##class(Frontier.UnitTest.Util).MarshallSQLResult(rd, .array), "can read SQL result")
  set expected = {"results":(array)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="T">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set t = ..%New(##class(Port.UnitTest.Manager).%New())
  do t.OnBeforeAllTests()
  do t.OnBeforeOneTest()
  do t.TestGETDynamicSQLResult()
  do t.OnAfterOneTest()
  do t.OnAfterAllTests()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Types">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64502,35612.05458</TimeCreated>

<Method name="TestIsDataType">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%Library.String"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%String"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%ZEN.Datatype.boolean"), "can resolve deep inheritances (custom datatypes)")
]]></Implementation>
</Method>

<Method name="TestIsStream">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.Object"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.GlobalCharacter"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsSerial">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%Library.SerialObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%SerialObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsCollection">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Collection.AbstractIterator"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%ListOfDataTypes"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Library.ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsPersistent">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Library.Persistent"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Persistent"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Dictionary.ClassDefinition"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsInstantiable">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%Library.RegisteredObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%RegisteredObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%ZEN.proxyObject"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamic">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%Library.DynamicAbstractObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicArray"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamicArray">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%Library.DynamicArray"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%DynamicArray"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsDynamicObject">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%Library.DynamicObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%DynamicObject"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsSQLProvider">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSQLProvider("Frontier.SQL.Provider"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("Invalid"), "returns 0 if invalid")
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Util.Formatter.SnakeCase">
<Super>Frontier.Util.Formatter</Super>
<TimeCreated>64561,31150.13181</TimeCreated>

<Method name="OnFormat">
<ReturnType>%String</ReturnType>
</Method>
</Class>


<CSP name="email-template.html" application="/csp/dev/" default="1"><![CDATA[
<!DOCTYPE html>
<html>
<body style="font-family: monospace, 'Courier New', Verdana, sans-serif;">
  <table border=0>
    <thead>
      <tr>
        <th colspan="2" style="font-size: 16px; width: 560px; text-align: center; background-color: #c11b1b; color: #fff9f9;">
          REQUEST ERROR REPORT
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Description</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%1</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">URL</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%2</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Class</th>
        <td style="font-family: Consolas, Geneva, sans-serif; width: 400px; text-align: left;">%3</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Method</th>
        <td align="left">%4</td>
      </tr>
      <tr>
        <th style="text-align: left; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Arguments</th>
        <td align="left">%5</td>
      </tr>
      <tr>
        <th style="text-align: center; background-color: #c11b1b; color: #fff9f9; padding: 5px;">Stack</th>
        <td align="left">%6</td>
      </tr>
 </body>
 </html>
  </tbody>
</table>
]]></CSP>


<Routine name="frontier" type="INC"><![CDATA[
#include %ZEN.Utils

#define ltrim(%str)       $zstrip(%str, "<W")
#define rtrim(%str)       $zstrip(%str, ">W")
#define trim(%str)        $zstrip(%str, "<>W")
#define trimQuote(%str)   $zstrip(%str, "<>", $c(34))
#define IsSQLQuery(%str)  ($$$ucase($extract($$$trim(%str), 6)) = "SELECT")
#define KeyGroup(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "=>N")
#define KeyIndex(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "<=A")
]]></Routine>


<Project name="frontier" LastModified="2017-10-10 16:26:35.860281" Target="api/mobile/accounts/I432/devices" TargetType="3" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="Frontier.AbstractSerializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.ArgumentDescription" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.BasicStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.Strategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.StrategyCombiner" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Context" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Marshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Serializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Unmarshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Exception" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Method" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter.CamelCase" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter.SnakeCase" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter.Email" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.Provider" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.Serializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Map" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Route" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Routes" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Authentication.DummyStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Class" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Student" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Reporter.Email" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Reporter.Mock" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.WebApplicationInstaller" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Authentication.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Reporter.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Util.Formatter.SnakeCase" type="CLS"></ProjectItem>
    <ProjectItem name="csp/dev/email-template.html" type="CSP"></ProjectItem>
    <ProjectItem name="frontier.INC" type="MAC"></ProjectItem>
  </Items>
  <BreakPoints>
    <BreakPoint Routine="Frontier.Schema.Util.CLS" Offset="T+1"></BreakPoint>
  </BreakPoints>
</Project>
</Export>
