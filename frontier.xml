<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Frontier.ArgumentDescription">
<Super>%RegisteredObject</Super>
<TimeCreated>64492,37806.502663</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="DefaultValue">
<Type>%String</Type>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Arity">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Index">
<Type>%Integer</Type>
<Required>1</Required>
</Property>
</Class>


<Class name="Frontier.Context">
<Super>%RegisteredObject</Super>
<TimeCreated>64502,31617.993909</TimeCreated>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="CharSet">
<Type>%String</Type>
<InitialExpression>"utf-8"</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Session = session
  set i%Request = request
  set i%Response = response
  do ..Response.SetHeader("Content-Type", "application/json")
  set ..CharSet = "utf-8"  
  return $$$OK
]]></Implementation>
</Method>

<Method name="CharSetSet">
<FormalSpec>charset:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.CharSet = charset
  set ..Response.HeaderCharSet = charset  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Raw">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/plain")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsRaw">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/plain"
]]></Implementation>
</Method>

<Method name="HTML">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/html")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsHTML">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/html"
]]></Implementation>
</Method>

<Method name="JSON">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "application/json")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsJSON">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "application/json"
]]></Implementation>
</Method>

<Method name="Status">
<FormalSpec>statusCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.Status = statusCode
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Marshaller">
<Super>%RegisteredObject</Super>
<TimeCreated>64502,32993.705412</TimeCreated>

<Property name="Cache">
<Type>%DynamicObject</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Properties">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="DropCyclicReferences">
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$OK
]]></Implementation>
</Method>

<Method name="PropertiesSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Properties = $lfs(value)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Marshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicAbstractObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  if $isobject(object) {
    set type = $classname(object)
    if ##class(Frontier.Types).IsCollection(type) return marshaller.MakeDynamicCollection(object, .dynamicObject)
    if ##class(Frontier.Types).IsDynamic(type) return marshaller.MarshallPartial(object, .dynamicObject)
    if ##class(Frontier.Types).IsInstantiable(type) return marshaller.MakeDynamicObject(object, .dynamicObject)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="MarshallPartial">
<FormalSpec>dynamicInstance:%DynamicAbstractObject,marshalledObject:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set iterator = dynamicInstance.%GetIterator()
  set marshalledObject = $System.OBJ.New($classname(dynamicInstance))
  set dynamicValueResult = ""
  
  while iterator.%GetNext(.key, .value) {
    set dynamicValueResult = value
    if $isobject(value) {
      set valueType = $classname(value)
      if ##class(Frontier.Types).IsDynamic(valueType) {
        set sc = ..MarshallPartial(value, .dynamicValueResult)       
      } else {
        set sc = ..Marshall(value, .dynamicValueResult)
      }
      if $$$ISERR(sc) return sc
    }
    do marshalledObject.%Set(key, dynamicValueResult)
  }
  return sc
]]></Implementation>
</Method>

<Method name="MarshallCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%RegisteredObject,*dynamicCollection:%DynamicObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  quit marshaller.MakeDynamicCollection(collection, .dynamicCollection)
]]></Implementation>
</Method>

<Method name="MakeDynamicObject">
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicObject="",parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK     
  
  // Temporary table to reuse processed instances.
  if $data(i%Cache(object)) {
    quit $$$OK
  } else {
    set dynamicObject = ##class(%DynamicObject).%New()
    set i%Cache(object) = dynamicObject
  }
    
  set isSameObject = 0
  set affectedProperties = ""
  set classDescriptors = ##class(%Dictionary.CompiledClass).%OpenId($classname(object))
  
  if $lv(..Properties) && (..Properties '= "") {
    set affectedProperties = ##class(%ListOfObjects).%New()
    for i=1:1:classDescriptors.Properties.Count() {
      set propertyDescriptors = classDescriptors.Properties.GetAt(i)
      if $lf(..Properties, propertyDescriptors.Name) {
        set sc = affectedProperties.Insert(propertyDescriptors)
      }
    }
  } else {
    set affectedProperties = classDescriptors.Properties
  }  
    
  for i=1:1:affectedProperties.Count() {    
    set propertyDescriptors = affectedProperties.GetAt(i)    
    if '$isobject(propertyDescriptors) continue    
    if propertyDescriptors.Private || propertyDescriptors.Calculated || ($extract(propertyDescriptors.Name) = "%") continue
    if $isobject(parentObject) && ($classname(parentObject) = propertyDescriptors.Type) && 
      (parentKey = propertyDescriptors.Name) && (propertyDescriptors.Cardinality '= "") {
      // Prevents the buffer from overflowing by skipping parent relationship serialization.
      // DO NOT DISABLE THIS FLAG WHEN SERIALIZING TO JSON!
      if '..DropCyclicReferences set $property(dynamicObject, parentKey) = i%Cache(parentObject)
      continue
    }
    set value = $property(object, propertyDescriptors.Name)
    if $isobject(value) {
      if value.%IsA("%RelationshipObject") {
        set parentObject = object               
        set parentKey = propertyDescriptors.Inverse
      }
      if propertyDescriptors.Collection = "" {        
        if value.%Extends("%Stream.Object") {
          set proxifiedChild = $System.OBJ.New($classname(value))
          set sc = proxifiedChild.CopyFrom(value)
          if $$$ISERR(sc) quit
        } else {          
          set sc = ..MakeDynamicObject(value, .proxifiedChild)
        }        
      } else {
        set sc = ..MakeDynamicCollection(value, .proxifiedChild, parentKey, parentObject)          
      }
      if $$$ISERR(sc) quit
      set $property(dynamicObject, propertyDescriptors.Name) = proxifiedChild                  
    } else {
      set $property(dynamicObject, propertyDescriptors.Name) = $property(object, propertyDescriptors.Name)
    }      
  }  
  if object.%Extends("%Persistent") {
    if $lf(..Properties, "__id__") || (..Properties = "") {
      set id = object.%Id()
      if id '= "" set $property(dynamicObject, "__id__") = object.%Id()
    }
  }      
  quit sc
]]></Implementation>
</Method>

<Method name="MakeDynamicCollection">
<FormalSpec>collection:%Collection.Super,*dynamicCollection:%String,parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK   
  set startOffset = 0
      
  if collection.%IsA("%Collection.AbstractList") || collection.%IsA("%RelationshipObject") {
    set startOffset = 1
    set dynamicCollection = []
  } else {
    set dynamicCollection = {}
  }
   
  set key = ""
  
  while collection.GetNext(.key) {
    set item = collection.GetAt(key)
    
    if $isobject(item) {
      if item.%IsA("%Collection.AbstractIterator") {
        set sc = ..MakeDynamicCollection(item , .value)
      } else {
        set sc = ..MakeDynamicObject(item, .value, parentKey, parentObject)
      }
    } else {
      set value = item
    }
    
    do dynamicCollection.%Set(key - startOffset, value)    
    if $$$ISERR(sc) quit
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Unmarshaller">
<Abstract>1</Abstract>
<TimeCreated>64505,55057.137365</TimeCreated>

<Method name="Unmarshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  if $isobject(dynamicObject) {
    set dynamicType = $classname(dynamicObject)
    set isCollection = ##class(Frontier.Types).IsCollection(className) || ##class(Frontier.Types).IsDynamicArray(className)
    
    if ##class(Frontier.Types).IsDynamicArray(dynamicType) {
      return ..MakeCollection(className, dynamicObject, .registeredObject)
    } elseif 'isCollection && ##class(Frontier.Types).IsDynamicObject(dynamicType) && ##class(Frontier.Types).IsInstantiable(className) {
      return ..MakeObject(className, dynamicObject, .registeredObject)
    }    
  }
  return $$$ERROR($$$GeneralError, "Cannot unmarshall data types.")
]]></Implementation>
</Method>

<Method name="MakeObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*object:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set object = ""
  set sc = $$$OK
  
  if '$isobject(dynamicObject) || ($isobject(dynamicObject) && 'dynamicObject.%IsA("%DynamicObject")) {
    quit $$$ERROR($$$GeneralError, "dynamicObject must be an instance of %DynamicObject.")
  }
  
  if dynamicObject.%IsDefined("__id__") {
    set object = $System.OBJ.OpenId(className, dynamicObject.%Get("__id__"))
  }
  
  set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(className)
  set properties = descriptor.Properties
  
  set propCount = properties.Count()
  
  set iterator = dynamicObject.%GetIterator()  

  while iterator.%GetNext(.key, .value) {
    if key = "__id__" continue
    set propertyId = className_"||"_key
    set property = ##class(%Dictionary.CompiledProperty).%OpenId(propertyId)     
    if '$isobject(property) continue
    if property.Private || property.Calculated || ($extract(property.Name) = "%") continue
    if '$isobject(object) {
      set object = $System.OBJ.New(className)
    }
    set dynamicObjectPropertyValue = $property(dynamicObject, property.Name)
    set isDataType = ##class(Frontier.Types).IsDataType(property.Type)
    set isSerial = ##class(Frontier.Types).IsSerial(property.Type)
    if 'isDataType {      
      if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%IsA("%DynamicObject") {
        set sc = ..MakeObject(property.Type, dynamicObjectPropertyValue, .dynamicChildInstance)          
        quit:$$$ISERR(sc)
        set $property(object, property.Name) = dynamicChildInstance
      } elseif ##class(Frontier.Types).IsStream(property.Type) {
        set childStream = $System.OBJ.New(property.Type)
        if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%Extends("%Stream.Object") {         
          do childStream.CopyFrom(dynamicObjectPropertyValue)
        } else {          
          do childStream.Write(dynamicObjectPropertyValue)
        }
        set $property(object, property.Name) = childStream
      } elseif isSerial {
        set $property(object, property.Name) = $classmethod(property.Type, "%Open", $lb(dynamicObjectPropertyValue, property.Type))
      } elseif property.Collection '= "" {
        set collectionType = $property(object, property.Name).ElementType
        set dynamicChildInstance = $property(object, property.Name)   
        if $isobject(dynamicObjectPropertyValue) {    
          set sc = ..MakeCollection(collectionType, dynamicObjectPropertyValue, .dynamicChildInstance)        
          quit:$$$ISERR(sc)
          set $property(object, property.Name) = dynamicChildInstance
        } elseif dynamicObjectPropertyValue '= "" {
          set value = dynamicObjectPropertyValue         
          set childInstance = $System.OBJ.OpenId(className, value)
          if $isobject(childInstance) {
            set $property(object, property.Name) = $property(childInstance, property.Name)
          }
        }
      } else {
        set childInstance = $System.OBJ.OpenId(property.Type, value)
        if $isobject(childInstance) set $property(object, property.Name) = childInstance                   
      }      
    } else {
      if dynamicObjectPropertyValue = "null" set dynamicObjectPropertyValue = ""  
      if property.Type = "%Library.Boolean" { set logicalValue = $case(value, "true" : 1, "false" : 0, 1 : 1, 0 : 0, : "") }
      elseif property.Type = "%Library.Date" && (dynamicObjectPropertyValue?4N1"-"2N1"-"2N1"T"2N1":"2N1":"2N1"."3N1"Z" = 1) { set logicalValue = $zdateh($piece(dynamicObjectPropertyValue,"T",1),3,,,,,,,dynamicObjectPropertyValue) }
      else {
        if isDataType && (##class(%Dictionary.CompiledMethod).%ExistsId(property.Type_"||IsValid") && ('$classmethod(property.Type, "IsValid", dynamicObjectPropertyValue) = 1)) {
          try {
            set logicalValue = $method(object, property.Name_"DisplayToLogical", dynamicObjectPropertyValue)            
          } catch {
            set logicalValue = dynamicObjectPropertyValue
          }
        } else {
          set logicalValue = dynamicObjectPropertyValue
        }
      }
      set $property(object, property.Name) = logicalValue     
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="MakeCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collectionType:%String,dynamicCollection:%DynamicAbstractObject,*collection:%Collection.Super=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set insertStrategy = "list"
  set hasChildObjects = 0
  set collectionClass = "%ListOfDataTypes"
  set firstItem = dynamicCollection.%Get(0)
  set startOffset = 0  
  
  if collectionType [ "RelationshipObject" {
    set startOffset = 1
  } 
  
  if $isobject(firstItem) {    
    set hasChildObjects = '##class(Frontier.Types).IsDataType($classname(firstItem))   
  }
  
  if dynamicCollection.%IsA("%DynamicObject") {
    set insertStrategy = "Array"
    set collectionClass = $replace(collectionClass, "List", insertStrategy)
  }
  
  if hasChildObjects {
    set collectionClass = $replace(collectionClass, "OfDataTypes", "OfObjects")
  }
  
  // We must check for both occorences: 
  // 1 - When this method is called within Deproxify.
  // 2 - When this method is a first call.
  if $isobject(collection) {
    do collection.Clear()
  } else {      
    set collection = $System.OBJ.New(collectionClass)
    set collection.ElementType = collectionType
  }
  
  set iterator = dynamicCollection.%GetIterator()
  set isPersistentItem = ##class(Frontier.Types).IsPersistent(collectionType)
  
  while iterator.%GetNext(.key, .dynamicItem) { 
    set isIdCandidate = '$isobject(dynamicItem) && (dynamicItem '= "")
    set itemClass = $select('isIdCandidate : $classname(dynamicItem), 1: "")
    
    if dynamicItem = "null" && (itemClass '= "") {
      continue      
    }    
    
    if isIdCandidate && isPersistentItem {
      set item = $System.OBJ.OpenId(collectionType, dynamicItem)
    } elseif $isobject(dynamicItem) { 
      set sc = $select(
        dynamicItem.%IsA("%DynamicObject") : ..MakeObject(collectionType, dynamicItem, .item),
        dynamicItem.%Extends("%DynamicArray") : ..MakeCollection(itemClass, dynamicItem, .item),
        1: $$$ERROR($$$GeneralError, "Cannot unmarshall items that aren't dynamic.")
      )
      if item = "" continue
    } else {
      set item = dynamicItem
    }
        
    if $$$ISERR(sc) quit    
    
    if insertStrategy = "Array" {
      set key = $select($isvalidnum(key) && (startOffset > 0): key + startOffset, 1: key)
      do collection.SetAt(item, key)
    } else {
      do collection.Insert(item)
    } 
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Method">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,35961.209604</TimeCreated>

<Property name="MethodArguments">
<Type>ArgumentDescription</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="MethodDescriptor">
<Type>%Dictionary.CompiledMethod</Type>
<Private>1</Private>
</Property>

<Property name="ReturnTypeParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Payload">
<Type>%CacheString</Type>
</Property>

<Property name="HttpMethod">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="Arguments">
<Type>%CacheString</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>className:%String,methodName:%String,RESTMethodArguments:%String,request:%CSP.Request</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..AssertMethodExists(className, methodName))
  
  set ..MethodDescriptor = ##class(%Dictionary.CompiledMethod).%OpenId(className_"||"_methodName)  
  
  $$$ThrowOnError(..DescribeArguments())
  $$$ThrowOnError(..ParseReturnTypeParameters())
  
  merge requestQueryParams = request.Data
  $$$ThrowOnError(..MergeArguments(.RESTMethodArguments, .requestQueryParams, .mergedArguments))    
    
  set ..Payload = request.Content
  set ..HttpMethod = request.Method
  
  $$$ThrowOnError(..Sequentialize(.mergedArguments))
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DescribeArguments">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set describedArguments = ##class(%ListOfObjects).%New()
  set formalSpec = ..MethodDescriptor.FormalSpec
  set currentIndex = 0
  
  while $$ParseArgument(.parsedArgument) {
    set sc = ..MethodArguments.Insert(parsedArgument)
    if $$$ISERR(sc) return sc
  }
  
  return sc 
 
ParseArgument(parsedArgument)
  set currentIndex = currentIndex + 1
  set argument = $piece(formalSpec, ",", currentIndex)
  
  if argument '= "" {
    set parsedArgument = ##class(Frontier.ArgumentDescription).%New()
    if argument [ "..." set parsedArgument.Arity = 1
    set parsedArgument.Name = $replace($piece(argument, ":", 1), "...", "")
    set parsedArgument.DefaultValue = $piece(argument, "=", 2)
    set parsedArgument.Type = $piece($piece(argument, ":", 2), "=")
    set parsedArgument.Index = currentIndex
    quit 1
  }    
  quit 0
]]></Implementation>
</Method>

<Method name="FindDescribedArgumentByName">
<Internal>1</Internal>
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.ArgumentDescription</ReturnType>
<Implementation><![CDATA[
  
  for i=1:1:..MethodArguments.Count() {
    set argument = ..MethodArguments.GetAt(i)
    if argument.Name = name return argument
  }
  return ""
]]></Implementation>
</Method>

<Method name="ParseReturnTypeParameters">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set serializedParameters = ..MethodDescriptor.ReturnTypeParams
  if serializedParameters = "" return $$$OK
  set parametersCount = $length(serializedParameters, ",")  
  
  for i=1:1:parametersCount {
    set part = $piece(serializedParameters, ",", i)
    set parameterKey = $piece(part, "=", 1)
    set parameterValue = $piece(part, "=", 2)
    set i%ReturnTypeParameters(parameterKey) = parameterValue
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertMethodExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = className_"||"_methodName
  
  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$ClassDoesNotExist, className)   
  }    
  
  if '##class(%Dictionary.CompiledMethod).%ExistsId(id) {
    return $$$ERROR($$$MethodDoesNotExist, methodName)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Sequentialize">
<FormalSpec><![CDATA[&mergedArguments=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  #define TriggerPayloadFlag if ..HttpMethod = "POST" || (..HttpMethod = "PUT") || (..HttpMethod = "PATCH") set payloadFound = 1
  #define AssertSinglePayloadParameter throw:payloadFound=1 ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, "Cannot have more than one payload for POST/PUT/PATCH requests."))
  
  set sc = $$$OK  
  
  set argsProcessed = 0  
  set payloadFound = 0
    
  set methodArgumentsLength = ..MethodArguments.Count()
  
  set jsonErrorMessage = "Invalid JSON format, expected a %1 compatible notation."  
  if $$$ISERR(sc) return sc  
  
  set maxLength = methodArgumentsLength
  if maxLength < mergedArguments set maxLength = mergedArguments    
  
  if methodArgumentsLength > 0 {
    for argsProcessed=1:1:maxLength {       
      set methodArgument = $select(argsProcessed > methodArgumentsLength 
        :  ..MethodArguments.GetAt(methodArgumentsLength), 
        1: ..MethodArguments.GetAt(argsProcessed)
      )
      set value = $get(mergedArguments(argsProcessed))
    
      if value = "" {
        if 'methodArgument.Arity set value = methodArgument.DefaultValue
        else  set value = $get(mergedArguments(methodArgument.Index))
      }       
    
      if ##class(Frontier.Types).IsDynamic(methodArgument.Type) {
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set value = $classmethod(methodArgument.Type, "%FromJSON", ..Payload)
        if value = "" return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
      } elseif ##class(Frontier.Types).IsZENProxyObject(methodArgument.Type) {
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set sc = ##class(%ZEN.Auxiliary.altJSONProvider).%ConvertJSONToObject(..Payload,,.value)
        if $$$ISERR(sc) return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
      } elseif ##class(Frontier.Types).IsPersistent(methodArgument.Type) {
        set value = $System.OBJ.OpenId(methodArgument.Type, value)
        if '$isobject(value) set value = ""
      }
      set i%Arguments(argsProcessed) = value
    }
  }
  set i%Arguments = argsProcessed
  return sc
]]></Implementation>
</Method>

<Method name="MergeArguments">
<FormalSpec><![CDATA[&routeArguments:%String=0,&requestArguments:%String=0,*preArguments:%String=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set argumentIndex = routeArguments 
  set nextKeyIndex = 0
  set key = ""
  set preArguments = 0
  set methodArgumentsLength = ..MethodArguments.Count()  

  for {
    set key = $order(requestArguments(key))
    quit:key=""
    
    set keyGroup = $$$KeyGroup(key)
    set methodArgument = ..FindDescribedArgumentByName(keyGroup)
    
    if '$isobject(methodArgument) {
      return $$$ERROR($$$GeneralError, "Formal spec doesn't match with request: "_keyGroup_" was not expected.")
    }
    
    // Don't depend on query parameter repeatance, because JavaScript cannot repeat object keys.
    // Instead the parameter should follow the pattern "paramN" which represents a sequence.    
    set value = requestArguments(key, 1)  
    
    // Checks if we have a sequenced query param.
    if key?.A1.2N {               
      if methodArgumentsLength > 1 {     
        set argumentIndex = methodArgumentsLength + nextKeyIndex
      } else {
        set argumentIndex = nextKeyIndex + 1
      }
      
      set nextKeyIndex = nextKeyIndex + 1
      
      if nextKeyIndex '= $$$KeyIndex(key) {
        return $$$ERROR($$$GeneralError, keyGroup_" was expected to be sequential.")
      }
    } else {
      set argumentIndex = methodArgument.Index
    }
    set preArguments(argumentIndex) = value  
  }  
  
  // Now we must merge the arguments, remember that route arguments always take priority.    
  merge preArguments = routeArguments
  set preArguments = argumentIndex
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Router">
<Super>%CSP.REST</Super>
<TimeCreated>64492,32085.189445</TimeCreated>

<Method name="DispatchRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUrl:%String,pMethod:%String,pForwarded:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim tSC As %Status = $$$OK
  #dim e As %Exception.AbstractException
  
  #dim tMatcher As %Regex.Matcher
  
  #dim tArgs,tClass,tMatchUrl,tMapEntry,tRegEx,tCall,tForward,tAccess,tSupportedVerbs,tTarget,tType As %String
  #dim tI,tIndex As %Integer
  #dim tResourceMatched,tContinue As %Boolean
  #dim tMethodMatched As %Boolean
  
  new %frontier
  set %frontier = ..InitContext(%session, %request, %response)  
    
   try {       
    set (tResourceMatched,tMethodMatched) = 0    
                
    #; Extract the match url from the application name
    if (0=pForwarded) set tMatchUrl="/"_$extract(pUrl, $length(%request.Application)+1,*)
    else  set tMatchUrl=pUrl        
      
    #; Uppercase the method
    set pMethod=$ZCVT(pMethod,"U")
    set tHttpStatus = $case(pMethod, "POST": ..#HTTP201CREATED, : ..#HTTP200OK)
          
    #; Pre-Dispatch
    set tContinue = 1
    $$$ThrowOnError(..OnPreDispatch(tMatchUrl, pMethod, 1))        
            
    #; Walk the dispatch map in collation order of defintion
    for tIndex=1:1 {           
      
      #; Get the next map entry
      set tMapEntry = ..DispatchMap(tIndex) if tMapEntry="" quit
             
      #; Pick out the RegEx
      set tRegEx = $list(tMapEntry,2)
            
      #; Create a matcher
      set tMatcher = ##class(%Regex.Matcher).%New(tRegEx)
            
      #; Test each regular expression in turn, extracting the arguments,
      #; dispatching to the named method  
      if tMatcher.Match(tMatchUrl) {
                
        #; We have matched the resource
        set tResourceMatched = 1
                
        set tType = $list(tMapEntry,1)
                
        #; If we are a simple route
        if tType = "R" {
                   
          #; Support OPTIONS VERB (cannot be overriden)
          if pMethod="OPTIONS" {                       
            set tMethodMatched = 1                      
            $$$ThrowOnError(..OnHandleOptionsRequest(tMatchUrl))                        
                        
            #; Dispatch CORS
            $$$ThrowOnError(..ProcessCorsRequest(pUrl,$list(tMapEntry,5)))                       
            return $$$OK
          }        
                    
          #; comparison is case-insensitive now
          If pMethod '= $ZCVT($list(tMapEntry,3),"U") continue                   
          set tTarget = $list(tMapEntry,4)
                      
          #; We have matched a method
          set tMethodMatched = 1
                      
          #; Dispatch CORS
          $$$ThrowOnError(..ProcessCorsRequest(pUrl,$list(tMapEntry,5)))
                   
          #; Got a match, marshall the arguments can call directly
          if tMatcher.GroupCount {
            #; Modified for Frontier compatibility: store key instead of index. We need this info to correlate the arguments.            
            for tI=1:1:tMatcher.GroupCount set tArgs(tI)=tMatcher.Group(tI)
            set tArgs = tI
          } else {
            set tArgs=0
          }          
                    
          #; Check for optional ClassName prefix
          set tClass = $classname()
          If tTarget [ ":" set tClass = $piece(tTarget,":"), tTarget = $Piece(tTarget,":",2)
                              
          #; Dispatch
          #; Modified to add support for type resolution and query parameters
          set tPublicMethod = ##class(Method).%New(tClass, tTarget, .tArgs, %request)
          merge tMethodArguments = tPublicMethod.Arguments                
          
          if tMethodArguments > 0 {
            set return = $classmethod(tClass, tTarget, tMethodArguments...)
          } else {
            set return = $classmethod(tClass, tTarget)
          }
          $$$ThrowOnError(..DispatchResponse(return, .tReturnParameters))
          return $$$OK
        } else {                    
          #; We are a map, massage the URL and forward the request
          set tMatchUrl = $piece(tMatchUrl,tMatcher.Group(1),"2",*), tForward = $listget(tMapEntry,3)
          set (tResourceMatched, tMethodMatched) = 1
                   
          #; Dispatch with modified URL 
          $$$ThrowOnError($classmethod(tForward,"DispatchRequest",tMatchUrl,pMethod,1))
        }                        
        return $$$OK
      }              
    }
        
    #; Didn't have a match for the resource, report not found
    if tResourceMatched = 0 {
      set tHttpStatus = ..#HTTP404NOTFOUND
      $$$ThrowOnError($$$ERROR($$$GeneralError, ..#HTTP404NOTFOUND))
    }
                  
    #; Had a match for resource but method not matched
    if tMethodMatched = 0 {      
      set tSC = ..SupportedVerbs(tMatchUrl,.tSupportedVerbs)            
      return ..Http405(tSupportedVerbs) Quit
    }
  } catch (e) {
    do ..CaptureStack(.stack)
    if tHttpStatus < 300 set tHttpStatus = ..#HTTP500INTERNALSERVERERROR
    
    do ..ReportHttpStatusCode(tHttpStatus, e.AsStatus(), .json)
    set json.stack = stack.Read()
    
    do json.%ToJSON(, "aelo")
  }   
  return $$$OK
]]></Implementation>
</Method>

<Method name="DispatchResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[returnedData:%CacheString,method:Frontier.Router,&returnTypeParams=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // Enables device writing.
  write ""
  set isDeviceWrite = 0
  set response = {}
  set response.result = returnedData
  if $isobject(returnedData) {
    set type = $classname(returnedData)    
    set isCollection = ##class(Types).IsDynamicArray(type) || (type [ "List")
    set isMarshallable = isCollection || ##class(Types).IsDynamicObject(type) || ##class(Types).IsPersistent(type)
    set isSerializable = (isCollection || isMarshallable || ##class(Types).IsZENProxyObject(type)) && ($extract(type '= "%"))
    if 'isSerializable {
      return $$$ERROR($$$GeneralError, "Cannot serialize system class instances.")
    }
    if isMarshallable {
      $$$QuitOnError(##class(Frontier.Dynamic.Marshaller).Marshall(returnedData, .marshalledData))
      if isCollection set response.result = marshalledData
      else  set response = marshalledData
      do response.%ToJSON()
      return $$$OK
    } else {      
      $$$QuitOnError(##class(%ZEN.Auxiliary.altJSONProvider).%ObjectToJSON(returnedData,,,"aelo"))      
    }
  } elseif %frontier.IsJSON() {
    do response.%ToJSON()
  } else {
    // Since we only support HTML and JSON for now we will leave it without any extra checks.
    write returnedData
  }  
  return $$$OK
]]></Implementation>
</Method>

<Method name="outputStatus">
<Description>
This method takes a status, renders it as json (if requested) and outputs the result</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSC:%Status,*tJSON:%ZEN.proxyObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim tSC As %Status = $$$OK
  #dim e As %Exception.AbstractException   
   
  try {      
    if ..AcceptsContentType("application/json") {
      Set %response.ContentType = ..#CONTENTTYPEJSON        
      #; Convert the exception to a status and render to JSON
      
      set tSC = ..StatusToProxyObject(pSC, .tJSON)
      if $$$ISERR(tSC) return tSC
      #; Write the JSON to the output device
      if $$$ISERR(tSC) return tSC            
    } else {            
      #; Set plain text
      set %response.ContentType = ..#CONTENTTYPETEXT
      
      #; Write out a simple text message
      do ##class(%Exception.StatusException).CreateFromStatus(pSC).OutputToDevice()
    }        
  } catch (e) {        
    #; Oops
    set tSC = e.AsStatus()
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ReportHttpStatusCode">
<Description>
Issue an 'Http' error</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHttpStatus,pSC:%Status=$$$OK,*pData:%ZEN.proxyObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set %response.Status=pHttpStatus
    
    If $$$ISERR(pSC) Do ..outputStatus(pSC, .pData)
        
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InitContext">
<ClassMethod>1</ClassMethod>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.Context</ReturnType>
<Implementation><![CDATA[  return ##class(Frontier.Context).%New(session, request, response)
]]></Implementation>
</Method>

<Method name="CaptureStack">
<ClassMethod>1</ClassMethod>
<FormalSpec>*stackText:%Stream.GlobalCharacter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stackText = ##class(%Stream.GlobalCharacter).%New()
    
  do stackText.WriteLine("Runtime exception ")
  set max = $stack(-1)
  for loop=max:-1:1 {
    set sc  = stackText.WriteLine($char(9)_"     at "_$stack(loop, "PLACE")_$stack(loop, "MCODE")_" (Level: "_loop_")")
    if $$$ISERR(sc) return sc
  }   
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Types">
<Abstract>1</Abstract>
<TimeCreated>64502,35492.335596</TimeCreated>

<Method name="IsInstantiable">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%RegisteredObject", 0, "")
]]></Implementation>
</Method>

<Method name="IsPersistent">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Persistent", 0, "")
]]></Implementation>
</Method>

<Method name="IsDataType">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%DataType", 0, "datatype")
]]></Implementation>
</Method>

<Method name="IsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Stream.Object", 0, "")
]]></Implementation>
</Method>

<Method name="IsCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Collection.AbstractIterator", 0, "")
]]></Implementation>
</Method>

<Method name="IsSerial">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%SerialObject", 0, "serial")
]]></Implementation>
</Method>

<Method name="IsDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicAbstractObject", 0)
]]></Implementation>
</Method>

<Method name="IsDynamicArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicArray", 0)
]]></Implementation>
</Method>

<Method name="IsDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicObject", 0)
]]></Implementation>
</Method>

<Method name="IsZENProxyObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%ZEN.proxyObject", 0)
]]></Implementation>
</Method>

<Method name="IsTypeOf">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,expectedType:%String,whenNull:%String=0,expectedClassType:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  #define NormalizeClassName(%cn) if $l(%cn, ".") = 1 && ($e(%cn) = "%") set %cn = "%Library."_$e(%cn, 2, *)
  
  set isExpectedType = whenNull
  if className = "" quit isExpectedType
  
  $$$NormalizeClassName(className)
  $$$NormalizeClassName(expectedType)  
  
  if className = expectedType return 1
  
  // Uses default %Extends method to check for common cases and improve performance.
  set matches = ##class(%Dictionary.CompiledClass).%ExistsId(className) && $classmethod(className, "%Extends", expectedType)
  if matches = 1 return matches
  
  // Now we check classes that are custom data types.
  set definition = ##class(%Dictionary.CompiledClass).%OpenId(className)
  if $isobject(definition) {
    // This should contain one of: "serial" or "datatype".
    set isExpectedType = (definition.Super [ expectedType || (expectedClassType '= "" && (definition.ClassType = expectedClassType)))
    // If we did not find it, we must traverse the inheritance up to the super.
    if 'isExpectedType {
      if definition.Super [ "," {
        if definition.Inheritance '= "right" {
          for i=1:1:$length(definition.Super, ",") {     
            set superClass = $piece(definition.Super, ",", i)
            set isExpectedType = ..IsTypeOf(superClass, expectedType, whenNull, expectedClassType)
            if isExpectedType return isExpectedType
          }
        } else {
          for i=$length(definition.Super, ","):-1:1 {     
            set superClass = $piece(definition.Super, ",", i)
            set isExpectedType = ..IsTypeOf(superClass, expectedType, whenNull, expectedClassType)            
            if isExpectedType return isExpectedType
          }          
        }
      } else {
        set isExpectedType = ..IsTypeOf(definition.Super, expectedType, whenNull, expectedClassType)
      }
    }       
  }  
  return isExpectedType
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Class">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34585.6306</TimeCreated>

<Property name="Plate">
<Type>%String</Type>
</Property>

<Property name="Students">
<Type>Student</Type>
<Cardinality>many</Cardinality>
<Inverse>Class</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.Fix50C.ClassD</DataLocation>
<DefaultData>ClassDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.Fix50C.ClassD</IdLocation>
<IndexLocation>^Frontier.UnitTest.Fix50C.ClassI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.Fix50C.ClassS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="ClassDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Plate</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Plate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Student">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34683.761379</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Class">
<Type>Class</Type>
<Cardinality>one</Cardinality>
<Inverse>Students</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.F50C.StudentD</DataLocation>
<DefaultData>StudentDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.F50C.StudentD</IdLocation>
<IndexLocation>^Frontier.UnitTest.F50C.StudentI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.F50C.StudentS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="StudentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Class</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>14.2857%</Selectivity>
<AverageFieldSize>1.2</AverageFieldSize>
</Property>
<Property name="Name">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>14.6</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Router">
<Super>Frontier.Router</Super>
<TimeCreated>64503,35090.481271</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
  <Route Url="/route_params/:class" Method="GET" Call="TestGETRouteParams"/>
  <Route Url="/query_params" Method="GET" Call="TestGETOneQueryParameter"/>
  <Route Url="/rest_params" Method="GET" Call="TestGETRestParametersSum"/>
  <Route Url="/mixed/rest" Method="POST" Call="TestPOSTMixedRestParametersSum"/>
  <Route Url="/unpublished" Method="GET" Call="TestGETUnpublishedMethod"/>
  <Route Url="/payload/single_object" Method="POST" Call="TestPOSTObjectPayloadSingle"/>
  <Route Url="/payload/object_with_query_params" Method="POST" Call="TestPOSTObjectPayloadQueryParams"/>  
  <Route Url="/payload/single_array" Method="POST" Call="TestPOSTArrayPayloadSingle"/>
  <Route Url="/payload/array_with_query_params" Method="POST" Call="TestPOSTArrayPayloadQueryParams"/>
  <Route Url="/payload/invalid" Method="POST" Call="TestPOSTInvalidPayload"/>
  <Route Url="/mixed/object" Method="GET" Call="TestGETMixedDynamicObject"/>
  <Route Url="/mixed/array" Method="GET" Call="TestGETMixedDynamicArray"/>
  <Route Url="/raw" Method="GET" Call="TestGETRawMode"/>
 </Routes>
]]></Data>
</XData>

<Method name="TestGETRouteParams">
<Description>
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/route_params/6' 
{"Plate":"O5397","Students":[{"Name":"Drabek,Peter T.","__id__":"20"}],"__id__":"6"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return class
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Description>
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/query_params?msg=hello'
{result":"hello"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return "hello"
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Description><![CDATA[
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/rest_params?n1=10&n2=20&n3=30'
{"result":60}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n...:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set sum = 0
  for i=1:1:n  set sum = sum + n(i)
  return sum
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Description><![CDATA[
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/mixed/rest?n1=10&n2=20&msg=hello'
{"sum":30,"data":{"username":"xyz","password":"xyz"},"params":["10","20"],"msg":"hello"}}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,data:%DynamicObject,n...:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 
  set parameters = []  
  set sum = 0
  for i=1:1:n  set sum = sum + n(i) do parameters.%Push(n(i))
  return {
    "sum": (sum),
    "data": (data),
    "params": (parameters),
    "msg": (msg)
  }
  return sum
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Description>
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/single_object'
{"username":"xyz","password":"xyz"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Description>
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/object_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String="",payload:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return {
    "msg": (msg),
    "payload": (payload)
  }
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Description>
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/single_array'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Description>
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/array_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject,msg:%String=""</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (msg), (payload) ]
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Description>
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/invalid'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payloadA:%DynamicArray,payloadB:%DynamicObject</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return payloadA
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Description>
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/object?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "class": (class)
  }
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Description>
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/array?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (class) ]
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  return "hello raw response"
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64503,34684.599157</TimeCreated>

<Parameter name="FRONTIERTESTURL">
<Default>/api/frontier/test</Default>
</Parameter>

<Method name="CreateWebApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ns = $namespace
  new $namespace
  
  set $namespace = "%SYS"  
  set properties("NameSpace") = ns
  set properties("DispatchClass") = "Frontier.UnitTest.Router"  
  
  if ##class(Security.Applications).Exists(..#FRONTIERTESTURL) {
    $$$QuitOnError(..DestroyWebApp())
  }
  return ##class(Security.Applications).Create(..#FRONTIERTESTURL, .properties)
]]></Implementation>
</Method>

<Method name="DestroyWebApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set ns = $namespace
  new $namespace
  
  set $namespace = "%SYS"
  do ##class(%File).RemoveDirectoryTree($System.Util.InstallDirectory()_"csp/frontier")
  return ##class(Security.Applications).Delete(..#FRONTIERTESTURL)
]]></Implementation>
</Method>

<Method name="MergeErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec>errors:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  for i=0:1:(errors.%Size() - 1) {
    set errorObject = errors.%Get(i)
    set sc = $$$ADDSC(sc, $$$ERROR(errorObject.code, errorObject.params.%Get(0)))
  }
  
  return sc
]]></Implementation>
</Method>

<Method name="DeepCompare">
<FormalSpec>currentPersistent:%Persistent,currentProxy:JQX.ProxyObject,i=""</FormalSpec>
<Implementation><![CDATA[
  set sc = $$$OK
  
  while currentProxy.Next(.key, .proxyValue) {
    set propertyDescriptor = ##class(%Dictionary.CompiledProperty).%OpenId($classname(currentPersistent)_"||"_key)
    set skipCurrent = 0
    set entityValue = ..GetDeepChildPropertyValue(currentPersistent, $replace(key, "_", "."))
    if $isobject(entityValue) {
      if ##class(JQX.Utils.Descriptor).IsPersistent(propertyDescriptor.RuntimeType) set entityValue = entityValue.%Id()
      if ##class(JQX.Utils.Descriptor).IsStream(propertyDescriptor.RuntimeType) set entityValue = entityValue.Read()
    }
    if $isobject(proxyValue) && $isobject(entityValue) {
      if proxyValue.%Extends("%Collection.AbstractList") {
        if $isobject(proxyValue.GetAt(1)) {        
          for j=1:1:proxyValue.Count() {
            set childEntityObject = entityValue.GetAt(j)
            set childProxyObject = proxyValue.GetAt(j)    
            set sc = ..CompareValues(childEntityObject, childProxyObject, j)
            if $$$ISERR(sc) quit            
          }
        }
      }
    } elseif '$isobject(proxyValue) && '$isobject(entityValue) {
      if proxyValue = "" set proxyValue = "<EMPTY>"
      if entityValue = "" set entityValue = "<EMPTY>"
      if entityValue '= proxyValue {
        set sc = $$$ERROR($$$GeneralError, $$$FormatText("Assertion error: %1property %2, where prox value '= entity value. Mismatch: %3 '= %4", $select(i = "" : i, 1: "index at "_i_", "), key, proxyValue, entityValue))
      }
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="GetDeepChildPropertyValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>parent:%RegisteredObject,composedKey:%String</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
  set nextParent = parent
  set deepestLevel = $length(composedKey, ".")
  for i=1:1:deepestLevel {
    set nextParent = $property(nextParent, $piece(composedKey, ".", i, i))   
  }
  quit nextParent
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplication">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64506,60730.368136</TimeCreated>

<Projection name="Reference">
<Type>Frontier.UnitTest.WebApplication</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Frontier.UnitTest.Util).CreateWebApp()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Frontier.UnitTest.Util).DestroyWebApp()
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplicationInstaller">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64530,35966.171067</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Projection name="Installer">
<Type>Frontier.UnitTest.WebApplicationInstaller</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..CreateWebApplication()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..RemoveWebApplication()
]]></Implementation>
</Method>

<Method name="CreateWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set targetNamespace = $namespace
  
  new $namespace  
  set $namespace = "%SYS"
  
  write !, ">> Creating demo web application using namespace "_targetNamespace_" ..."
  if ##class(Security.Applications).Exists(..#NAME) {
    write !, ">> Application already exists, skipping ..."
    return $$$OK
  }
  
  set properties("CookiePath") = ..#NAME
  set properties("DispatchClass") = "Frontier.UnitTest.Router"
  set properties("Namespace") = targetNamespace
  set properties("UseCookies") = 2
  set properties("AutheEnabled") = 64
  
  $$$QuitOnError(##class(Security.Applications).Create(..#NAME, .properties))
  write !, ">> Application /api/frontier/test has been created."
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  
  if '##class(Security.Applications).Exists(..#NAME) return $$$OK
  write !, ">> Deleting sample web application ..."   
  
  $$$QuitOnError(##class(Security.Applications).Delete(..#NAME))
  write !, ">> Web application has been deleted with success."
  
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Router">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64499,42651.978954</TimeCreated>

<Parameter name="TESTSERVER">
<Default>localhost</Default>
</Parameter>

<Parameter name="TESTSERVERPORT">
<Default>57772</Default>
</Parameter>

<Property name="Request">
<Type>%Net.HttpRequest</Type>
</Property>

<Property name="Class">
<Type>Frontier.UnitTest.Fixtures.Class</Type>
</Property>

<Property name="Student">
<Type>Frontier.UnitTest.Fixtures.Student</Type>
</Property>

<Property name="WebApplicationName">
<Type>%String</Type>
<InitialExpression>$e(##class(Frontier.UnitTest.WebApplicationInstaller).#NAME, 2, *)</InitialExpression>
</Property>

<Method name="OnAfterAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  return ##class(Frontier.UnitTest.Fixtures.Student).%KillExtent()
]]></Implementation>
</Method>

<Method name="OnBeforeAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(Frontier.UnitTest.Fixtures.Class).Populate()
  do ##class(Frontier.UnitTest.Fixtures.Student).Populate()
  
  &sql(SELECT TOP 1 ID INTO :classId FROM FRONTIER_UNITTEST_FIXTURES.CLASS)
  &sql(SELECT TOP 1 ID INTO :studentId FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  
  set ..Class = ##class(Frontier.UnitTest.Fixtures.Class).%OpenId(classId)
  set ..Student = ##class(Frontier.UnitTest.Fixtures.Student).%OpenId(studentId)
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Request = ##class(%Net.HttpRequest).%New()
  do ..Request.SetHeader("Content-Type", "application/json; charset=utf-8")
  set ..Request.Server = ..#TESTSERVER
  set ..Request.Port = ..#TESTSERVERPORT
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertRequest">
<FormalSpec>resource:%String,expected:%DynamicAbstractObject="",method:%String="GET",payload:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $isobject(payload) {
    $$$QuitOnError(..Request.SetHeader("Content-Type", "application/json; charset=utf-8"))
    $$$QuitOnError(..Request.EntityBody.Write(payload.%ToJSON()))
  }
  
  $$$QuitOnError(..Request.Send(method, resource))
  set response = ..Request.HttpResponse.Data
  set responseText = response.Read()
  set expectedText = expected
  
  set firstByte = $extract(responseText)
  
  if $extract(firstByte)?1(1"{",2"[") {
    set response = ##class(%DynamicObject).%FromJSON(responseText)
    if $isobject(response) {
      if response.errors {
        return ##class(Frontier.UnitTest.Util).MergeErrors(response.errors)
      } else {
        if ##class(Frontier.Types).IsDynamic($classname(expected)) {
          set expectedText = expected.%ToJSON()
        }
      }
    }
  }
  
  if responseText '= expectedText {
    return $$$ERROR($$$GeneralError, $$$FormatText("The received content mismatches with the expected one: %1 '= %2", responseText, expectedText))
  }  
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1route_params/%2", ..WebApplicationName, ..Class.%Id())
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .expected)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Implementation><![CDATA[
  set expected = { "result": "hello" }  
  set resource = $$$FormatText("%1query_params?msg=%2", ..WebApplicationName, "hello")
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Implementation><![CDATA[
  set expected = { "result": 60 }
  set resource = $$$FormatText("%1rest_params?n1=10&n2=20&n3=30", ..WebApplicationName)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/rest?n1=10&n2=20&msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"sum":30,"data":{"username":"xyz","password":"xyz"},"params":["10","20"],"msg":"hello"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_object", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/object_with_query_params?msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"msg":"hello","payload":(payload)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_array", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = {"result":(payload)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/array_with_query_params?msg=hello", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = {"result":["hello",(payload)]}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/invalid", ..WebApplicationName)
  set payload = [{"username":"xyz","password":"xyz"}]
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */, "POST", payload), "returns an error if more than one payload is formally expected")
]]></Implementation>
</Method>

<Method name="TestGETInvalidRestSequence">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1rest_params?n1=&n4=10", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if rest argument index is not sequential")
]]></Implementation>
</Method>

<Method name="TestGETUnspecifiedArgument">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1query_params?unknown=1", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if an unknown argument is provided")
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/object?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = {"class":(class)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/array?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = {"result":[(class)]}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1raw", ..WebApplicationName)
  set expected = "hello raw response"
  return $$$AssertStatusOK(..AssertRequest(resource, expected))
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Types">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64502,35612.05458</TimeCreated>

<Method name="TestIsDataType">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%Library.String"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%String"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%ZEN.Datatype.boolean"), "can resolve deep inheritances (custom datatypes)")
]]></Implementation>
</Method>

<Method name="TestIsStream">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.Object"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.GlobalCharacter"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsSerial">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%Library.SerialObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%SerialObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsCollection">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Collection.AbstractIterator"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%ListOfDataTypes"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Library.ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsPersistent">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Library.Persistent"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Persistent"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Dictionary.ClassDefinition"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsInstantiable">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%Library.RegisteredObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%RegisteredObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%ZEN.proxyObject"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamic">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%Library.DynamicAbstractObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicArray"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamicArray">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%Library.DynamicArray"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%DynamicArray"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsDynamicObject">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%Library.DynamicObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%DynamicObject"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>
</Class>


<Routine name="frontier" type="INC"><![CDATA[
#define ltrim(%str)       $zstrip(%str, "<W")
#define rtrim(%str)       $zstrip(%str, ">W")
#define trim(%str)        $zstrip(%str, "<>W")
#define IsSQLQuery(%str)  ($$$ucase($extract($$$trim(%str), 6)) = "SELECT")
#define KeyGroup(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "=>N")
#define KeyIndex(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "<=A")
]]></Routine>


<Project name="frontier" LastModified="2017-09-04 11:42:47.50833" Target="##class(Frontier.Types).IsSerial(&quot;%Library.SerialObject&quot;)" TargetType="2" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="Frontier.ArgumentDescription" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Context" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Marshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Unmarshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Method" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Class" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Student" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.WebApplication" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.WebApplicationInstaller" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="frontier.INC" type="MAC"></ProjectItem>
  </Items>
</Project>
</Export>
