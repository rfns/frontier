<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Frontier.ArgumentDescription">
<Super>%RegisteredObject</Super>
<TimeCreated>64492,37806.502663</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="DefaultValue">
<Type>%String</Type>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Arity">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Index">
<Type>%Integer</Type>
<Required>1</Required>
</Property>
</Class>


<Class name="Frontier.Context">
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,31617.993909</TimeCreated>

<Property name="Session">
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="CharSet">
<Type>%String</Type>
<InitialExpression>"utf-8"</InitialExpression>
</Property>

<Property name="SQL">
<Type>Frontier.SQL</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Data">
<Type>%DynamicObject</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Session = session
  set i%Request = request
  set i%Response = response
  set i%SQL = ##class(Frontier.SQL).%New()
  do ..Response.SetHeader("Content-Type", "application/json")
  set ..CharSet = "utf-8"  
  return $$$OK
]]></Implementation>
</Method>

<Method name="CharSetSet">
<FormalSpec>charset:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.CharSet = charset
  set ..Response.HeaderCharSet = charset  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Raw">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/plain")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsRaw">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/plain"
]]></Implementation>
</Method>

<Method name="HTML">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "text/html")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsHTML">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "text/html"
]]></Implementation>
</Method>

<Method name="JSON">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..Response.SetHeader("Content-Type", "application/json")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsJSON">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return $$$lcase(..Response.ContentType) = "application/json"
]]></Implementation>
</Method>

<Method name="Status">
<FormalSpec>statusCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.Status = statusCode
  return $$$OK
]]></Implementation>
</Method>

<Method name="ThrowException">
<FormalSpec>message:%String,statusCode:%Integer=$$$GeneralError,parameters...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(parameters) set parameters = 0
  set args = 2 + parameters
  set args(1) = statusCode
  set args(2) = message
  
  for i=1:1:parameters set args(2+i) = parameters(i)
  throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(args...))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Marshaller">
<Super>%RegisteredObject</Super>
<TimeCreated>64502,32993.705412</TimeCreated>

<Property name="Cache">
<Type>%DynamicObject</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Properties">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="DropCyclicReferences">
<InitialExpression>1</InitialExpression>
</Property>

<Method name="%OnNew">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$OK
]]></Implementation>
</Method>

<Method name="PropertiesSet">
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Properties = $lfs(value)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Marshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicAbstractObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  if $isobject(object) {
    set type = $classname(object)
    if ##class(Frontier.Types).IsCollection(type) return marshaller.MakeDynamicCollection(object, .dynamicObject)
    if ##class(Frontier.Types).IsDynamic(type) return marshaller.MarshallPartial(object, .dynamicObject)
    if ##class(Frontier.Types).IsInstantiable(type) return marshaller.MakeDynamicObject(object, .dynamicObject)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="MarshallPartial">
<FormalSpec>dynamicInstance:%DynamicAbstractObject,marshalledObject:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set iterator = dynamicInstance.%GetIterator()
  set marshalledObject = $System.OBJ.New($classname(dynamicInstance))
  set dynamicValueResult = ""
  
  while iterator.%GetNext(.key, .value) {
    set dynamicValueResult = value
    if $isobject(value) {
      set valueType = $classname(value)
      set isDynamic = ##class(Frontier.Types).IsDynamic(valueType)
      set isStream = ##class(Frontier.Types).IsStream(valueType)
      set isSQLProvider = ##class(Frontier.Types).IsSQLProvider(valueType)
      if isDynamic {
        set sc = ..MarshallPartial(value, .dynamicValueResult)       
      } elseif 'isStream && 'isSQLProvider {
        set sc = ..Marshall(value, .dynamicValueResult)
      }
      if $$$ISERR(sc) return sc
    }
    do marshalledObject.%Set(key, dynamicValueResult)
  }
  return sc
]]></Implementation>
</Method>

<Method name="MarshallCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%RegisteredObject,*dynamicCollection:%DynamicObject,properties:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  quit marshaller.MakeDynamicCollection(collection, .dynamicCollection)
]]></Implementation>
</Method>

<Method name="MakeDynamicObject">
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicObject="",parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK     
  
  // Temporary table to reuse processed instances.
  if $data(i%Cache(object)) {
    quit $$$OK
  } else {
    set dynamicObject = ##class(%DynamicObject).%New()
    set i%Cache(object) = dynamicObject
  }
    
  set isSameObject = 0
  set affectedProperties = ""
  set classDescriptors = ##class(%Dictionary.CompiledClass).%OpenId($classname(object))
  
  if $lv(..Properties) && (..Properties '= "") {
    set affectedProperties = ##class(%ListOfObjects).%New()
    for i=1:1:classDescriptors.Properties.Count() {
      set propertyDescriptors = classDescriptors.Properties.GetAt(i)
      if $lf(..Properties, propertyDescriptors.Name) {
        set sc = affectedProperties.Insert(propertyDescriptors)
      }
    }
  } else {
    set affectedProperties = classDescriptors.Properties
  }  
    
  for i=1:1:affectedProperties.Count() {    
    set propertyDescriptors = affectedProperties.GetAt(i)    
    if '$isobject(propertyDescriptors) continue    
    if propertyDescriptors.Private || propertyDescriptors.Calculated || ($extract(propertyDescriptors.Name) = "%") continue
    if $isobject(parentObject) && ($classname(parentObject) = propertyDescriptors.Type) && 
      (parentKey = propertyDescriptors.Name) && (propertyDescriptors.Cardinality '= "") {
      // Prevents the buffer from overflowing by skipping parent relationship serialization.
      // DO NOT DISABLE THIS FLAG WHEN SERIALIZING TO JSON!
      if '..DropCyclicReferences set $property(dynamicObject, parentKey) = i%Cache(parentObject)
      continue
    }
    set value = $property(object, propertyDescriptors.Name)
    if $isobject(value) {
      if value.%IsA("%RelationshipObject") {
        set parentObject = object               
        set parentKey = propertyDescriptors.Inverse
      }
      if propertyDescriptors.Collection = "" {        
        if value.%Extends("%Stream.Object") {
          set proxifiedChild = $System.OBJ.New($classname(value))
          set sc = proxifiedChild.CopyFrom(value)
          if $$$ISERR(sc) quit
        } else {          
          set sc = ..MakeDynamicObject(value, .proxifiedChild)
        }        
      } else {
        set sc = ..MakeDynamicCollection(value, .proxifiedChild, parentKey, parentObject)          
      }
      if $$$ISERR(sc) quit
      set $property(dynamicObject, propertyDescriptors.Name) = proxifiedChild                  
    } else {
      set $property(dynamicObject, propertyDescriptors.Name) = $property(object, propertyDescriptors.Name)
    }      
  }  
  if object.%Extends("%Persistent") {
    if $lf(..Properties, "__id__") || (..Properties = "") {
      set id = object.%Id()
      if id '= "" set $property(dynamicObject, "__id__") = object.%Id()
    }
  }      
  quit sc
]]></Implementation>
</Method>

<Method name="MakeDynamicCollection">
<FormalSpec>collection:%Collection.Super,*dynamicCollection:%String,parentKey:%String="",parentObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK   
  set startOffset = 0
  set cyclicReferenceTrap = 0
      
  if collection.%IsA("%Collection.AbstractList") || collection.%IsA("%RelationshipObject") {
    set startOffset = 1
    set dynamicCollection = []
  } else {
    set dynamicCollection = {}
  }
   
  set key = ""
  
  while collection.GetNext(.key) {
    set item = collection.GetAt(key)
    
    if $isobject(item) {
      if item.%IsA("%Collection.AbstractIterator") {
        set sc = ..MakeDynamicCollection(item , .value)
      } else {
        set sc = ..MakeDynamicObject(item, .value, parentKey, parentObject)
        set cyclicReferenceTrap = (value = "")
      }
    } else {
      set value = item
    }
    
    if 'cyclicReferenceTrap do dynamicCollection.%Set(key - startOffset, value)    
    if $$$ISERR(sc) quit
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Serializer">
<IncludeCode>frontier,%ZEN.Utils</IncludeCode>
<TimeCreated>64531,58689.528672</TimeCreated>

<Method name="Serialize">
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,parentKey:%String=""</FormalSpec>
<Implementation><![CDATA[
  set isArray = ##class(Frontier.Types).IsDynamicArray($classname(dynamic))  
  
  if isArray {
    write "["
  } else {
    write "{"
  }
  
  set iterator = dynamic.%GetIterator()   
  set comma = ""  
  
  while iterator.%GetNext(.key, .value) {
    write comma
    set comma = ","
    if 'isArray write $$$ZENJSPROP(key)_":"
    if $isobject(value) {
      set type = $classname(value)
      if ##class(Frontier.Types).IsDynamic(type) {         
        do ..Serialize(value, key) 
      } elseif ##class(Frontier.Types).IsStream(type) {
        write $c(34)
        do WriteEscaped(value)
        write $c(34)
      } elseif ##class(Frontier.Types).IsSQLProvider(type) {        
        do value.RenderToJSON()
      }
    } else {
      write $$$ZENJSVALUE(value)
    }    
  }
  
  if isArray write "]"
  else  write "}"
  
  return $$$OK
  
WriteEscaped(v)
  while 'v.AtEnd { 
    write $$$ZENJSONESCAPE(v.Read(),"s")
  }
]]></Implementation>
</Method>

<Method name="SerializeToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,*stream:%Stream.Object</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
  new currentMnemonic, alreadyRedirected
  
  set isRedirected = 0
  
  set stream = ##class(%Stream.TmpBinary).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  
  try {
    set currentMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
    use $io::("^"_$zname)
    do ##class(%Device).ReDirectIO(1)
    do ..Serialize(dynamic)
  } catch ex {
    set sc = ex.AsStatus()
  }
  
  if alreadyRedirected { 
    do ##class(%Device).ReDirectIO(1) 
    use $io::(currentMnemonic) 
  }
  
  return $$$OK
  
wstr(s) Do stream.Write(s) Quit
wchr(a) Do stream.Write($char(a)) Quit
wnl Do stream.Write($char(13,10)) Quit
wff Do stream.Write($char(13,10,13,10)) Quit
wtab(n) Do stream.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Unmarshaller">
<Abstract>1</Abstract>
<TimeCreated>64505,55057.137365</TimeCreated>

<Method name="Unmarshall">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  if $isobject(dynamicObject) {
    set dynamicType = $classname(dynamicObject)
    set isCollection = ##class(Frontier.Types).IsCollection(className) || ##class(Frontier.Types).IsDynamicArray(className)
    
    if ##class(Frontier.Types).IsDynamicArray(dynamicType) {
      return ..MakeCollection(className, dynamicObject, .registeredObject)
    } elseif 'isCollection && ##class(Frontier.Types).IsDynamicObject(dynamicType) && ##class(Frontier.Types).IsInstantiable(className) {
      return ..MakeObject(className, dynamicObject, .registeredObject)
    }    
  }
  return $$$ERROR($$$GeneralError, "Cannot unmarshall data types.")
]]></Implementation>
</Method>

<Method name="MakeObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*object:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set object = ""
  set sc = $$$OK
  
  if '$isobject(dynamicObject) || ($isobject(dynamicObject) && 'dynamicObject.%IsA("%DynamicObject")) {
    quit $$$ERROR($$$GeneralError, "dynamicObject must be an instance of %DynamicObject.")
  }
  
  if dynamicObject.%IsDefined("__id__") {
    set object = $System.OBJ.OpenId(className, dynamicObject.%Get("__id__"))
  }
  
  set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(className)
  set properties = descriptor.Properties
  
  set propCount = properties.Count()
  
  set iterator = dynamicObject.%GetIterator()  

  while iterator.%GetNext(.key, .value) {
    if key = "__id__" continue
    set propertyId = className_"||"_key
    set property = ##class(%Dictionary.CompiledProperty).%OpenId(propertyId)     
    if '$isobject(property) continue
    if property.Private || property.Calculated || ($extract(property.Name) = "%") continue
    if '$isobject(object) {
      set object = $System.OBJ.New(className)
    }
    set dynamicObjectPropertyValue = $property(dynamicObject, property.Name)
    set isDataType = ##class(Frontier.Types).IsDataType(property.Type)
    set isSerial = ##class(Frontier.Types).IsSerial(property.Type)
    if 'isDataType {      
      if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%IsA("%DynamicObject") {
        set sc = ..MakeObject(property.Type, dynamicObjectPropertyValue, .dynamicChildInstance)          
        quit:$$$ISERR(sc)
        set $property(object, property.Name) = dynamicChildInstance
      } elseif ##class(Frontier.Types).IsStream(property.Type) {
        set childStream = $System.OBJ.New(property.Type)
        if $isobject(dynamicObjectPropertyValue) && dynamicObjectPropertyValue.%Extends("%Stream.Object") {         
          do childStream.CopyFrom(dynamicObjectPropertyValue)
        } else {          
          do childStream.Write(dynamicObjectPropertyValue)
        }
        set $property(object, property.Name) = childStream
      } elseif isSerial {
        set $property(object, property.Name) = $classmethod(property.Type, "%Open", $lb(dynamicObjectPropertyValue, property.Type))
      } elseif property.Collection '= "" {
        set collectionType = $property(object, property.Name).ElementType
        set dynamicChildInstance = $property(object, property.Name)   
        if $isobject(dynamicObjectPropertyValue) {    
          set sc = ..MakeCollection(collectionType, dynamicObjectPropertyValue, .dynamicChildInstance)        
          quit:$$$ISERR(sc)
          set $property(object, property.Name) = dynamicChildInstance
        } elseif dynamicObjectPropertyValue '= "" {
          set value = dynamicObjectPropertyValue         
          set childInstance = $System.OBJ.OpenId(className, value)
          if $isobject(childInstance) {
            set $property(object, property.Name) = $property(childInstance, property.Name)
          }
        }
      } else {
        set childInstance = $System.OBJ.OpenId(property.Type, value)
        if $isobject(childInstance) set $property(object, property.Name) = childInstance                   
      }      
    } else {
      if dynamicObjectPropertyValue = "null" set dynamicObjectPropertyValue = ""  
      if property.Type = "%Library.Boolean" { set logicalValue = $case(value, "true" : 1, "false" : 0, 1 : 1, 0 : 0, : "") }
      elseif property.Type = "%Library.Date" && (dynamicObjectPropertyValue?4N1"-"2N1"-"2N1"T"2N1":"2N1":"2N1"."3N1"Z" = 1) { set logicalValue = $zdateh($piece(dynamicObjectPropertyValue,"T",1),3,,,,,,,dynamicObjectPropertyValue) }
      else {
        if isDataType && (##class(%Dictionary.CompiledMethod).%ExistsId(property.Type_"||IsValid") && ('$classmethod(property.Type, "IsValid", dynamicObjectPropertyValue) = 1)) {
          try {
            set logicalValue = $method(object, property.Name_"DisplayToLogical", dynamicObjectPropertyValue)            
          } catch {
            set logicalValue = dynamicObjectPropertyValue
          }
        } else {
          set logicalValue = dynamicObjectPropertyValue
        }
      }
      set $property(object, property.Name) = logicalValue     
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="MakeCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>collectionType:%String,dynamicCollection:%DynamicAbstractObject,*collection:%Collection.Super=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set insertStrategy = "list"
  set hasChildObjects = 0
  set collectionClass = "%ListOfDataTypes"
  set firstItem = dynamicCollection.%Get(0)
  set startOffset = 0  
  
  if collectionType [ "RelationshipObject" {
    set startOffset = 1
  } 
  
  if $isobject(firstItem) {    
    set hasChildObjects = '##class(Frontier.Types).IsDataType($classname(firstItem))   
  }
  
  if dynamicCollection.%IsA("%DynamicObject") {
    set insertStrategy = "Array"
    set collectionClass = $replace(collectionClass, "List", insertStrategy)
  }
  
  if hasChildObjects {
    set collectionClass = $replace(collectionClass, "OfDataTypes", "OfObjects")
  }
  
  // We must check for both occorences: 
  // 1 - When this method is called within Deproxify.
  // 2 - When this method is a first call.
  if $isobject(collection) {
    do collection.Clear()
  } else {      
    set collection = $System.OBJ.New(collectionClass)
    set collection.ElementType = collectionType
  }
  
  set iterator = dynamicCollection.%GetIterator()
  set isPersistentItem = ##class(Frontier.Types).IsPersistent(collectionType)
  
  while iterator.%GetNext(.key, .dynamicItem) { 
    set isIdCandidate = '$isobject(dynamicItem) && (dynamicItem '= "")
    set itemClass = $select('isIdCandidate : $classname(dynamicItem), 1: "")
    
    if dynamicItem = "null" && (itemClass '= "") {
      continue      
    }    
    
    if isIdCandidate && isPersistentItem {
      set item = $System.OBJ.OpenId(collectionType, dynamicItem)
    } elseif $isobject(dynamicItem) { 
      set sc = $select(
        dynamicItem.%IsA("%DynamicObject") : ..MakeObject(collectionType, dynamicItem, .item),
        dynamicItem.%Extends("%DynamicArray") : ..MakeCollection(itemClass, dynamicItem, .item),
        1: $$$ERROR($$$GeneralError, "Cannot unmarshall items that aren't dynamic.")
      )
      if item = "" continue
    } else {
      set item = dynamicItem
    }
        
    if $$$ISERR(sc) quit    
    
    if insertStrategy = "Array" {
      set key = $select($isvalidnum(key) && (startOffset > 0): key + startOffset, 1: key)
      do collection.SetAt(item, key)
    } else {
      do collection.Insert(item)
    } 
  }
  quit sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Method">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,35961.209604</TimeCreated>

<Property name="MethodArguments">
<Type>ArgumentDescription</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="MethodDescriptor">
<Type>%Dictionary.CompiledMethod</Type>
<Private>1</Private>
</Property>

<Property name="ReturnTypeParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Payload">
<Type>%CacheString</Type>
</Property>

<Property name="HttpMethod">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="Arguments">
<Type>%CacheString</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>className:%String,methodName:%String,RESTMethodArguments:%String,request:%CSP.Request</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..AssertMethodExists(className, methodName))
  
  set ..MethodDescriptor = ##class(%Dictionary.CompiledMethod).%OpenId(className_"||"_methodName)  
  
  $$$ThrowOnError(..DescribeArguments())
  $$$ThrowOnError(..ParseReturnTypeParameters())
  
  merge requestQueryParams = request.Data
  $$$ThrowOnError(..MergeArguments(.RESTMethodArguments, .requestQueryParams, .mergedArguments))    
    
  set ..Payload = request.Content
  set ..HttpMethod = request.Method
  
  $$$ThrowOnError(..Sequentialize(.mergedArguments))
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DescribeArguments">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set describedArguments = ##class(%ListOfObjects).%New()
  set formalSpec = ..MethodDescriptor.FormalSpec
  set currentIndex = 0
  
  while $$ParseArgument(.parsedArgument) {
    set sc = ..MethodArguments.Insert(parsedArgument)
    if $$$ISERR(sc) return sc
  }
  
  return sc 
 
ParseArgument(parsedArgument)
  set currentIndex = currentIndex + 1
  set argument = $piece(formalSpec, ",", currentIndex)
  
  if argument '= "" {
    set parsedArgument = ##class(Frontier.ArgumentDescription).%New()
    if argument [ "..." set parsedArgument.Arity = 1
    set parsedArgument.Name = $replace($piece(argument, ":", 1), "...", "")
    set parsedArgument.DefaultValue = $piece(argument, "=", 2)
    set parsedArgument.Type = $piece($piece(argument, ":", 2), "=")
    set parsedArgument.Index = currentIndex
    quit 1
  }    
  quit 0
]]></Implementation>
</Method>

<Method name="FindDescribedArgumentByName">
<Internal>1</Internal>
<FormalSpec>name:%String</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.ArgumentDescription</ReturnType>
<Implementation><![CDATA[
  
  for i=1:1:..MethodArguments.Count() {
    set argument = ..MethodArguments.GetAt(i)
    if argument.Name = name return argument
  }
  return ""
]]></Implementation>
</Method>

<Method name="ParseReturnTypeParameters">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set serializedParameters = ..MethodDescriptor.ReturnTypeParams
  if serializedParameters = "" return $$$OK
  set parametersCount = $length(serializedParameters, ",")  
  
  for i=1:1:parametersCount {
    set part = $piece(serializedParameters, ",", i)
    set parameterKey = $piece(part, "=", 1)
    set parameterValue = $piece(part, "=", 2)
    set i%ReturnTypeParameters(parameterKey) = parameterValue
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertMethodExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = className_"||"_methodName
  
  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$ClassDoesNotExist, className)   
  }    
  
  if '##class(%Dictionary.CompiledMethod).%ExistsId(id) {
    return $$$ERROR($$$MethodDoesNotExist, methodName)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Sequentialize">
<FormalSpec><![CDATA[&mergedArguments=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  #define TriggerPayloadFlag if ..HttpMethod = "POST" || (..HttpMethod = "PUT") || (..HttpMethod = "PATCH") set payloadFound = 1
  #define AssertSinglePayloadParameter throw:payloadFound=1 ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, "Cannot have more than one payload for POST/PUT/PATCH requests."))
  
  set sc = $$$OK  
  
  set argsProcessed = 0  
  set payloadFound = 0
    
  set methodArgumentsLength = ..MethodArguments.Count()
  
  set jsonErrorMessage = "Invalid JSON format, expected a %1 compatible notation."  
  if $$$ISERR(sc) return sc  
  
  set maxLength = methodArgumentsLength
  if maxLength < mergedArguments set maxLength = mergedArguments
      
  
  if methodArgumentsLength > 0 {
    for argsProcessed=1:1:maxLength {       
      set methodArgument = $select(argsProcessed > methodArgumentsLength 
        :  ..MethodArguments.GetAt(methodArgumentsLength), 
        1: ..MethodArguments.GetAt(argsProcessed)
      )
      set value = $get(mergedArguments(argsProcessed))
    
      if value = "" {
        if 'methodArgument.Arity set value = methodArgument.DefaultValue
        else  set value = $get(mergedArguments(methodArgument.Index))
      }       
    
      if ##class(Frontier.Types).IsDynamic(methodArgument.Type) {
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set value = $classmethod(methodArgument.Type, "%FromJSON", ..Payload)
        if value = "" return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
      } elseif ##class(Frontier.Types).IsZENProxyObject(methodArgument.Type) {
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag
        set sc = ##class(%ZEN.Auxiliary.altJSONProvider).%ConvertJSONToObject(..Payload,,.value)
        if $$$ISERR(sc) return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, methodArgument.Type))
      } elseif ##class(Frontier.Types).IsPersistent(methodArgument.Type) {
        set value = $System.OBJ.OpenId(methodArgument.Type, value)
        if '$isobject(value) set value = ""
      }
      set i%Arguments(argsProcessed) = value
    }
  }
  set i%Arguments = argsProcessed
  return sc
]]></Implementation>
</Method>

<Method name="MergeArguments">
<FormalSpec><![CDATA[&routeArguments:%String=0,&requestArguments:%String=0,*preArguments:%String=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set argumentIndex = routeArguments 
  set nextKeyIndex = 0
  set key = ""
  set preArguments = 0
  set methodArgumentsLength = ..MethodArguments.Count()  

  for {
    set key = $order(requestArguments(key))
    quit:key=""
    
    
    set keyGroup = $$$KeyGroup(key)
    set methodArgument = ..FindDescribedArgumentByName(keyGroup)
    
    if '$isobject(methodArgument) {
      return $$$ERROR($$$GeneralError, "Formal spec doesn't match with request: "_keyGroup_" was not expected.")
    }
    
    // Don't depend on query parameter repeatance, because JavaScript cannot repeat object keys.
    // Instead the parameter should follow the pattern "paramN" which represents a sequence.    
    set value = requestArguments(key, 1)  
    
    // Checks if we have a sequenced query param.
    if key?.A1.2N {               
      if methodArgumentsLength > 1 {     
        set argumentIndex = methodArgumentsLength + nextKeyIndex
      } else {
        set argumentIndex = nextKeyIndex + 1
      }
      
      set nextKeyIndex = nextKeyIndex + 1
      
      if nextKeyIndex '= $$$KeyIndex(key) {
        return $$$ERROR($$$GeneralError, keyGroup_" was expected to be sequential.")
      }
    } else {
      set argumentIndex = methodArgument.Index
    }
    set preArguments(argumentIndex) = value  
  }  
  
  // Now we must merge the arguments, remember that route arguments always take priority.    
  merge preArguments = routeArguments
  set preArguments = argumentIndex
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Router">
<Super>%CSP.REST</Super>
<TimeCreated>64492,32085.189445</TimeCreated>

<Method name="DispatchRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUrl:%String,pMethod:%String,pForwarded:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  #; This is a modified version of %CSP.REST's DispatchRequest that creates an entry point for
  #; for additional features.
  #; TODO: Check the possibility of purging this source code to stop ovewriting the original method.
  
  #dim tSC As %Status = $$$OK
  #dim e As %Exception.AbstractException
  
  #dim tMatcher As %Regex.Matcher
  
  #dim tArgs,tClass,tMatchUrl,tMapEntry,tRegEx,tCall,tForward,tAccess,tSupportedVerbs,tTarget,tType As %String
  #dim tI,tIndex As %Integer
  #dim tResourceMatched,tContinue As %Boolean
  #dim tMethodMatched As %Boolean
  
  new %frontier
  set %frontier = ..InitContext(%session, %request, %response)  
    
   try {       
    set (tResourceMatched,tMethodMatched) = 0    
                
    #; Extract the match url from the application name
    if (0=pForwarded) set tMatchUrl="/"_$extract(pUrl, $length(%request.Application)+1,*)
    else  set tMatchUrl=pUrl        
      
    #; Uppercase the method
    set pMethod=$ZCVT(pMethod,"U")
    set tHttpStatus = $case(pMethod, "POST": ..#HTTP201CREATED, : ..#HTTP200OK)
          
    #; Pre-Dispatch
    set tContinue = 1
    $$$ThrowOnError(..OnPreDispatch(tMatchUrl, pMethod, 1))        
            
    #; Walk the dispatch map in collation order of defintion
    for tIndex=1:1 {           
      
      #; Get the next map entry
      set tMapEntry = ..DispatchMap(tIndex) if tMapEntry="" quit
             
      #; Pick out the RegEx
      set tRegEx = $list(tMapEntry,2)
            
      #; Create a matcher
      set tMatcher = ##class(%Regex.Matcher).%New(tRegEx)
            
      #; Test each regular expression in turn, extracting the arguments,
      #; dispatching to the named method  
      if tMatcher.Match(tMatchUrl) {
                
        #; We have matched the resource
        set tResourceMatched = 1
                
        set tType = $list(tMapEntry,1)
                
        #; If we are a simple route
        if tType = "R" {
                   
          #; Support OPTIONS VERB (cannot be overriden)
          if pMethod="OPTIONS" {                       
            set tMethodMatched = 1                      
            $$$ThrowOnError(..OnHandleOptionsRequest(tMatchUrl))                        
                        
            #; Dispatch CORS
            $$$ThrowOnError(..ProcessCorsRequest(pUrl,$list(tMapEntry,5)))                       
            return $$$OK
          }        
                    
          #; comparison is case-insensitive now
          If pMethod '= $ZCVT($list(tMapEntry,3),"U") continue                   
          set tTarget = $list(tMapEntry,4)
                      
          #; We have matched a method
          set tMethodMatched = 1
                      
          #; Dispatch CORS
          $$$ThrowOnError(..ProcessCorsRequest(pUrl,$list(tMapEntry,5)))
                   
          #; Got a match, marshall the arguments can call directly
          if tMatcher.GroupCount {
            #; Modified for Frontier compatibility: store key instead of index. We need this info to correlate the arguments.            
            for tI=1:1:tMatcher.GroupCount set tArgs(tI)=tMatcher.Group(tI)
            set tArgs = tI
          } else {
            set tArgs=0
          }          
                    
          #; Check for optional ClassName prefix
          set tClass = $classname()
          If tTarget [ ":" set tClass = $piece(tTarget,":"), tTarget = $Piece(tTarget,":",2)
                              
          #; Dispatch
          #; Modified to add support for type resolution and query parameters
          set tPublicMethod = ##class(Method).%New(tClass, tTarget, .tArgs, %request)
          merge tMethodArguments = tPublicMethod.Arguments
          
          set receivedData = ..OnReceivingData()
          
          if '$isobject(receivedData) || ($isobject(receivedData) && 'receivedData.%IsA("%DynamicObject"))  {
            $$$ThrowOnError($$$ERROR($$$GeneralError, "OnReceivingData must return a %DynamicObject."))
          } else {
            set %frontier.Data = receivedData
          }          
                   
          if tMethodArguments > 0 {
            set return = $classmethod(tClass, tTarget, tMethodArguments...)
          } else {            
            set return = $classmethod(tClass, tTarget)
          }
          $$$ThrowOnError(..DispatchResponse(return, .tReturnParameters))
          return $$$OK
        } else {                    
          #; We are a map, massage the URL and forward the request
          set tMatchUrl = $piece(tMatchUrl,tMatcher.Group(1),"2",*), tForward = $listget(tMapEntry,3)
          set (tResourceMatched, tMethodMatched) = 1
                   
          #; Dispatch with modified URL 
          $$$ThrowOnError($classmethod(tForward,"DispatchRequest",tMatchUrl,pMethod,1))
        }                        
        return $$$OK
      }              
    }
        
    #; Didn't have a match for the resource, report not found
    if tResourceMatched = 0 {
      set tHttpStatus = ..#HTTP404NOTFOUND
      $$$ThrowOnError($$$ERROR($$$GeneralError, ..#HTTP404NOTFOUND))
    }
                  
    #; Had a match for resource but method not matched
    if tMethodMatched = 0 {      
      set tSC = ..SupportedVerbs(tMatchUrl,.tSupportedVerbs)            
      return ..Http405(tSupportedVerbs) Quit
    }
  } catch (e) {
    do ..CaptureStack(.stack)
    if tHttpStatus < 300 set tHttpStatus = ..#HTTP500INTERNALSERVERERROR
    
    do ..ReportHttpStatusCode(tHttpStatus, e.AsStatus(), .json)
    set json.stack = stack.Read()
    
    do json.%ToJSON(, "aelo")
  }   
  return $$$OK
]]></Implementation>
</Method>

<Method name="DispatchResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[returnedData:%CacheString,method:Frontier.Router,&returnTypeParams=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  set response = {}
  
  // Enables device writing.
  write ""
  
  if $isobject(returnedData) {
    set type = $classname(returnedData)
    set isCollection = ##class(Types).IsCollection(type)
    set isSQLProvider = ##class(Types).IsSQLProvider(type)
    set isStream = ##class(Types).IsStream(type)
    set isDynamic = ##class(Types).IsDynamic(type)
    set isSystemType = ($extract(type) = "%")
    set isMarshallable = isCollection || isDynamic || isStream || isSQLProvider || ('isSystemType && ##class(Types).IsInstantiable(type))
    if isMarshallable {
      if isStream {
        set stream = returnedData set returnedData = response
        set response.content = stream
      } elseif isSQLProvider {
        set results = returnedData set returnedData = response
        set response.results = results
      }
      $$$QuitOnError(##class(Frontier.Dynamic.Marshaller).Marshall(returnedData, .response))
    } else {
      return $$$ERROR($$$GeneralError, "Cannot serialize system class instances.")
    }
  } elseif %frontier.IsJSON() {
    set response.result = returnedData
  } else {
    write returnedData
    return $$$OK
  }
  // We must use a custom serializer because the current %ToJSON implementation cannot serialize
  // mixed instances.
  do ##class(Frontier.Dynamic.Serializer).Serialize(response)
  return $$$OK
]]></Implementation>
</Method>

<Method name="outputStatus">
<Description>
This method takes a status, renders it as json (if requested) and outputs the result</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSC:%Status,*tJSON:%ZEN.proxyObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim tSC As %Status = $$$OK
  #dim e As %Exception.AbstractException   
   
  try {      
    if ..AcceptsContentType("application/json") {
      Set %response.ContentType = ..#CONTENTTYPEJSON        
      #; Convert the exception to a status and render to JSON
      
      set tSC = ..StatusToProxyObject(pSC, .tJSON)
      if $$$ISERR(tSC) return tSC
      #; Write the JSON to the output device
      if $$$ISERR(tSC) return tSC            
    } else {            
      #; Set plain text
      set %response.ContentType = ..#CONTENTTYPETEXT
      
      #; Write out a simple text message
      do ##class(%Exception.StatusException).CreateFromStatus(pSC).OutputToDevice()
    }        
  } catch (e) {        
    #; Oops
    set tSC = e.AsStatus()
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ReportHttpStatusCode">
<Description>
Issue an 'Http' error</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHttpStatus,pSC:%Status=$$$OK,*pData:%ZEN.proxyObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set %response.Status=pHttpStatus
    
    If $$$ISERR(pSC) Do ..outputStatus(pSC, .pData)
        
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InitContext">
<ClassMethod>1</ClassMethod>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.Context</ReturnType>
<Implementation><![CDATA[  return ##class(Frontier.Context).%New(session, request, response)
]]></Implementation>
</Method>

<Method name="CaptureStack">
<ClassMethod>1</ClassMethod>
<FormalSpec>*stackText:%Stream.GlobalCharacter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stackText = ##class(%Stream.GlobalCharacter).%New()
    
  do stackText.WriteLine("Runtime exception ")
  set max = $stack(-1)
  for loop=max:-1:1 {
    set sc  = stackText.WriteLine($char(9)_"     at "_$stack(loop, "PLACE")_$stack(loop, "MCODE")_" (Level: "_loop_")")
    if $$$ISERR(sc) return sc
  }   
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnReceivingData">
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return {}
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL">
<Super>%RegisteredObject</Super>
<TimeCreated>64531,35746.997056</TimeCreated>

<Method name="Prepare">
<FormalSpec>statement:%String</FormalSpec>
<Implementation><![CDATA[  return ##class(Frontier.SQL.Provider).%New(statement)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.DeviceOutputAdapter">
<Super>%ZEN.Auxiliary.altJSONSQLProvider</Super>
<TimeCreated>64532,54699.043149</TimeCreated>

<Method name="%DrawJSON">
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set ..contentType = "array"
  set key = ""
  
  try {    
    while ..parameters.GetNext(.key) {
      set value = ..parameters.GetAt(key).value
      Set parameters(key) = $$$ZENVAL(value)
    }        
    
    set queryInfo = ##class(%ZEN.Auxiliary.QueryInfo).%New()     
    merge queryInfo.parms = parameters
    set resultSet = ..%CreateResultSet(.sc, queryInfo)
    if $$$ISERR(sc) || '$isobject(resultSet) write "null" quit
    
    kill columnInfo
    
    if resultSet.%IsA("%Library.ResultSet") {
      set columnsCount = resultSet.GetColumnCount()
      for c = 1:1:columnsCount {
       Set columnInfo(c,"name") = resultSet.GetColumnHeader(c)
      }
    } else {
      set columnsCount = resultSet.%ResultColumnCount
      for c = 1:1:columnsCount {
        set columnInfo(c,"name") = resultSet.%Metadata.columns.GetAt(c).label
      }
    }   
    
    set arrayNode = []    
    Set row = 0
    
    while (resultSet.%Next(.sc) && ((..maxRows = 0) || (row < ..maxRows))) {
      quit:$$$ISERR(sc)
      set row = row + 1
      set node = {}
      for c = 1:1:resultSet.%ResultColumnCount {
        set value = resultSet.%GetData(c)
        
        if ($isvalidnum(value) && ($e(value) '= 0)) do node.%Set($get(columnInfo(c,"name")),$num(value),"number")
        else  do node.%Set($get(columnInfo(c,"name")),value)
      }
      Do arrayNode.%Push(node)
    }   
    do arrayNode.%ToJSON()    
  } catch ex {
    Write "null"
    Set tSC = ex.AsStatus()  
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Provider">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64531,36463.732591</TimeCreated>

<Property name="SQLProvider">
<Type>Frontier.SQL.DeviceOutputAdapter</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>statement:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..CreateProvider(statement))
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateProvider">
<FormalSpec>statement:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set ..SQLProvider = ##class(Frontier.SQL.DeviceOutputAdapter).%New()
  set ..SQLProvider.maxRows = 0
  
  if $length(statement, ":") = 2 {   
    set ..SQLProvider.queryClass = $piece(statement, ":")
    set ..SQLProvider.queryName = $piece(statement, ":", 2)
  } elseif $extract($$$ucase($$$trim(statement)), 1, 6) = "SELECT" {
    set ..SQLProvider.sql = statement    
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Parameters">
<FormalSpec>params...:%String</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  do ..SQLProvider.parameters.Clear()
  
  for i=1:1:params {
    set parameter = ##class(%ZEN.Auxiliary.parameter).%New()
    set parameter.value = params(i)
    do ..SQLProvider.parameters.SetAt(parameter, i)
  }
  return $this
]]></Implementation>
</Method>

<Method name="RenderToJSON">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..SQLProvider.%DrawJSON()
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Types">
<Abstract>1</Abstract>
<TimeCreated>64502,35492.335596</TimeCreated>

<Method name="IsInstantiable">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%RegisteredObject", 0, "")
]]></Implementation>
</Method>

<Method name="IsPersistent">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Persistent", 0, "")
]]></Implementation>
</Method>

<Method name="IsDataType">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%DataType", 0, "datatype")
]]></Implementation>
</Method>

<Method name="IsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Stream.Object", 0, "")
]]></Implementation>
</Method>

<Method name="IsCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Collection.AbstractIterator", 0, "")
]]></Implementation>
</Method>

<Method name="IsSerial">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%SerialObject", 0, "serial")
]]></Implementation>
</Method>

<Method name="IsDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicAbstractObject", 0)
]]></Implementation>
</Method>

<Method name="IsDynamicArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicArray", 0)
]]></Implementation>
</Method>

<Method name="IsDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicObject", 0)
]]></Implementation>
</Method>

<Method name="IsZENProxyObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%ZEN.proxyObject", 0)
]]></Implementation>
</Method>

<Method name="IsSQLProvider">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "Frontier.SQL.Provider", 0)
]]></Implementation>
</Method>

<Method name="IsTypeOf">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,expectedType:%String,whenNull:%String=0,expectedClassType:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  #define NormalizeClassName(%cn) if $l(%cn, ".") = 1 && ($e(%cn) = "%") set %cn = "%Library."_$e(%cn, 2, *)
  
  set isExpectedType = whenNull
  if className = "" quit isExpectedType
  
  $$$NormalizeClassName(className)
  $$$NormalizeClassName(expectedType)  
  
  if className = expectedType return 1
  
  // Uses default %Extends method to check for common cases and improve performance.
  set matches = ##class(%Dictionary.CompiledClass).%ExistsId(className) && $classmethod(className, "%Extends", expectedType)
  if matches = 1 return matches
  
  // Now we check classes that are custom data types.
  set definition = ##class(%Dictionary.CompiledClass).%OpenId(className)
  if $isobject(definition) {
    // This should contain one of: "serial" or "datatype".
    set isExpectedType = (definition.Super [ expectedType || (expectedClassType '= "" && (definition.ClassType = expectedClassType)))
    // If we did not find it, we must traverse the inheritance up to the super.
    if 'isExpectedType {
      if definition.Super [ "," {
        if definition.Inheritance '= "right" {
          for i=1:1:$length(definition.Super, ",") {     
            set superClass = $piece(definition.Super, ",", i)
            set isExpectedType = ..IsTypeOf(superClass, expectedType, whenNull, expectedClassType)
            if isExpectedType return isExpectedType
          }
        } else {
          for i=$length(definition.Super, ","):-1:1 {     
            set superClass = $piece(definition.Super, ",", i)
            set isExpectedType = ..IsTypeOf(superClass, expectedType, whenNull, expectedClassType)            
            if isExpectedType return isExpectedType
          }          
        }
      } else {
        set isExpectedType = ..IsTypeOf(definition.Super, expectedType, whenNull, expectedClassType)
      }
    }       
  }  
  return isExpectedType
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Class">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34585.6306</TimeCreated>

<Property name="Plate">
<Type>%String</Type>
</Property>

<Property name="Students">
<Type>Student</Type>
<Cardinality>many</Cardinality>
<Inverse>Class</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.Fix50C.ClassD</DataLocation>
<DefaultData>ClassDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.Fix50C.ClassD</IdLocation>
<IndexLocation>^Frontier.UnitTest.Fix50C.ClassI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.Fix50C.ClassS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="ClassDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Plate</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Plate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>4.8</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Student">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34683.761379</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Class">
<Type>Class</Type>
<Cardinality>one</Cardinality>
<Inverse>Students</Inverse>
<Relationship>1</Relationship>
</Property>

<Query name="PaginatedStudents">
<Type>%SQLQuery</Type>
<FormalSpec>offset:%Integer,limit:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>  
  SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN :offset AND :limit</SqlQuery>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.F50C.StudentD</DataLocation>
<DefaultData>StudentDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.F50C.StudentD</IdLocation>
<IndexLocation>^Frontier.UnitTest.F50C.StudentI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.F50C.StudentS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="StudentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Class</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>12.5000%</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Name">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>16.5</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Router">
<Super>Frontier.Router</Super>
<TimeCreated>64503,35090.481271</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
  <Route Url="/route_params/:class" Method="GET" Call="TestGETRouteParams"/>
  <Route Url="/query_params" Method="GET" Call="TestGETOneQueryParameter"/>
  <Route Url="/rest_params" Method="GET" Call="TestGETRestParametersSum"/>
  <Route Url="/sql/dynamic" Method="GET" Call="TestGETDynamicSQLResult"/>
  <Route Url="/sql/query" Method="GET" Call="TestGETQuerySQLResult"/>
  <Route Url="/raw" Method="GET" Call="TestGETRawMode"/>
  <Route Url="/shared_data" Method="GET" Call="TestGETData"/>
  <Route Url="/stream" Method="GET" Call="TestGETStream"/>
  <Route Url="/payload/single_object" Method="POST" Call="TestPOSTObjectPayloadSingle"/>
  <Route Url="/payload/object_with_query_params" Method="POST" Call="TestPOSTObjectPayloadQueryParams"/>  
  <Route Url="/payload/single_array" Method="POST" Call="TestPOSTArrayPayloadSingle"/>
  <Route Url="/payload/array_with_query_params" Method="POST" Call="TestPOSTArrayPayloadQueryParams"/>
  <Route Url="/payload/invalid" Method="POST" Call="TestPOSTInvalidPayload"/>
  <Route Url="/mixed/object" Method="GET" Call="TestGETMixedDynamicObject"/>
  <Route Url="/mixed/array" Method="GET" Call="TestGETMixedDynamicArray"/>
  <Route Url="/mixed/rest" Method="POST" Call="TestPOSTMixedRestParametersSum"/>
 </Routes>
]]></Data>
</XData>

<Method name="OnReceivingData">
<Description>
If you need to share something between methods. You can use this method to populate %frontier.Data.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "Message": "This 'Message' is shared between all methods."
  }
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Description>
Whenever a parameter is typed of %Persistent and a valid id is provided, the parameter will be instantiated.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/route_params/6' 
{"Plate":"O5397","Students":[{"Name":"Drabek,Peter T.","__id__":"20"}],"__id__":"6"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return class
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Description>
Query parameters are also supported. And are fetch if the parameter name matches the URL query name.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/query_params?msg=hello'
{result":"hello"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return "hello"
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Description><![CDATA[
Rest parameters are sequential query parameters. They can have flexible arity and have the format parameterN.
This request takes that number of parameters and sum them.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/rest_params?n1=10&n2=20&n3=30']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n...:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set sum = 0
  for i=1:1:n  set sum = sum + n(i)
  return sum
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Description>
Support of SQL is implemented as well. This example demonstrates how easy it's to create a paginated query.
For SQL, the usage of of Prepare() from frontier.SQL API is required.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows
  
  return %frontier.SQL.Prepare(
    "SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?"
  ).Parameters(offset, limit)
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Description>
Support of SQL is implemented as well. This example demonstrates how easy it's to create a paginated query.
For SQL, the usage of of Prepare() from frontier.SQL API is required.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows
  
  return %frontier.SQL.Prepare("Frontier.UnitTest.Fixtures.Student:PaginatedStudents").Parameters(offset, limit)
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Description>
There can be cases where the response should not be a JSON.
This method shows how to output a text in plain format.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/raw</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  return "hello raw response"
]]></Implementation>
</Method>

<Method name="TestGETData">
<Description>
This method uses the data object provided on OnReceivingData method.
The idea is to demonstrate how to access shared data.
Call example: 
/// curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/shared_data' </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return %frontier.Data
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Description>
Streams can be serialized as well.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  set stream = ##class(%Stream.GlobalCharacter).%New()
  do stream.Write("This line is from a stream.")
  
  return stream
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Description>
If the request is a POST/PUT/PATCH method, it can receive a payload that's represented by a parameter typed of %DynamicObject instances.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/single_object'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Description>
Request can have a payload along with a query parameter.
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/object_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String="",payload:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return {
    "msg": (msg),
    "payload": (payload)
  }
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Description>
Payloads can also be an array.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/single_array'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Description>
Requests with array payloads also support query parameters.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/array_with_query_params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject,msg:%String=""</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (msg), (payload) ]
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Description>
This demonstrates payload validation, as browsers can receive one payload per request
a classmethod that expects more than one is considered invalid and will throw an exception.
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/invalid'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payloadA:%DynamicArray,payloadB:%DynamicObject</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return payloadA
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Description>
Normally %Dynamic instances cannot serialize childrens that aren't dynamic as well. (%ToJSON would thrown an exception).
Frontier fixes it by marshalling irregular to %Dynamic instances beforehand and making it compatible.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/object?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "class": (class)
  }
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Description>
Also supported for %DynamicArray.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/array?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (class) ]
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Description><![CDATA[
It's possible to mix multiple parameter types as you could when calling a method.
The example below illustrates the usage of a method that receives a 'msg' query parameter along with a payload and a rest parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/mixed/rest?n1=10&n2=20&msg=hello']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,data:%DynamicObject,n...:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 
  set parameters = []  
  set sum = 0
  for i=1:1:n  set sum = sum + n(i) do parameters.%Push(n(i))
  return {
    "sum": (sum),
    "data": (data),
    "params": (parameters),
    "msg": (msg)
  }
  return sum
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64503,34684.599157</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Method name="CreateWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set targetNamespace = $namespace
  
  new $namespace  
  set $namespace = "%SYS"
  
  write !, ">> Creating demo web application using namespace "_targetNamespace_" ..."
  if ##class(Security.Applications).Exists(..#NAME) {
    write !, ">> Application already exists, skipping ..."
    return $$$OK
  }
  
  set properties("CookiePath") = ..#NAME
  set properties("DispatchClass") = "Frontier.UnitTest.Router"
  set properties("NameSpace") = targetNamespace
  set properties("UseCookies") = 2
  set properties("AutheEnabled") = 64
  
  $$$QuitOnError(##class(Security.Applications).Create(..#NAME, .properties))
  write !, ">> Application /api/frontier/test has been created."
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  
  if '##class(Security.Applications).Exists(..#NAME) return $$$OK
  write !, ">> Deleting demo web application "_..#NAME_" ..."
  
  $$$QuitOnError(##class(Security.Applications).Delete(..#NAME))
  write !, ">> Web application has been deleted with success."
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="MergeErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec>errors:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  for i=0:1:(errors.%Size() - 1) {
    set errorObject = errors.%Get(i)
    set sc = $$$ADDSC(sc, $$$ERROR(errorObject.code, errorObject.params.%Get(0)))
  }
  
  return sc
]]></Implementation>
</Method>

<Method name="DeepCompare">
<FormalSpec>currentPersistent:%Persistent,currentProxy:JQX.ProxyObject,i=""</FormalSpec>
<Implementation><![CDATA[
  set sc = $$$OK
  
  while currentProxy.Next(.key, .proxyValue) {
    set propertyDescriptor = ##class(%Dictionary.CompiledProperty).%OpenId($classname(currentPersistent)_"||"_key)
    set skipCurrent = 0
    set entityValue = ..GetDeepChildPropertyValue(currentPersistent, $replace(key, "_", "."))
    if $isobject(entityValue) {
      if ##class(JQX.Utils.Descriptor).IsPersistent(propertyDescriptor.RuntimeType) set entityValue = entityValue.%Id()
      if ##class(JQX.Utils.Descriptor).IsStream(propertyDescriptor.RuntimeType) set entityValue = entityValue.Read()
    }
    if $isobject(proxyValue) && $isobject(entityValue) {
      if proxyValue.%Extends("%Collection.AbstractList") {
        if $isobject(proxyValue.GetAt(1)) {        
          for j=1:1:proxyValue.Count() {
            set childEntityObject = entityValue.GetAt(j)
            set childProxyObject = proxyValue.GetAt(j)    
            set sc = ..CompareValues(childEntityObject, childProxyObject, j)
            if $$$ISERR(sc) quit            
          }
        }
      }
    } elseif '$isobject(proxyValue) && '$isobject(entityValue) {
      if proxyValue = "" set proxyValue = "<EMPTY>"
      if entityValue = "" set entityValue = "<EMPTY>"
      if entityValue '= proxyValue {
        set sc = $$$ERROR($$$GeneralError, $$$FormatText("Assertion error: %1property %2, where prox value '= entity value. Mismatch: %3 '= %4", $select(i = "" : i, 1: "index at "_i_", "), key, proxyValue, entityValue))
      }
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="GetDeepChildPropertyValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>parent:%RegisteredObject,composedKey:%String</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
  set nextParent = parent
  set deepestLevel = $length(composedKey, ".")
  for i=1:1:deepestLevel {
    set nextParent = $property(nextParent, $piece(composedKey, ".", i, i))   
  }
  quit nextParent
]]></Implementation>
</Method>

<Method name="MarshallSQLResult">
<ClassMethod>1</ClassMethod>
<FormalSpec>SQLResult:%IResultSet,*dynamicArray:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set dynamicArray = []
  set columnInfo = ""
  
  set columnsCount = SQLResult.%ResultColumnCount
  for c = 1:1:columnsCount {
    set columnInfo(c,"name") = SQLResult.%GetMetadata().columns.GetAt(c).label
  }  
  
  while (SQLResult.%Next(.sc)) {
    quit:$$$ISERR(sc)
    set node = {}
    for c = 1:1:SQLResult.%ResultColumnCount {
      set value = SQLResult.%GetData(c)
        
      if ($isvalidnum(value) && ($e(value) '= 0)) do node.%Set($get(columnInfo(c,"name")),$num(value),"number")
      else  do node.%Set($get(columnInfo(c,"name")),value)
    }
    Do dynamicArray.%Push(node)
  }
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplicationInstaller">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64530,35966.171067</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Projection name="Installer">
<Type>Frontier.UnitTest.WebApplicationInstaller</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).Populate())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).Populate())  
  return ##class(Frontier.UnitTest.Util).CreateWebApplication()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())  
  return ##class(Frontier.UnitTest.Util).RemoveWebApplication()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Router">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64499,42651.978954</TimeCreated>

<Parameter name="TESTSERVER">
<Default>localhost</Default>
</Parameter>

<Parameter name="TESTSERVERPORT">
<Default>57772</Default>
</Parameter>

<Property name="Request">
<Type>%Net.HttpRequest</Type>
</Property>

<Property name="Class">
<Type>Frontier.UnitTest.Fixtures.Class</Type>
</Property>

<Property name="Student">
<Type>Frontier.UnitTest.Fixtures.Student</Type>
</Property>

<Property name="WebApplicationName">
<Type>%String</Type>
<InitialExpression>$e(##class(Frontier.UnitTest.WebApplicationInstaller).#NAME, 2, *)</InitialExpression>
</Property>

<Method name="OnBeforeAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  &sql(SELECT TOP 1 ID INTO :classId FROM FRONTIER_UNITTEST_FIXTURES.CLASS)
  &sql(SELECT TOP 1 ID INTO :studentId FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  
  set ..Class = ##class(Frontier.UnitTest.Fixtures.Class).%OpenId(classId)
  set ..Student = ##class(Frontier.UnitTest.Fixtures.Student).%OpenId(studentId)
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Request = ##class(%Net.HttpRequest).%New()
  do ..Request.SetHeader("Content-Type", "application/json; charset=utf-8")
  set ..Request.Server = ..#TESTSERVER
  set ..Request.Port = ..#TESTSERVERPORT
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertRequest">
<FormalSpec>resource:%String,expected:%DynamicAbstractObject="",method:%String="GET",payload:%DynamicAbstractObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $isobject(payload) {
    $$$QuitOnError(..Request.SetHeader("Content-Type", "application/json; charset=utf-8"))
    $$$QuitOnError(..Request.EntityBody.Write(payload.%ToJSON()))
  }
  
  $$$QuitOnError(..Request.Send(method, resource))
  set response = ..Request.HttpResponse.Data
  set responseText = response.Read()
  set expectedText = expected
  
  set firstByte = $extract(responseText)
  
  if $extract(firstByte)?1(1"{",1"[") {
    set response = ##class(%DynamicObject).%FromJSON(responseText)    
    if $isobject(response) {
      if ##class(Frontier.Types).IsDynamicObject(response) && (response.errors '= ""){        
        return ##class(Frontier.UnitTest.Util).MergeErrors(response.errors)
      } elseif ##class(Frontier.Types).IsDynamic($classname(expected)) {
        $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(expected, .str))
        set expectedText = str.Read()
      }
    }
  }
  
  if responseText '= expectedText {
    return $$$ERROR($$$GeneralError, $$$FormatText("The received content mismatches with the expected one: %1 '= %2", responseText, expectedText))
  }  
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1route_params/%2", ..WebApplicationName, ..Class.%Id())
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .expected)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Implementation><![CDATA[
  set expected = { "result": "hello" }  
  set resource = $$$FormatText("%1query_params?msg=%2", ..WebApplicationName, "hello")
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Implementation><![CDATA[
  set expected = { "result": 60 }
  set resource = $$$FormatText("%1rest_params?n1=10&n2=20&n3=30", ..WebApplicationName)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/rest?n1=10&n2=20&msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"sum":30,"data":{"username":"xyz","password":"xyz"},"params":["10","20"],"msg":"hello"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_object", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/object_with_query_params?msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"msg":"hello","payload":(payload)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single_array", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/array_with_query_params?msg=hello", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = ["hello",(payload)]
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/invalid", ..WebApplicationName)
  set payload = [{"username":"xyz","password":"xyz"}]
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */, "POST", payload), "returns an error if more than one payload is formally expected")
]]></Implementation>
</Method>

<Method name="TestGETInvalidRestSequence">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1rest_params?n1=&n4=10", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if rest argument index is not sequential")
]]></Implementation>
</Method>

<Method name="TestGETUnspecifiedArgument">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1query_params?unknown=1", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if an unknown argument is provided")
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/object?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = {"class":(class)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/array?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).Marshall(..Class, .class)
  set expected = [ (class) ]
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1raw", ..WebApplicationName)
  set expected = "hello raw response"
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1stream", ..WebApplicationName)
  set expected = {"content":"This line is from a stream."}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/dynamic", ..WebApplicationName)
  
  set sd = ##class(%SQL.Statement).%New()
  do sd.%Prepare("SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?")
  set rd = sd.%Execute(1, 5)
  
  do $$$AssertStatusOK(##class(Frontier.UnitTest.Util).MarshallSQLResult(rd, .array), "can read SQL result")
  set expected = {"results":(array)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/query", ..WebApplicationName)
  
  set sd = ##class(%SQL.Statement).%New()
  do sd.%PrepareClassQuery("Frontier.UnitTest.Fixtures.Student", "PaginatedStudents")
  set rd = sd.%Execute(1, 5)
  
  do $$$AssertStatusOK(##class(Frontier.UnitTest.Util).MarshallSQLResult(rd, .array), "can read SQL result")
  set expected = {"results":(array)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="T">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set t = ..%New(##class(Port.UnitTest.Manager).%New())
  do t.OnBeforeAllTests()
  do t.OnBeforeOneTest()
  do t.TestGETQuerySQLResult()
  do t.OnAfterOneTest()
  do t.OnAfterAllTests()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Types">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64502,35612.05458</TimeCreated>

<Method name="TestIsDataType">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%Library.String"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%String"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%ZEN.Datatype.boolean"), "can resolve deep inheritances (custom datatypes)")
]]></Implementation>
</Method>

<Method name="TestIsStream">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.Object"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.GlobalCharacter"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsSerial">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%Library.SerialObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%SerialObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsCollection">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Collection.AbstractIterator"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%ListOfDataTypes"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Library.ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsPersistent">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Library.Persistent"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Persistent"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Dictionary.ClassDefinition"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsInstantiable">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%Library.RegisteredObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%RegisteredObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%ZEN.proxyObject"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamic">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%Library.DynamicAbstractObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicArray"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamicArray">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%Library.DynamicArray"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%DynamicArray"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsDynamicObject">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%Library.DynamicObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%DynamicObject"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsSQLProvider">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSQLProvider("Frontier.SQL.Provider"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("Invalid"), "returns 0 if invalid")
]]></Implementation>
</Method>
</Class>


<Routine name="frontier" type="INC"><![CDATA[
#include %ZEN.Utils

#define ltrim(%str)       $zstrip(%str, "<W")
#define rtrim(%str)       $zstrip(%str, ">W")
#define trim(%str)        $zstrip(%str, "<>W")
#define trimQuote(%str)   $zstrip(%str, "*", $c(34))
#define IsSQLQuery(%str)  ($$$ucase($extract($$$trim(%str), 6)) = "SELECT")
#define KeyGroup(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "=>N")
#define KeyIndex(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "<=A")
]]></Routine>


<Project name="frontier" LastModified="2017-09-08 16:32:47.099205" Target="##class(UnitTest.Frontier.Router).T()" TargetType="2" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="Frontier.ArgumentDescription" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Context" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Marshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Serializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Unmarshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Method" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.DeviceOutputAdapter" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.Provider" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Class" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Student" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.WebApplicationInstaller" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="frontier.INC" type="MAC"></ProjectItem>
  </Items>
</Project>
</Export>
