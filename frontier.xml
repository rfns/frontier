<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Frontier.AbstractSerializer">
<Description>
This class holds the default implementation used to handle device redirection.
You should not use this class but instead its specializations.</Description>
<Abstract>1</Abstract>
<IncludeCode>frontier,%ZEN.Utils</IncludeCode>
<TimeCreated>64553,37866.500056</TimeCreated>

<Method name="SerializeToStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>*str:%Stream.Object="",arguments...</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new oldMnemonic, alreadyRedirected, sc

  set sc = $$$OK
  set isRedirected = 0

  set str = ##class(%Stream.TmpBinary).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
  set initIO = $io

  try {
    use $io::("^"_$zname)

    do ##class(%Device).ReDirectIO(1)
    set isRedirected = 1
    set sc = ..Serialize(arguments...)
    do str.Rewind()
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }

  if oldMnemonic '= "" {
    use initIO::(oldMnemonic)
  } else {
    use oldMnemonic
  }

  do ##class(%Device).ReDirectIO(alreadyRedirected)

  return sc

wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.ArgumentDescription">
<Description>
This holds the metadata used to resolve each argument from the classmethod to be called which generates an response.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>64492,37806.502663</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Alias">
<Type>%String</Type>
</Property>

<Property name="DefaultValue">
<Type>%String</Type>
</Property>

<Property name="HasDefaultValue">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Arity">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<Property name="Index">
<Type>%Integer</Type>
<Required>1</Required>
</Property>
</Class>


<Class name="Frontier.Authentication.BasicStrategy">
<Description>
This strategy provides the implementation for handling clients requests whose authentication
follows the format: Authorization: Basic b64(user:password). This class can be used to demonstrate
how a strategy can be implemented and even augmented. This strategy works as the following:
* If the user doesn't provide an Authorization header, we assume that the client isn't using the Basic
specification and let the request be handle by the next strategy.
* If the user provided an Authorization header, but the value doesn't start with 'Basic', we consider
it as malformed and reply it back to the client as an error.
* If the client didn't provided any authentication, we challenge it using the implemented GetChallenge.</Description>
<IncludeCode>%occErrors,%occStatus,frontier</IncludeCode>
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64553,59181.195484</TimeCreated>

<Property name="Name">
<Description>
This is the name the of the strategy. Can be used to determine that this strategy should be used for a Route exclusively.</Description>
<Type>%String</Type>
<InitialExpression>"Basic"</InitialExpression>
</Property>

<Property name="Realm">
<Description><![CDATA[
This is used by the challenge. Represents the "realm=<value>" from the WWW-Authenticate challenge header.]]></Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Validator">
<Description>
A string whose format should be classname:classmethod, which is used to validate the value from the Authorization header.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Realm = config.realm
  set ..Validator = config.validator
  if config.%IsDefined("name") set ..Name = config.name
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<Description>
Searches for the Authorization header, skips if nothing is found. Otherwise validates the header and the credentials themselves.</Description>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set found = 0
  set httpStatus = ""
  set authHeader = request.GetCgiEnv("HTTP_AUTHORIZATION")

  if authHeader = "" {
    // Let the manager call the next strategy, if that's the last one than the error is
    // fired by the router class.
    return $$$OK
  } elseif authHeader '= "" && ($$$ucase($extract(authHeader, 1, 5)) '= "BASIC") {
    // Specific errors can overwrite the return with something other than $$$OK.
    set sc = $$$ERROR($$$GeneralError, "Malformed authentication header.")
    set response.Status = "400 Bad Request"
  } else {
    set credentials = $System.Encryption.Base64Decode($$$trim($piece(authHeader, " ", 2)))
    set userName = $piece(credentials, ":")
    set password = $piece(credentials, ":", 2)
    set sc = ##class(Frontier.Shared.Utilities).SafeClassMethodCall(..Validator, userName, password, .found, .httpStatus, .user)
    set ..Verified = found
    if $$$ISERR(sc) {
      if httpStatus '= "" set response.Status = httpStatus
      else  set response.Status = "500 Internal Server Error"
    }
  }

  if $$$ISOK(sc) && (found = 0) {
    set sc = $$$ERROR($$$InvalidUsernameOrPassword)
    set response.Status = "403 Forbidden"
  }

  return sc
]]></Implementation>
</Method>

<Method name="GetChallenge">
<Description>
Returns a string that is used to populate the WWW-Authenticate.</Description>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "Basic realm="""_..Realm_""""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.BearerStrategy">
<Description><![CDATA[
This strategy provides the implementation for handling clients requests whose authentication
follows the format: Authorization: Bearer <bearer_token>. There's not much difference with
the Basic version, only that it won't decode the token since a Bearer token is implementation specific.
Which means that the implementer must use the method specified in the 'validator' to decode and validate it.]]></Description>
<IncludeCode>%occErrors,%occStatus,frontier</IncludeCode>
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64553,59181.195484</TimeCreated>

<Property name="Name">
<Description>
This is the name the of the strategy. Can be used to determine that this strategy should be used for a Route exclusively.</Description>
<Type>%String</Type>
<InitialExpression>"Bearer"</InitialExpression>
</Property>

<Property name="Realm">
<Description><![CDATA[
This is used by the challenge. Represents the "realm=<value>" from the WWW-Authenticate challenge header.]]></Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Validator">
<Description>
A string whose format should be classname:classmethod, which is used to validate the value from the Authorization header.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ChallengeScope">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Realm = config.realm
  set ..Validator = config.validator
  if config.%IsDefined("name") set ..Name = config.name
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<Description>
Searches for the Authorization header, skips if nothing is found. Otherwise validates the header and the credentials themselves.</Description>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set found = 0
  set httpStatus = ""
  set authHeader = request.GetCgiEnv("HTTP_AUTHORIZATION")

  if authHeader = "" {
    // Let the manager call the next strategy, if that's the last one than the error is
    // fired by the router class.
    return $$$OK
  } elseif authHeader '= "" && ($$$ucase($extract(authHeader, 1, 6)) '= "BEARER") {
    // Specific errors can overwrite the return with something other than $$$OK.
    set sc = $$$ERROR($$$GeneralError, "Malformed authentication header.")
    set response.Status = "400 Bad Request"
  } else {
    set token = $$$trim($extract(authHeader, 7, *))
    set sc = ##class(Frontier.Shared.Utilities).SafeClassMethodCall(..Validator, token, .found, .httpStatus, .user)
    if 'found  set ..ChallengeScope = $replace(resourceScope, ",", " ")
    set ..Verified = found
    if $$$ISERR(sc) {
      if httpStatus '= "" set response.Status = httpStatus
      else  set response.Status = "500 Internal Server Error"
    }
  }

  if $$$ISOK(sc) && (found = 0) {
    set sc = $$$ERROR($$$InvalidUsernameOrPassword)
    set response.Status = "403 Forbidden"
  }
  
  return sc
]]></Implementation>
</Method>

<Method name="GetChallenge">
<Description>
Returns a string that is used to populate the WWW-Authenticate.</Description>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "Basic realm="""_..Realm_""""
  if ..ChallengeScope '= "" set challenge = challenge_" scope="_..ChallengeScope
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.CookieStrategy">
<Description>
This strategy can be used to validate tokens generated by the utility class
Frontier.Security.CookieSignature. When configuring this strategy, you just need
to provide the same secret used when signing the token.</Description>
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>65029,52410.489996</TimeCreated>

<Property name="Name">
<Description>
The name of the strategy.</Description>
<Type>%String</Type>
<InitialExpression>"Cookie"</InitialExpression>
</Property>

<Property name="Key">
<Description>
The cookie key to search for.</Description>
<Type>%String</Type>
<InitialExpression>"__fc"</InitialExpression>
</Property>

<Property name="Secret">
<Description>
The same secret used to create the signed token.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Validator">
<Description>
A classmethod that is used to validate the token AFTER it was unsigned.
This method is only called when the token has a valid signature.</Description>
<Type>%String</Type>
</Property>

<Property name="Path">
<Description>
The path used to find to which location the cookie should be applied.</Description>
<Type>%String</Type>
<InitialExpression>"/"</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Secret = config.secret
  if config.%IsDefined("name") set ..Name = config.name
  if config.%IsDefined("key") set ..Key = config.key
  if config.%IsDefined("validator") set ..Validator = config.validator
  if config.%IsDefined("path") set ..Path = config.path
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<Description>
Validates if the request contains the cookie, skips the check if the cookie is not present.
Otherwise attempts to unsign the token to obtain the value and pass it down to the Validator method.</Description>
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set failed = 0
  #define ExpireCookie  do response.SetCookie(..Key,"",$zdt("0,0", 2)_" GMT", ..Path)
  #define AssertPropertyDefined(%jp,%ip) if $p($this, %ip) = "" $$$ExpireCookie return $$$ERROR($$$GeneralError, $$$FormatText("Strategy '%1' requires '%1' property to be specified.", ..Name, %jp))

  $$$AssertPropertyDefined("validator", "Validator")
  $$$AssertPropertyDefined("key", "Key")
  $$$AssertPropertyDefined("secret", "Secret")

  if 'request.IsDefinedCookie(..Key) return $$$OK
  set token = request.GetCookie(..Key)
  set payload = ##class(Frontier.Security.CookieSignature).Unsign(token, ..Secret)

  if payload = "" {
    $$$ExpireCookie
    set response.Status = "401 Forbidden"
    return $$$ERROR($$$InvalidUsernameOrPassword)
  }
  
  set found = 0
  set httpStatus = "200 OK"
  set sc = ##class(Frontier.Shared.Utilities).SafeClassMethodCall(..Validator, payload, .found, .httpStatus, .user)
  
  if found = 1 { 
    set ..Verified = 1
  } else{
    if httpStatus '= "" set response.Status = httpStatus
    else  set httpStatus = "401 Forbidden"
  }  
  
  $$$QuitOnError(sc)
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Manager">
<Description>
The Authentication Manager is responsible for running the verification
from each provided strategy. When implementing a strategy you must follow
the specification provided by the Frontier.Authentication.Strategy.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>64553,52230.315441</TimeCreated>

<Property name="Strategies">
<Description>
A list of strategies added that will be executed.</Description>
<Type>Frontier.Authentication.Strategy</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Session">
<Description>
A reference for the %session object.</Description>
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Description>
A reference for the %request object.</Description>
<Type>%CSP.Request</Type>
<Private>1</Private>
</Property>

<Property name="Response">
<Description>
A reference for the %response object.</Description>
<Type>%CSP.Response</Type>
<Private>1</Private>
</Property>

<Property name="ScopeSeparator">
<Description>
If the authenticated user have more than one scope, you can define how each scope must be splitted before the check.</Description>
<Type>%String</Type>
<InitialExpression>" "</InitialExpression>
</Property>

<Property name="Verified">
<Description>
This is an internal flag that signals the routing engine that the client can access the protected resource.
This flag should NOT be set manually.</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  return $$$OK
]]></Implementation>
</Method>

<Method name="ScopeSeparatorSet">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  set i%ScopeSeparator = $get(value, ",")
]]></Implementation>
</Method>

<Method name="AddStrategy">
<Description>
Adds a strategy to the chain. Added strategies will be used to validade against the client's request data.</Description>
<FormalSpec>strategy:Frontier.Authentication.Strategy</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Verified = 0
  $$$QuitOnError(..Strategies.Insert(strategy))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<Description>
Resets the manager into the initial state. If you have a router with an authentication
already configured and a child router that must provide a new authentication chain, you must
call this method before populating the new chain.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Verified = 0
  return ..Strategies.Clear()
]]></Implementation>
</Method>

<Method name="Verify">
<Description>
This method will run each strategy to check if the client comply to any of their requirements.
The Verified flag will be set to 1 if there's any. Otherwise an error will be thrown informing that the client is not authenticated.
If a strategy implements the method GetChallenge, this method will be called if the client didn't provided any credentials that match any strategies in the chain.
Note that the GetChallenge will be executed only if the current strategy is the last one.</Description>
<FormalSpec>*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set totalStrategies = ..Strategies.Count()
  set strategy = ""

  try {
    for i=1:1:totalStrategies {
      set strategy = ..Strategies.GetAt(i)
      if 'strategy.%Extends("Frontier.Authentication.Strategy") continue
      set sc = strategy.Verify(..Session, ..Request, ..Response, .user, resourceScope)
      if $$$ISERR(sc) return sc

      set ..Verified = strategy.Verified

      if ..Verified = 1 {
        return $$$OK
      } elseif i < totalStrategies {
        continue
      } elseif $$$ISOK(sc) {
        do ..SetChallenge(strategy)
      }
    }
  } catch ex {
    set sc = ex.AsStatus()
  }

  return sc
]]></Implementation>
</Method>

<Method name="VerifyUsing">
<Description>
If the Route contains an AuthStrategy property, the named strategy provided there will be the only one called.
In this case the client must always comply with that strategy.</Description>
<FormalSpec>namedStrategy:%String,*user,resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Verified = 0
  set sc = $$$OK
  set found = 0

  for i=1:1:..Strategies.Count() {
    set strategy = ..Strategies.GetAt(i)
    if strategy.Name = namedStrategy {
      set found = 1
      try {
        set sc = strategy.Verify(..Session, ..Request, ..Response, .user, resourceScope)
        if $$$ISERR(sc) return sc

        set ..Verified = strategy.Verified

        if ..Verified = 1 {
          return $$$OK
        } elseif $$$ISOK(sc) {
          do ..SetChallenge(strategy)
          return sc
        }
      } catch ex {
        set sc = ex.AsStatus()
      }
    }
  }

  if 'found {
    return $$$ERROR($$$GeneralError, $$$FormatText("Strategy '%1' was not defined.", namedStrategy))
  }
  return sc
]]></Implementation>
</Method>

<Method name="CheckResourceScope">
<Description>
This is an internal method used by the routing engine to check if any of the user's scope complies to the one provided
in the Route element's Scope property.</Description>
<Internal>1</Internal>
<FormalSpec>resourceScope:%String="",authenticationScope:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if resourceScope [ " " {    
    set resourceScope = $lfs(resourceScope, " ")
    set isMatch = 0    
    
    for i=1:1:$ll(resourceScope) {      
      set oneScope = $zstrip($lg(resourceScope, i), "<>W")
      set modifier = $extract(oneScope, 1)
      if $extract(modifier)?1AN = 1 set modifier = "+"
      
      if modifier = "-" set mustMatch = 0
      else  set mustMatch = 1
      
      set oneScope = $translate(oneScope, "+-", "")
      set isMatch = ..CheckResourceScope(oneScope, authenticationScope)
      if mustMatch && 'isMatch { return 0 }
      elseif 'mustMatch && isMatch { return 0 }
    }
    return 1
  }
  if resourceScope '= "" return $lf($lfs(authenticationScope, ..ScopeSeparator), resourceScope) > 0
  return 1
]]></Implementation>
</Method>

<Method name="SetChallenge">
<Description>
An internal method that will be used to set the client challenge.</Description>
<FormalSpec>strategy:Frontier.Authentication.Strategy</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  set sc = strategy.GetChallenge(..Session, ..Request, ..Response, .challenge)
  if challenge '= "" do ..Response.SetHeader("WWW-Authenticate", challenge)
  $$$ThrowOnError(sc)
]]></Implementation>
</Method>

<Method name="HasStrategies">
<Description>
Returns if there's any strategies added.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..Strategies.Count() > 0
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Authentication.Strategy">
<Description>
This class is the backbone required to implement an strategy.
The implementation must follow the specification below:
****
1 - The new strategy must inherit from this class.
****
2 - The method %OnNew must receive a %DynamicObject to populate the new strategy's properties.
/****
3 - The Verify method must be used to validate both: the strategy configuration and the request.
****
4 - The strategy must always check if the client provided sufficient data
to run the validation, if it didn't, the strategy MUST return $$$OK. This will
make the manager skips to the next strategy in the chain.
****
5 - If the user provided enough data and the validation succeeded, then the strategy
must set the Verified flag to 1. This will make the manager bail out without running
the remaining strategies, thus allowing the client to access the protected resource.
****
6 - If the user provided enough data but the validation failed, the strategy must return
an $$$ERROR. This will also make the manager bail out the strategy chain but the error emitted by
the current strategy will be display. Additionally, the strategies can also provide a challenge
by implementing the method GetChallenge and/or set an adequate HTTP Status Code, by using the response.Status property.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>64553,51285.209032</TimeCreated>

<Property name="Realm">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Verified">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ThrowStatus($$$ERROR($$$MethodNotImplemented, "%OnNew"))
  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.CORS">
<Description>
The Frontier CORS API
Use this API to define a set of CORS rules that allow or deny access to the
protected resource if the origin is extraneous.</Description>
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64862,59420.301475</TimeCreated>

<Property name="Context">
<Description>
The %frontier context.</Description>
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Property name="VaryHeaders">
<Description>
The header names to be added in the Vary header.</Description>
<Private>1</Private>
</Property>

<Property name="AllowedOrigin">
<Description>
A single origin resolved from the incoming request and list of allowed origins.
If this is empty, then the request will fail.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AllowedMethods">
<Description>
If the request is made using a HTTP method that is not in this list, the request will fail.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AllowedCredentials">
<Description>
If this value is not set to true and the request contains Authorization, the request will fail.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AllowedHeaders">
<Description>
Any headers that aren't in this list will make the request fail.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AllowedAge">
<Description>
How long the preflight request can be cached.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ExposedHeaders">
<Description>
What the response can expose.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="OriginVerifier">
<Description>
A string containing the class:method which is used to filter which origins should be allowed.</Description>
<Type>%String</Type>
<InitialExpression>"Frontier.CORS:IsOriginAllowed"</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsActive">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if i%VaryHeaders '= "" return 1
  if i%AllowedOrigin '= "" return 1
  if i%AllowedMethods '= "" return 1
  if i%AllowedCredentials '= "" return 1
  if i%AllowedHeaders '= "" return 1
  if i%AllowedAge '= "" return 1
  if i%ExposedHeaders '= "" return 1
  return 0
]]></Implementation>
</Method>

<Method name="AllowOrigin">
<Description>
Defines a set of origins allowed to access this protected resource.
If more than one is provided, then it will use the classmethod from OriginVerifier to validated each entry against the request origin.
If no origin is provided, then it will match against the request origin making it unrestricted.
If only one origin is provided, than the request origin will be matched against it and fail the request if it differs.</Description>
<FormalSpec>origins...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(origins) set origins = 0

  if origins = 0 {
    set ..AllowedOrigin = ..Context.Request.GetCgiEnv("HTTP_ORIGIN")
  } elseif origins = 1 {
    set ..AllowedOrigin = origins(1)
  } elseif origins > 2 {
    for i=1:1:origins {
      if ..TestOrigin(origins(i)) {
        set ..AllowedOrigin = origins(i) quit
      }
    }
  }
]]></Implementation>
</Method>

<Method name="AllowMethods">
<Description>
Specify which HTTP methods the request can use when accessing this protected resource.
Each method will be used against the request's method. If none match, the request will fail.</Description>
<FormalSpec>methods...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(methods) set methods = 0
  set ..AllowedMethods = ..makeList(methods...)
]]></Implementation>
</Method>

<Method name="AllowHeaders">
<Description>
Specify a list of headers that the request can be sent with, any header sent that is not present in this list
will cause the request to fail.</Description>
<FormalSpec>headers...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(headers) set headers = 0
  set ..AllowedHeaders = ..makeList(headers...)
]]></Implementation>
</Method>

<Method name="AllowCredentials">
<Description>
Specify if the request include credential related headers. Otherwise the request will fail.</Description>
<FormalSpec>enabled:%Boolean=0</FormalSpec>
<Implementation><![CDATA[  set ..AllowedCredentials = $$$FormatBoolean(enabled)
]]></Implementation>
</Method>

<Method name="ExposeHeaders">
<Description>
Specify a list of response headers that the client can read.</Description>
<FormalSpec>headers...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(headers) set headers = 0
  set ..ExposedHeaders = ..makeList(headers)
]]></Implementation>
</Method>

<Method name="makeList">
<FormalSpec>args...:%String</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
  set list = ""

  for i=1:1:args {
    set $list(list, *+1) = args(i)
  }

  return $lts(list, ", ")
]]></Implementation>
</Method>

<Method name="Default">
<Description>
Provides full resouce access to the specified origins otherwise assume any origin can access it.</Description>
<FormalSpec>origins...:%String</FormalSpec>
<Implementation><![CDATA[
  do ..AllowOrigin(origins...)
  do ..AllowCredentials(1)
  do ..AllowMethods("GET", "POST", "PUT", "DELETE", "HEAD")
  do ..AllowHeaders("Authorization", "Content-Type")
  do ..AllowCredentials(1)
]]></Implementation>
</Method>

<Method name="Vary">
<Description>
Sets the list of Vary headers.</Description>
<FormalSpec>varyHeaders...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(varyHeaders) set varyHeaders = 0
  do ..Context.Response.SetHeader("Vary", ..makeList(varyHeaders...))
]]></Implementation>
</Method>

<Method name="CheckPreflight">
<Internal>1</Internal>
<Implementation><![CDATA[
  if '..IsActive() quit
  do ..SetHeaderIfProvided("Vary", "Origin")
  do ..SetHeaderIfProvided("Vary", "Access-Control-Request-Headers")
  do ..SetHeaderIfProvided("Access-Control-Allow-Origin", ..AllowedOrigin)
  do ..SetHeaderIfProvided("Access-Control-Allow-Methods", ..AllowedMethods)
  do ..SetHeaderIfProvided("Access-Control-Allow-Headers", ..AllowedHeaders)
  do ..SetHeaderIfProvided("Access-Control-Allow-Credentials", ..AllowedCredentials)
  do ..SetHeaderIfProvided("Access-Control-Expose-Headers", ..ExposedHeaders)
  do ..SetHeaderIfProvided("Access-Control-Max-Age", ..AllowedAge)
  do ..Context.Response.DeleteHeader("Content-Type")
  set ..Context.Response.ContentLength = 0
  set ..Context.Response.ContentType = ""
]]></Implementation>
</Method>

<Method name="Set">
<Internal>1</Internal>
<Implementation><![CDATA[
  if '..IsActive() quit
  do ..SetHeaderIfProvided("Vary", "Origin")
  do ..SetHeaderIfProvided("Access-Control-Allow-Origin", ..AllowedOrigin)
  do ..SetHeaderIfProvided("Access-Control-Allow-Credentials", ..AllowedCredentials)
]]></Implementation>
</Method>

<Method name="Unset">
<Description>
Use this method to undo CORS configuration. Can be used if you need to ovewrite
the parent router with a children configuration.</Description>
<Implementation><![CDATA[
  do ..Context.Response.DeleteHeader("Vary")
  do ..Context.Response.DeleteHeader("Access-Control-Allow-Origin")
  do ..Context.Response.DeleteHeader("Access-Control-Allow-Methods")
  do ..Context.Response.DeleteHeader("Access-Control-Allow-Headers")
  do ..Context.Response.DeleteHeader("Access-Control-Allow-Credentials")
]]></Implementation>
</Method>

<Method name="SetHeaderIfProvided">
<FormalSpec>header:%String,value:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[  if value '= "" do ..Context.Response.SetHeader(header, value)
]]></Implementation>
</Method>

<Method name="IsOriginAllowed">
<FormalSpec>allowedOrigin:%String,requestUrl:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return allowedOrigin = requestUrl
]]></Implementation>
</Method>

<Method name="TestOrigin">
<FormalSpec>origin:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set isAllowed = 0
  set className = $piece(..OriginVerifier, ":")
  set methodName = $piece(..OriginVerifier, ":", 2)

  try {
    set isAllowed = $classmethod(className, methodName, origin, ..Context.Request.URL)
  } catch ex { }

  return isAllowed
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Context">
<Description>
When instantiated, this class provides a set of features that can be used
to configure how Frontier behaves when handling the requests. Usually represented
by the public %frontier variable, which is always available inside a router class.</Description>
<IncludeCode>%occErrors,%occStatus</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,31617.993909</TimeCreated>

<Parameter name="VERSION">
<Default>5.0.0</Default>
</Parameter>

<Property name="Session">
<Description>
This holds the reference for the %session object.</Description>
<Type>%CSP.Session</Type>
<Private>1</Private>
</Property>

<Property name="Request">
<Description>
This holds the reference for the %request object.</Description>
<Type>%CSP.Request</Type>
</Property>

<Property name="Response">
<Description>
This holds the reference for the %response object.</Description>
<Type>%CSP.Response</Type>
</Property>

<Property name="RequestURL">
<Description>
The URL that matched the route.</Description>
<Type>%String</Type>
</Property>

<Property name="Method">
<Description>
The last method called in the current request.</Description>
<Type>%String</Type>
</Property>

<Property name="ClassName">
<Description>
The dispatcher class that will reply the request.</Description>
<Type>%String</Type>
</Property>

<Property name="ArgumentValues">
<Description>
A list of resolved arguments built by the Frontier.Method class.</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Stack">
<Description>
The current stack that is used by reporters to display the error.</Description>
<Type>%Stream.GlobalCharacter</Type>
<Internal>1</Internal>
</Property>

<Property name="IncludeStack">
<Description>
An internal flag that signals when to include stack info with the error.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Exception">
<Description>
The exception data that will be passed to the reporter.</Description>
<Type>Frontier.Exception</Type>
<Internal>1</Internal>
</Property>

<Property name="SQL">
<Description>
This Frontier SQL API, a minimalist API used to quickly retrieve SQL results.</Description>
<Type>Frontier.SQL</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ReporterManager">
<Description>
The Reporter API, which is used to handle and report errors.</Description>
<Type>Frontier.Reporter.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="AuthenticationManager">
<Description>
The Authentication API, which is used to define a set of strategies and configure them.</Description>
<Type>Frontier.Authentication.Manager</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Files">
<Description>
The Files API, which allows the handling of file uploads and serving files/directories as well.</Description>
<Type>Frontier.Files</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Data">
<Description>
The object populated by the method OnDataSet which is called before each request.</Description>
<Type>%DynamicObject</Type>
</Property>

<Property name="DirectWrite">
<Description>
DEPRECATED: use %frontier.Modifiers.DIRECTWRITE instead.
This flag indicates if the response should be rewritten to the response stream buffer or write directly.
Keep this flag set to 0 to prevent errors from corrupting the output, set it to 1 if you need performance
and your code is secure enough to not error while writing to the device.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="User">
<Description>
This holds all the properties defined by the elected strategy.</Description>
<Type>%DynamicObject</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PropertyFormatter">
<Description>
This allows to provide a custom property formatter for JSON.</Description>
<Type>Frontier.PropertyFormatter</Type>
</Property>

<Property name="StrictQueryParameters">
<Description>
By default Frontier won't allow the usage of query parameters that aren't arguments from the classmethod that will be called.
Setting this flag to 0 will disable this check.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="RouteParameters">
<Description>
This is plain text version from the route parameters. It's useful when its equivalent argument resolved to an object due to its type.
Each route parameters is keyed by its name.</Description>
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Matches">
<Description>
When the Route element has Strict=false, this property will be populated with the set of regular expression matching groups.</Description>
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="RawMode">
<Description>
By default, everything Frontier outputs is formatted to JSON. This internal flag informs the routing engine to display the result as plain text.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Encoding">
<Description>
Represents the response charset.</Description>
<Type>%String</Type>
<InitialExpression>"utf-8"</InitialExpression>
</Property>

<Property name="CORS">
<Description>
The CORS API, which handles the access from extraneous servers.</Description>
<Type>Frontier.CORS</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Route">
<Description>
A string that holds the Route element's Url expression. Can be used to identified which route as been called.</Description>
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = session
  set ..Request = request
  set ..Response = response
  set i%SQL = ##class(Frontier.SQL).%New()
  set i%ReporterManager = ##class(Frontier.Reporter.Manager).%New($this)
  set i%AuthenticationManager = ##class(Frontier.Authentication.Manager).%New(..Session, ..Request, ..Response)
  set i%Files = ##class(Frontier.Files).%New($this)
  set i%CORS = ##class(Frontier.CORS).%New($this)
  set i%ArgumentValues = 0
  set ..Data = {}
  set ..Response.ContentType = "application/json"
  return $$$OK
]]></Implementation>
</Method>

<Method name="Raw">
<Description>
Disables the JSON output, making the response to be sent in plain text.
The Content-Type header is overwritten to 'text/plain'.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..RawMode = 1
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsRaw">
<Description>
Returns if the Raw mode is enabled.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return (..RawMode = 1)
]]></Implementation>
</Method>

<Method name="HTML">
<Description>
This is almost the same than the Raw method.
But instead the Content-Type will be overwritten to 'text/html'.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..RawMode = 1
  do ..Response.SetHeader("Content-Type", "text/html")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsHTML">
<Description>
Returns if the HTML method has been called.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return (..RawMode = 1 && ($$$lcase(..Response.ContentType) = "text/html"))
]]></Implementation>
</Method>

<Method name="JSON">
<Description>
Restores Frontier making it use JSON.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..RawMode = 0
  do ..Response.SetHeader("Content-Type", "application/json")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsJSON">
<Description>
Returns if Frontier will be sending JSON.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return (..RawMode = 0 && ($$$lcase(..Response.ContentType) = "application/json"))
]]></Implementation>
</Method>

<Method name="Status">
<Description>
Sets the status that will be sent with the response.</Description>
<FormalSpec>statusCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Response.Status = statusCode
  return $$$OK
]]></Implementation>
</Method>

<Method name="ThrowException">
<Description>
Throws an application controlled error, such errors won't cause the Reporter API to be fired.</Description>
<FormalSpec>message:%String,httpStatus:%String="500 Internal Server Error",parameters...:%String</FormalSpec>
<Implementation><![CDATA[
  if '$data(parameters) set parameters = 0
  set args = 2 + parameters
  set args(1) = $$$GeneralError
  set args(2) = message

  set ..Response.Status = httpStatus

  for i=1:1:parameters set args(2+i) = parameters(i)
  throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(args...))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Marshaller">
<Description>
This class provides an API used to transform an object into a %DynamicAbstractObject, which can be either a %DynamicObject or a %DynamicArray.
This is used internally by Frontier, but it might also be used manually by calling the method Marshal.
By default while marshalling an object, this engine will attempt to build a dynamic instance while preventing cyclic references.
However since this can be ineffective for most of the cases. So if you want more control, you can also define until which depth the marshalling should be made.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,32993.705412</TimeCreated>

<Property name="Properties">
<Description>
Contains a list of properties that should be contained in the marshalled object.</Description>
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="Depth">
<Description>
This is a internal counter indicating the current object depth.</Description>
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<Property name="DescriptorsCache">
<Description>
Contains a list of class descriptors. This is used to prevent roundtrips thus improving the performance.</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="PropertiesCache">
<Description>
Contains a list of property descriptors. Same reason as DescriptorsCache.</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="JSONDataFormatsCache">
<Description>
Contains a list of JSON property types. Also to prevent roundtrips.</Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="MaxDepth">
<Description>
Holds a positive integer value that specifies the maximum depth the marshalling process can reach.</Description>
<Type>%Integer</Type>
<InitialExpression>7</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Path">
<Description>
A string that represents the path from concatenated property names, used to filter which properties to include.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Object">
<Type>%RegisteredObject</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>maxDepth:%Integer=7,properties:%String="",object:%RegisteredObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  if maxDepth < 0 set maxDepth = 7
  set ..Properties = ..SpreadProperties(properties)  
  set ..MaxDepth = maxDepth
  set ..Object = object
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="MarshalDirect">
<Description>
Marshals the provided 'object' into a dynamic instance that is ready to be serialized.
This method returns an error if it fails, otherwise the 'dynamicObject' is populated.
The parameter 'properties' can be used to define which properties the instance should contain.
The parameter 'maxDepth' if specified will be used in the place of the default cyclic references check.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicAbstractObject,properties:%String="",maxDepth:%Integer=7</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New(maxDepth, properties, object)
  return marshaller.Marshal(.dynamicObject)
]]></Implementation>
</Method>

<Method name="Marshal">
<Description>
Marshals the current object into a Dynamic qualified instance.
This method uses the configuration provided from %New which includes an optional object overwrite to be marshalled.</Description>
<Internal>1</Internal>
<FormalSpec>*dynamicObject:%DynamicAbstractObject,object:%RegisteredObject=..Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  if '$isobject(object) {
    return $$$ERROR($$$GeneralError, "Object to marshal was not provided.")
  }  
  
  set i%DescriptorsCache = ""
  set i%PropertiesCache = ""
  set i%JSONDataFormatsCache = ""  
  
  set type = $classname(object)      
  if ##class(Frontier.Types).IsCollection(type) return ..MakeDynamicCollection(object, .dynamicObject)
  if ##class(Frontier.Types).IsDynamic(type) return ..Traverse(object, .dynamicObject)
  if ##class(Frontier.Types).IsInstantiable(type) return ..MakeDynamicObject(object, .dynamicObject) 
  
  return $$$ERROR($$$GeneralError, "Invalid object type to marshal: class must extend from %RegisteredObject.")
]]></Implementation>
</Method>

<Method name="SpreadProperties">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set props = ""
  set value = $lfs(value)
  
  for i=1:1:$ll(value) {
    set property = $lg(value, i)
    if '$lf(props, property) set $list(props, *+1) = property
    if property [ "." {
      for ii=$length(property, "."):-1:1 {
        set part = $piece(property, ".", 1, ii)
        if $lf(props, part) || (part = "*") continue
        set $list(props, *+1) = part 
      }
    }
  }
  
  return props
]]></Implementation>
</Method>

<Method name="SetValue">
<Internal>1</Internal>
<FormalSpec>target,key,value,type=""</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if ..IsTooDeep() quit

  if type '= "" {
    do target.%Set(key, value, type)
  } else {
    do target.%Set(key, value)
  }
]]></Implementation>
</Method>

<Method name="IsTooDeep">
<Internal>1</Internal>
<FormalSpec>depth:%Integer=..Depth</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if ..MaxDepth '= "" && (depth > ..MaxDepth) return 1
  return 0
]]></Implementation>
</Method>

<Method name="UpdatePath">
<Internal>1</Internal>
<FormalSpec>pathComponent:%String=""</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if pathComponent '="" {
    if i%Path '= "" set $piece(i%Path, ".", *+1) = pathComponent
    else  set i%Path = pathComponent
  } else {
    set ..Path = $piece(..Path, ".", 1, *-1)
  }
]]></Implementation>
</Method>

<Method name="Traverse">
<Internal>1</Internal>
<FormalSpec>dynamicInstance:%DynamicAbstractObject,marshalledObject:%DynamicAbstractObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  set iterator = dynamicInstance.%GetIterator()
  set marshalledObject = dynamicInstance

  if '$isobject(dynamicInstance) {
    set marshalledObject = $System.OBJ.New($classname(dynamicInstance))
  }

  set dynamicValueResult = ""

  while iterator.%GetNext(.key, .value) {
    set dynamicValueResult = value
    if $isobject(value) {
      set valueType = $classname(value)
      set isDynamic = ##class(Frontier.Types).IsDynamic(valueType)
      set isCollection = ##class(Frontier.Types).IsCollection(valueType)
      set isStream = ##class(Frontier.Types).IsStream(valueType)
      set isSQLProvider = ##class(Frontier.Types).IsSQLProvider(valueType)
      if isDynamic {
        set sc = ..Traverse(value, .dynamicValueResult)
      } elseif isCollection {
        set sc = ..MarshalCollection(value, .dynamicValueResult)
      } elseif 'isStream && 'isSQLProvider {
        set sc = ..MakeDynamicObject(value, .dynamicValueResult)
      }
      do ..SetValue(marshalledObject, key, dynamicValueResult)
      if $$$ISERR(sc) return sc
    }
  }
  return sc
]]></Implementation>
</Method>

<Method name="MarshalCollection">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%RegisteredObject,*dynamicCollection:%DynamicObject,properties:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set marshaller = ..%New()
  set marshaller.Properties = properties
  return marshaller.MakeDynamicCollection(collection, .dynamicCollection)
]]></Implementation>
</Method>

<Method name="BuildPropertiesList">
<Internal>1</Internal>
<FormalSpec>classDescriptor:%Dictionary.CompiledClass,*properties:%AbstractList=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $lv(..Properties) && (..Properties '= "") {
    set properties = ##class(%ListOfObjects).%New()
    
    while ..NextSerializableProperty(classDescriptor.Properties, .property, .index) {
      set path = property.Name
      if ..Path '= "" set path = ..Path_"."_property.Name
      
      if $lf(..Properties, path) || $lf(..Properties, ..Path_".*") {
        set sc = properties.Insert(property)
        if $$$ISERR(sc) return sc
      }    
    } 
  } else {
    set properties = classDescriptor.Properties
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="NextSerializableProperty">
<Internal>1</Internal>
<FormalSpec><![CDATA[properties:%ListOfObjects,&property:%Dictionary.CompiledProperty="",&index:%Integer=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[

  while 1 {
    set property = properties.GetAt(index)
    if property = "" return 0

    set index = index + 1
    if property.MultiDimensional || property.Private || property.Internal || ($extract(property.Name) = "%") {
      continue
    } else {
      return 1
    }
  }
]]></Implementation>
</Method>

<Method name="MakeChildObject">
<Internal>1</Internal>
<FormalSpec>object:%RegisteredObject,child:%RegisteredObject,*bailOut:%Boolean=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[

  set sc = $$$OK
  
  if object.%Extends("%Stream.Object") {
    set child = $System.OBJ.New($classname(object))
    set sc = child.CopyFrom(object)
    if $$$ISERR(sc) quit
  } elseif object.%Extends("%Collection.AbstractIterator") {    
    set sc = ..MakeDynamicCollection(object, .child, .bailOut)
  } else {
    set sc = ..MakeDynamicObject(object, .child,  .bailOut)
  }  
  return sc
]]></Implementation>
</Method>

<Method name="GetExternalValue">
<Internal>1</Internal>
<FormalSpec>object:%RegisteredObject,propertyName:%String,propertyType:%String,internalValue:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if ##class(%Dictionary.CompiledMethod).%ExistsId(propertyType_"||LogicalToDisplay") {
    return $method(object, propertyName_"LogicalToDisplay", internalValue)
  }
  return ""
]]></Implementation>
</Method>

<Method name="MakeDynamicObject">
<FormalSpec>object:%RegisteredObject,*dynamicObject:%DynamicObject="",*bailOut:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  if ..IsTooDeep(..Depth + 1) set bailOut = 1 return $$$OK
  set dynamicObject = {}

  set ..Depth = ..Depth + 1

  set classname = $classname(object)
  set skip = 0
  
  $$$QuitOnError(..GetProperties(classname, .properties))

  while ..NextSerializableProperty(properties, .property, .index) {
    do ..UpdatePath(property.Name)
    
    set skip = 0
    set value = $property(object, property.Name)
    set jsonDataFormat = ..GetJSONDataFormat(property.Type)
    set isCollection = property.Collection '= ""
    if isCollection || ##class(Frontier.Types).IsInstantiable(property.Type) {
      set child = ""
      if '$isobject(value) do dynamicObject.%Set(property.Name, "", "null") continue
      else  set sc = ..MakeChildObject(value, .child, .skip)
      if skip = 1 continue
      if $$$ISERR(sc) {
        quit
      } elseif child = "" && (value '= "") {
        if ##class(Frontier.Types).IsPersistent($classname(value)) {
          do ..SetValue(dynamicObject, property.Name, "", "null")
        } elseif '##class(Frontier.Types).IsSerial($classname(value)) {
          do ..SetValue(dynamicObject, property.Name, "", "null")
        }
      } else {
        do ..SetValue(dynamicObject, property.Name, child)
      }
    } elseif '(property.Type = "%Boolean" || (property.Type = "%Library.Boolean")) {
      do ..SetValue(dynamicObject, property.Name, value)
      if value = "" continue
      set external = ..GetExternalValue(object, property.Name, property.Type, value)
      if value '= external do ..SetValue(dynamicObject, property.Name_"__x", external)
    } else {
      do ..SetValue(dynamicObject, property.Name, value, "boolean")
    }
    
    do ..UpdatePath("")
  }

  if object.%Extends("%Persistent") && 'skip {
    if $lf(..Properties, "__id__") || (..Properties = "") {
      set id = object.%Id()
      if id '= "" set $property(dynamicObject, "__id__") = object.%Id()
    }
  }  
  
  set ..Depth = ..Depth - 1 
  if dynamicObject.%Size() = 0 {
    set bailOut = 1
    set dynamicObject = ""
  }
  quit sc
]]></Implementation>
</Method>

<Method name="MakeDynamicCollection">
<FormalSpec>collection:%Collection.Super,*dynamicCollection:%String,*bailOut:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  set sc = $$$OK
  set startOffset = 0
  
  set elementType = collection.ElementType
  if elementType [ ":" set elementType = $piece(elementType, ":")
  set expectingObject = ##class(Frontier.Types).IsInstantiable(collection.ElementType)
  
  if collection.%Extends("%Collection.AbstractIterator") {
    set startOffset = 1
    set dynamicCollection = []
  } else {
    set dynamicCollection = {}
  } 
   
  set shouldAdvanceDepth = (expectingObject && startOffset = 1)
  
  if shouldAdvanceDepth && ..IsTooDeep(..Depth + 2) set bailOut = 1 return $$$OK 
  if 'shouldAdvanceDepth && ..IsTooDeep(..Depth + 1) set bailOut = 1 return $$$OK   
  
  set ..Depth = ..Depth + 1

  set key = ""
  set item = collection.GetNext(.key)

  while key {
    set skip = 0
    if $isobject(item) {
      if item.%IsA("%Collection.AbstractIterator") {
        set sc = ..MakeDynamicCollection(item, .value, .skip)
      } else {
        set sc = ..MakeDynamicObject(item, .value, .skip)
      }
    } else {      
      if expectingObject set item = "null"
      set value = item
    }

    if 'skip do ..SetValue(dynamicCollection, key - startOffset, value)
    if $$$ISERR(sc) quit

    set item = collection.GetNext(.key)
  }
  
  set ..Depth = ..Depth - 1
  
  if dynamicCollection.%Size() '= collection.Count() {
    set bailOut = 1
    set dynamicCollection = ""
  }  
  
  quit sc
]]></Implementation>
</Method>

<Method name="GetDescriptor">
<Internal>1</Internal>
<FormalSpec>classname:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set descriptor = $get(i%DescriptorsCache(classname))
  if descriptor = "" {
    set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(classname)
    set i%DescriptorsCache(classname) = descriptor
  }

  return descriptor
]]></Implementation>
</Method>

<Method name="GetProperties">
<Internal>1</Internal>
<FormalSpec>classname:%String,*properties:%Collection.AbstractList=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set properties = ..GetPropertiesListFromCache(classname)
  if $isobject(properties) return $$$OK  

  set descriptor = ..GetDescriptor(classname)

  $$$QuitOnError(..BuildPropertiesList(descriptor, .properties))
  do ..CachePropertiesList(classname, properties)

  return $$$OK
]]></Implementation>
</Method>

<Method name="GetPropertiesListFromCache">
<Internal>1</Internal>
<FormalSpec>className:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Dictionary.CompiledProperty</ReturnType>
<Implementation><![CDATA[
  if ..Properties '= "" return ""
  set properties = $get(i%PropertiesCache(className))
  
  if properties '= "" return properties
  return ""
]]></Implementation>
</Method>

<Method name="CachePropertiesList">
<Internal>1</Internal>
<FormalSpec>classname:%String,properties:%ListOfObjects</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if ..Properties '= "" quit
  set i%PropertiesCache(classname) = properties
]]></Implementation>
</Method>

<Method name="GetJSONDataFormat">
<Internal>1</Internal>
<FormalSpec>propertyType:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set format = $get(i%JSONDataFormatsCache(propertyType))
  if format = "" {
    set format = ##class(Frontier.Types).GetJSONDataFormat(propertyType)
    set i%JSONDataFormatsCache(propertyType) = format
  }

  return format
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Serializer">
<Description>
This class is basically an overwrite for the %ToJSON method, because Frontier needs features
that allows the mixed serialization of SQL providers and streams.
Note: As of the Cach 2019 version, the support for serializing streams have been introduced,
however since Frontier targets the 2017 onwards, this class is still required.</Description>
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64531,58689.528672</TimeCreated>

<Method name="Serialize">
<Description>
Takes an %DynamicAbstractObject and serializes it while writing back to the current device.
This method is not supposed to be used manually.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>dynamic:%DynamicAbstractObject,depth:%String=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set results = ""
  set isArray = ##class(Frontier.Types).IsDynamicArray($classname(dynamic))

  if isArray {
    write "["
  } else {
    write "{"
  }

  set iterator = dynamic.%GetIterator()
  set comma = ""

  while iterator.%GetNext(.key, .value) {
    write comma
    set comma = ","
    set propertyName = key
    set type = dynamic.%GetTypeOf(key)

    if $isobject(propertyFormatter) {
      set propertyName = propertyFormatter.Format(propertyName, depth)
    }

    if 'isArray {
      write $$$ZENJSONPROP(propertyName, "s")_":"
    }    

    if value = "null" || (type = "null" && (value = "")) {
      write "null"
    } elseif type = "boolean" || (value?1(1"true",1"false") = 1) {
      write $$$FormatBoolean(value)
    } elseif $isobject(value) {
      set type = $classname(value)
      if ##class(Frontier.Types).IsDynamic(type) {
        set sc = $$$ADDSC(sc, ..Serialize(value, depth, propertyFormatter))
      } elseif ##class(Frontier.Types).IsStream(type) {
        write $c(34)
        do WriteEscaped(value)
        write $c(34)
      } elseif ##class(Frontier.Types).IsSQLProvider(type) {
        if 'value.StatementExecuted set sc = value.Execute()
        if $$$ISERR(sc) quit
        $$$ThrowOnError(##class(Frontier.SQL.Serializer).Serialize(value.Results, value.Metadata, depth, propertyFormatter))
      }
    } elseif type = "string" {
      write $$$ZENJSONSTR(value, "s")
    } elseif type = "number" {
      write $$$ZENJSNUM(value)
    } else {
      write $$$ZENJSONVALUE(value, "s")
    }
  }

  $$$QuitOnError(sc)

  if isArray write "]"
  else  write "}"

  return sc

WriteEscaped(v)
  set readCount = 0
  do v.Rewind()

  // Instead of using AtEnd, we compare the stream size with the buffer read size.
  // We use it this way, because apparently AtEnd doesn't track the position correctly when the device is redirected.
  // This can also be related to how we are dealing with this redirection along with %CSP.REST.
  while readCount < v.Size {
    set buffer = v.Read()
    set readCount = readCount + $length(buffer)
    write $$$ZENJSONESCAPE(buffer,"s")
  }
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Dynamic.Unmarshaller">
<Description>
This class is used to transform a %DynamicAbstractObject into a full-featured %RegisteredObject, which also includes %Persistent-inherited class instances.
It's used internally by Frontier, but can be used manually as well by using the method Unmarshal, which takes a class name and the dynamic instance.</Description>
<IncludeCode>%occErrors,frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64505,55057.137365</TimeCreated>

<Property name="Depth">
<Description>
An integer indicating how deep in the dynamic object the marshalling is.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Formatter">
<Description>
An instance of the property formatter that was provided in the router's OnSetup method.</Description>
<Type>Frontier.PropertyFormatter</Type>
<Private>1</Private>
</Property>

<Property name="CachedDefinitions">
<Description>
A list of the already used definitions, which can prevent roundtrips.</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Path">
<Description>
A string indicating the current visited path, that is used to report errors.</Description>
<Type>%String</Type>
<InitialExpression><![CDATA["<root>"]]></InitialExpression>
<Private>1</Private>
</Property>

<Property name="Strict">
<Description>
If set to 1 will return an error if the dynamic object doesn't fully comply with the provided class definition properties.
Otherwise the unknown properties will be skipped.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>formatter:Frontier.PropertyFormatter="",strict:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Formatter = formatter
  set ..Strict = strict
  return $$$OK
]]></Implementation>
</Method>

<Method name="Unmarshal">
<Description>
Creates a full-featured instance of the 'className', using the 'source' to populate its properties.
If $$$OK the 'result' is populated with the generated instance.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,source:%DynamicAbstractObject,*result:%RegisteredObject="",formatter:Frontier.PropertyFormatter="",strict:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set unmarshaller = ..%New(formatter, strict)
  return unmarshaller.DetermineTypeAndUnmarshal(className, source, .result)
]]></Implementation>
</Method>

<Method name="DetermineTypeAndUnmarshal">
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$GeneralError, "Unable to determine which class is '"_className_"'.")
  }

  if $isobject(dynamicObject) {
    set dynamicType = $classname(dynamicObject)
    set isCollection = ##class(Frontier.Types).IsCollection(className) || ##class(Frontier.Types).IsDynamicArray(className)

    if ##class(Frontier.Types).IsDynamicArray(dynamicType) {
      set sc = ..UnmarshalCollection(dynamicObject, .registeredObject, className)
    } elseif 'isCollection && ##class(Frontier.Types).IsDynamicObject(dynamicType) && ##class(Frontier.Types).IsInstantiable(className) {
      set sc = ..UnmarshalObject(className, dynamicObject, .registeredObject)
    }

    if $$$ISERR(sc) {
      set registeredObject = ""
      return $$$EMBEDSC($$$ERROR($$$GeneralError, $$$FormatText("Failed to unmarshal payload to type '%1'. Path: %2", className, ..Path)), sc)
    }

    return sc
  }
  return $$$ERROR($$$GeneralError, "Cannot unmarshal data types, expected a dynamic object that imitates an instance of "_className_". But received value: "_dynamicObject_ " instead.")
]]></Implementation>
</Method>

<Method name="UnmarshalUsingObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%RegisteredObject,dynamicObject:%DynamicAbstractObject,*registeredObject:%RegisteredObject="",propertyFormatter:Frontier.PropertyFormatter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set dynamicObject."__id__" = object.%Id()
  return ..Unmarshal($classname(object), dynamicObject, .registeredObject, propertyFormatter)
]]></Implementation>
</Method>

<Method name="InitializeObject">
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*initialObject:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  if '$isobject(dynamicObject) || ($isobject(dynamicObject) && 'dynamicObject.%IsA("%DynamicObject")) {
    return $$$ERROR($$$GeneralError, "An instance of %DynamicObject was not provided.")
  }

  if dynamicObject.%IsDefined("__id__") {
    set initialObject = $System.OBJ.OpenId(className, dynamicObject."__id__")
    if '$isobject(initialObject) return $$$ERROR($$$GeneralError, "Invalid id for '"_className_"'.")
  } else {
    set id = ..AtemptToFindIdUsingIndices(className, dynamicObject)
    if id '= "" {
      set dynamicObject."__id__" = id
      return ..InitializeObject(className, dynamicObject, .initialObject)
    }
    set initialObject = $System.OBJ.New(className)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="UpdatePath">
<FormalSpec>pathComponent:%String=""</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if pathComponent '="" set $piece(i%Path, ".", *+1) = pathComponent
  else  set ..Path = $piece(..Path, ".", 1, *-1)
]]></Implementation>
</Method>

<Method name="AtemptToFindIdUsingIndices">
<FormalSpec>className:%String,dynamicObject:%DynamicObject</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set idMembers = ""
  set id = ""

  set definition = ..GetAndCacheDefinition(className)
  for i=1:1:definition.Indices.Count() {
    set index = definition.Indices.GetAt(i)
    if index.IdKey = 1 {
      set idMembers = $lfs(index.Properties)
      quit
    }
  }

  if idMembers '= "" {
    for i=1:1:$listlength(idMembers) {
      set idProperty = $listget(idMembers, i)
      set value = dynamicObject.%Get(idProperty)
      if value '= "" set $piece(id, "||", *+1) = value
    }
  }
  if $length(id, "||") = $listlength(idMembers) return id
  return ""
]]></Implementation>
</Method>

<Method name="PopulateFormatter">
<FormalSpec>className:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set definition = ..GetAndCacheDefinition(className)
  if '$isobject(definition) return $$$ERROR($$$ClassDoesNotExist, className)

  if $isobject(..Formatter) {
    do ..Formatter.FormatAllProperties(definition.Properties, ..Depth)
  }

  return $$$OK
]]></Implementation>
</Method>

<Method name="GetPropertyId">
<FormalSpec>className:%String,key:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set propertyId = className_"||"

  if $isobject(..Formatter) {
    set propertyId = propertyId_..Formatter.Normalize(key, ..Depth)
  } else {
    set propertyId = propertyId_key
  }

  return propertyId
]]></Implementation>
</Method>

<Method name="NextQualifiedProperty">
<FormalSpec>className:%String,iterator:%Iterator.AbstractIterator,*key:%String="",*value="",*property:%Dictionary.CompiledProperty,iterationError:%Status=$$$OK</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[

  #define IsQualifiedProperty(%p) '(%p.Private || %p.Calculated || ($extract(%p.Name) = "%"))

  while 1 {
    set iterationError = $$$OK
    set hasNext = iterator.%GetNext(.candidateKey, .candidateValue)
    if 'hasNext return 0

    if candidateKey = "__id__" continue

    set propertyId = ..GetPropertyId(className, candidateKey)
    set property = ..GetAndCacheDefinition(propertyId)

    if '$isobject(property) {
      if '..Strict continue
      do ..UpdatePath(candidateKey)
      set iterationError = $$$ERROR($$$GeneralError, $$$FormatText("Candidate field '%1' is not a property from '%2'", candidateKey, className))
      return 0
    }

    if $$$IsQualifiedProperty(property) {
      set key = candidateKey
      set value = candidateValue
      return 1
    } else {
      continue
    }
  }
]]></Implementation>
</Method>

<Method name="GetInputType">
<FormalSpec>value:%String,property:%Dictionary.CompiledProperty</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if '$isobject(value) && ##class(Frontier.Types).IsDataType(property.Type) {
    return "datatype"
  } elseif $isobject(value) && value.%IsA("%DynamicObject") {
    return "dynamic"
  } elseif property.Collection '= "" {
    return "collection"
  } elseif ##class(Frontier.Types).IsPersistent(property.Type) {
    return "persistent"
  } elseif ##class(Frontier.Types).IsSerial(property.Type) {
    return "serial"
  } elseif ##class(Frontier.Types).IsStream(property.Type) {
    return "stream"
  }
  return ""
]]></Implementation>
</Method>

<Method name="WrapString">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,value,*stream:%Stream.Object=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stream = $System.OBJ.New(type)
  $$$AssertClassExists(stream)

  if $isobject(value) && value.%Extends("%Stream.Object") {
    // This is never true until ISC provides native support for Stream property when using dynamic instances.
    do stream.CopyFrom(value)
  } else {
    do stream.Write(value)
  }

  return $$$OK
]]></Implementation>
</Method>

<Method name="GetSerialObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,value,*serial:%SerialObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  set serial = $classmethod(type, "%Open", $lb(value, type))
  return $$$OK
]]></Implementation>
</Method>

<Method name="ResolvePrimitive">
<FormalSpec>type:%String,name:%String,object:%RegisteredObject,value,*result:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define BoolToBin(%v) $case(%v, "true" : 1, 1: 1, : 0)
  #define DateISOString(%d) (%d?4N1"-"2N1"-"2N1"T"2N1":"2N1":"2N1"."3N1"Z" = 1)

  set sc = $$$OK
  set inputValue = value

  try {
    if value = "null" {
      set value = ""
    } elseif type = "%Library.Boolean" {
      set value = $$$BoolToBin(value)
    } elseif $$$DateISOString(value) {
      if type = "%Library.Date" { set value = $zdh($p(value,"T",1),3,,,,,,,"") }
      elseif type = "%Library.Time" { set value = $zth($p($p(value, "T", 2), ".", 1)) }
      elseif type = "%Library.TimeStamp" || (type = "%Library.DateTime") {  set value = $translate(value, "Z", "") }
    } elseif type = "%Library.TimeStamp" || (type = "%Library.DateTime") {
      set value = $translate(value, "Z", "")
    } elseif type = "%Library.Date" || (type = "%Library.Time") {
      set value = ##class(Frontier.Shared.Utilities).SafeMethodCallAndReturn(.sc, object, name_"DisplayToLogical", value)
      $$$ThrowOnError(sc)
    }

    set valid = ##class(Frontier.Shared.Utilities).SafeMethodCallAndReturn(.sc, object, name_"IsValid", value)
    $$$ThrowOnError(sc)

    set value = ##class(Frontier.Shared.Utilities).SafeMethodCallAndReturn(.sc, object, name_"Normalize", value)
    if value = "error" $$$ThrowOnError($$$ERROR($$$GeneralError, "Internal normalization error"))
    $$$ThrowOnError(sc)

    if valid = 1 set result = value
  } catch {
    set error = $$$ERROR($$$GeneralError, $$$FormatText("Validation error: Invalid primitive value for property '%1' of type '%2' in class '%3'. Value: %4", name, type, $classname(object), inputValue))
    set sc = error
  }

  return sc
]]></Implementation>
</Method>

<Method name="GetPersistedObject">
<FormalSpec>type:%String,name:%String,value,*result:%Persistent=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set result = $System.OBJ.OpenId(type, value)

  if '$isobject(result) && (result '= "") {
    return $$$ERROR($$$GeneralError, $$$FormatText("Invalid id for property '%1', typed as '%2'.", name, type))
  }

  return $$$OK
]]></Implementation>
</Method>

<Method name="UnmarshalObject">
<FormalSpec>className:%String,dynamicObject:%DynamicAbstractObject,*object:%RegisteredObject=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  $$$QuitOnError(..InitializeObject(className, dynamicObject, .object))
  $$$QuitOnError(..PopulateFormatter(className))

  set ..Depth = ..Depth + 1

  set iterator = dynamicObject.%GetIterator()

  while ..NextQualifiedProperty(className, iterator, .key, .value, .property, .sc) {
    set type = ..GetInputType(value, property)
    set result = ""

    do ..UpdatePath(key)

    if type = "dynamic" {
      set sc = ..UnmarshalObject(property.Type, value, .result)
    } elseif type = "stream" {
      set sc = ..WrapString(property.Type, value, .result)
    } elseif type = "persistent" {
      set sc = ..GetPersistedObject(property.Type, property.Name, value, .result)
    } elseif type = "serial" {
      set sc = ..GetSerialObject(property.Type, value, .result)
    } elseif type = "collection"  {
      set result = $property(object, property.Name)
      set sc = ..UnmarshalCollection(value, .result)
    } elseif type = "datatype" {
      set sc = ..ResolvePrimitive(property.Type, property.Name, object, value, .result)
    } else {
      set sc = $$$ERROR($$$GeneralError, $$$FormatText("Invalid input type for key '%1' from '%2'", key, className))
    }

    if $$$ISERR(sc) quit
    do ..UpdatePath("")
    set $property(object, property.Name) = result
  }

  set ..Depth = ..Depth - 1
  return sc
]]></Implementation>
</Method>

<Method name="UnmarshalCollection">
<FormalSpec><![CDATA[dynamicCollection:%DynamicAbstractObject,&collection:%Collection.Super="",className:%String=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set insertStrategy = "list"
  set hasChildObjects = 0
  set collectionClass = "%ListOfDataTypes"
  set firstItem = dynamicCollection.%Get(0)
  set startOffset = 0

  set collectionType = $classname(collection)

  if collectionType [ "RelationshipObject" {
    set startOffset = 1
  }

  if $isobject(firstItem) {
    set hasChildObjects = '##class(Frontier.Types).IsDataType($classname(firstItem))
  }

  if dynamicCollection.%IsA("%DynamicObject") {
    set insertStrategy = "Array"
    set collectionClass = $replace(collectionClass, "List", insertStrategy)
  }

  if hasChildObjects {
    set collectionClass = $replace(collectionClass, "OfDataTypes", "OfObjects")
  }

  // We usually have the collection instance, so we can just Clear it.
  // However when this method is called recursively (linear), then we must create the instance ourselves.
  if $isobject(collection) {
    do collection.Clear()
  } else {
    set collection = $System.OBJ.New(collectionClass)
  }

  set elementType = $case(className, "": collection.ElementType, : className)
  set iterator = dynamicCollection.%GetIterator()
  set isPersistentItem = ##class(Frontier.Types).IsPersistent(elementType)

  set ..Depth = ..Depth + 1

  while iterator.%GetNext(.key, .dynamicItem) {
    do ..UpdatePath(key)

    set isIdCandidate = '$isobject(dynamicItem) && (dynamicItem '= "")
    set itemClass = $select('isIdCandidate : $classname(dynamicItem), 1: "")

    if dynamicItem = "null" && (itemClass '= "") continue

    if isIdCandidate && isPersistentItem {
      set item = $System.OBJ.OpenId(elementType, dynamicItem)
    } elseif $isobject(dynamicItem) {
      set sc = $select(
        dynamicItem.%IsA("%DynamicObject") : ..UnmarshalObject(elementType, dynamicItem, .item),
        dynamicItem.%IsA("%DynamicArray") : ..UnmarshalCollection(dynamicItem, .item),
        1: $$$ERROR($$$GeneralError, "Cannot unmarshal items that aren't dynamic.")
      )
      if item = "" continue
    } else {
      set item = dynamicItem
    }

    if $$$ISERR(sc) quit

    if insertStrategy = "Array" {
      set key = $select($isvalidnum(key) && (startOffset > 0): key + startOffset, 1: key)
      do collection.SetAt(item, key)
    } else {
      do collection.Insert(item)
    }

    do ..UpdatePath("")
  }

  set ..Depth = ..Depth - 1
  quit sc
]]></Implementation>
</Method>

<Method name="GetAndCacheDefinition">
<FormalSpec>id:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Persistent</ReturnType>
<Implementation><![CDATA[

  if id [ "||" set definitionClass = "%Dictionary.CompiledProperty"
  else  set definitionClass = "%Dictionary.CompiledClass"

  set definition = $get(i%CachedDefinitions(id))
  if $isobject(definition) return definition

  set i%CachedDefinitions(id) = $System.OBJ.OpenId(definitionClass, id)
  return i%CachedDefinitions(id)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Exception">
<Super>%Exception.StatusException</Super>
<TimeCreated>64225,38503.046031</TimeCreated>

<Method name="CreateFromStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSC:%Status,errorIndex:%Integer=1</FormalSpec>
<ReturnType>Frontier.Exception</ReturnType>
<Implementation><![CDATA[
  #dim tException As %Exception.AbstractException
  #dim tData As %List
  #dim tInfo
  
  Set tException = $$$NULLOREF
  
  Do $SYSTEM.Status.DecomposeStatus(pSC,.tInfo)
  If $DATA(tInfo(1)) {
    // Build the exception object
    Set tData="" For tI=1:1:9 Set tData=tData_$LB(tInfo(errorIndex,"param",tI))
    Set tException = ..%New(tInfo(errorIndex,"code"),tInfo(errorIndex,"code"),$get(tInfo(errorIndex,"caller")),tData)
    
    // If there's an embedded error, construct that also
    If $DATA(tInfo(errorIndex,"embeddedstatus")) {
      Set tException.InnerException = ..CreateFromStatus(tInfo(errorIndex,"embeddedstatus"))
    }
    If $data(tInfo(errorIndex + 1)) Set tException.NextException=..CreateFromStatus(pSC, errorIndex + 1)
  }
  
  Quit tException
]]></Implementation>
</Method>

<Method name="ToDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()
  set graph = ..BuildObjectGraph(exception)
  
  if graph.%IsA("%DynamicObject") {
    set de.error = graph
  } elseif graph.%IsA("%DynamicArray") {
    set de.errors = graph
  }  
  return de
]]></Implementation>
</Method>

<Method name="CreateInfoObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set de = ##class(%DynamicObject).%New()    
  set de.internalCode = exception.Code
  
  set fullMessage = $System.Status.GetOneStatusText(exception.AsStatus(), 1)
  set messageWithoutLF = $piece(fullMessage, $c(13), 1, 1)
  
  set message = ##class(%Regex.Matcher).%New("#[0-9]{1,4}\:", messageWithoutLF).ReplaceAll("")
  set message = $piece(messageWithoutLF, "#:", 1 , 1)
  set de.message = message
  return de
]]></Implementation>
</Method>

<Method name="BuildObjectGraph">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:Frontier.Exception</FormalSpec>
<ReturnType>%DynamicAbstractObject</ReturnType>
<Implementation><![CDATA[
     
  #define SupportsNextException(%ex) ($isobject(%ex) && ##class(%Dictionary.CompiledProperty).%ExistsId($classname(%ex)_"||NextException") && $isobject(%ex.NextException))  
  
  if $$$SupportsNextException(exception) {
    set de = ..CreateInfoObject(exception)
    set ex = exception.NextException
    set de = [ (de) ]
    while ex {
      set sibling = {}
      do TraverseException(.sibling, ex)
      do de.%Push(sibling)
      if $$$SupportsNextException(ex) {
        set ex = ex.NextException           
      } else {
        quit
      }      
    }
    return de
  }
  
  do TraverseException(.de, exception)
  return de

TraverseException(payload, ex)
  set payload = ..CreateInfoObject(ex)
  set supportsInnerException = ##class(%Dictionary.CompiledProperty).%ExistsId($classname()_"||InnerException") 

  if supportsInnerException && $isobject(ex.InnerException) {
    set payload.origin = ..BuildObjectGraph(ex.InnerException)   
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="CaptureStack">
<ClassMethod>1</ClassMethod>
<FormalSpec>*stackText:%Stream.GlobalCharacter="",from:%Integer=($stack  - $estack) + 1,to:%Integer=$stack +1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stackText = ##class(%Stream.GlobalCharacter).%New()
    
  do stackText.WriteLine("Runtime exception")  
  for loop=to:-1:from {
    do stackText.WriteLine(" at "_$stack(loop, "PLACE"))
    do stackText.WriteLine(" "_$stack(loop, "MCODE"))
  }
  do stackText.Rewind()
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Files">
<Description><![CDATA[
This class provides a bridge to access the Upload API and also contains the engine
to serve files. Either directories and single files can be served.
If you need so serve a single file you can use the method ServeFile.
If you need to serve a path, you can use the method ServeFrom.
However if you need more configuration power, then you must use the Serve method.
Both ServeFile and ServeForm are basically wrappers for the Serve method with a set
of predefined configurations.

Using Serve allows the application to provide advanced cache configuration and extension recognition.
The following settings are available for usage:

root - Provides the path where files are located.

file - If root is not provided, a 'file' is expected to be defined. Which points to a file instead of a directory.

index - Indicates which files to search for and serve as default if no specific file path was provided. THis is ignored if 'file' is specified.

charset - Defines which charset to be apply while reading the device and also sets the charset parameter for the response.

cache - How the cache should behave.

cache.configuration - A string containing the Cache-Control header configuration. Eg: "max-age=120, public".
cacheignore - A array indicating which extensions should not be cached.

extensions - An Object containing how to the server should handle files matching the extension.

The file server attempts to discover how to handle the extension.
But defaults to 'application/octet-stream' if the extension is unknown. The 'extension' object provides a way to handle them.
Each extension object should be keyed by its own extension identifier along with a child object.

<extension> - This is the keyed object, all configurations inside it will affect the <extension> exclusively.
<extension>.disposition - This will set the Content-Disposition header.
<extension>.disposition = "attachment" will force the browser to download the file instead of opening it.
<extension>.disposition = "inline" will force the browser to open the file.
<extension>.mimeType - Sets the Content-Type to the specified string.
<extension>.binary - Informs the file server to handle the file as binary. This disables charset conversion.
<extension>.charset - If not specified, this assumes the global 'charset' configuration. This setting exists to differ the charset by the file extension.

You can see an example using the full-sized configuration in the class Frontier.UnitTest.Router, method TestGETStaticFileWithCustomConfig.]]></Description>
<IncludeCode>%cspBuild,frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64817,50880.253868</TimeCreated>

<Property name="Context">
<Description>
This is a reference for the %frontier object.</Description>
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Property name="Uploader">
<Description>
This is the uploader API, used to handle single file and multipart uploads.</Description>
<Type>Frontier.Files.Uploader</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context
  set ..Uploader = ##class(Frontier.Files.Uploader).%New(context)
  return $$$OK
]]></Implementation>
</Method>

<Method name="Upload">
<FormalSpec>settings:%DynamicObject</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do ..Context.Raw()
  $$$ThrowOnError(..Uploader.HandleRequest(settings))
  return ""
]]></Implementation>
</Method>

<Method name="ServeFrom">
<FormalSpec>root:%String</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  return ..Serve({
    "root": (root),
    "etag": "weak",    
    "index": "index.html index.htm",
    "extensions": {
      "md": {
        "disposition": "inline",
        "mimeType": "text/markdown",
        "charset": "utf-8",
        "binary": false
      }
    }
  })
]]></Implementation>
</Method>

<Method name="ServeFile">
<FormalSpec>absoluteFilePath:%String,charset:%String="utf-8"</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  return ..Serve({
    "file": (absoluteFilePath),
    "etag": "weak",
    "charset": (charset),
    "extensions": {
      "md": {
        "disposition": "inline",
        "mimeType": "text/markdown",
        "binary": false
      }
    }
  })
]]></Implementation>
</Method>

<Method name="Serve">
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  // Make sure to stream the file in plain text.
  do ..Context.Raw()

  if config.%IsDefined("file") {
    // We are only serving a file that we define which is it.
    set normalizedAbsoluteFilePath = ##class(%File).NormalizeFilename(config.file)
    set fileExists = ##class(%File).Exists(normalizedAbsoluteFilePath)
    set requestDirectory = normalizedAbsoluteFilePath
  } else {
    // We are serving a directory.
    set directory = config.root
    set indexAs = config.index

    // Checks if a path to a file has been provided.
    set virtualPath = $get(..Context.Matches(1))
    set requestDirectory = ""

    // Otherwise fallback to possible indexAs files.
    if virtualPath = "" set virtualPath = indexAs
    set fileExists = 0

    // Attempted to access a path outside the root.
    if virtualPath [ ".." {
      return ..Context.ThrowException("File does not exist.", "404 Not Found")
    }

    for i=1:1:$length(virtualPath, " ") {
      set virtualFileName = $piece(virtualPath, " ", i)
      set requestDirectory = ##class(%File).NormalizeFilename(virtualFileName, directory)      
      if ##class(%File).Exists(requestDirectory) set fileExists = 1 quit
    }
  }   

  if 'fileExists {
    if 'config.%IsDefined("redirect404To") {
      return ..Context.ThrowException("File does not exist.", "404 Not Found")
    } elseif config.root '= "" {
      set requestDirectory = ##class(%File).NormalizeFilename(config.root_"/"_config.redirect404To)
      if ##class(%File).Exists(requestDirectory) return ..Context.ThrowException("File does not exist.", "404 Not Found")
    }
  }

  $$$ThrowOnError(..GetFileServerConfig(.appConfig))

  set fileName = $piece(requestDirectory, $$$OSSlash, *)
  set extension = $piece(fileName, ".", *)

  set contentConfig = ..GetContentConfiguration(extension, config)
  set charset = contentConfig.charset

  if contentConfig.binary = 1 {
    // Prevents content corruption.
    set ..Context.Response.NoCharSetConvert = 1
    set ..Context.Response.CharSet = ""
    set stream = ##class(%Stream.FileBinary).%New()
  } else {
    set stream = ##class(%Stream.FileCharacter).%New()
    if charset '= "" {
      set stream.TranslateTable = $$MapCharset^%SYS.NLS(charset)
      set ..Context.Response.CharSet = contentConfig.charset
    }
  }

  $$$ThrowOnError(stream.LinkToFile(requestDirectory))

  set ..Context.Response.ContentType = contentConfig.mimeType
  set ..Context.Response.ContentLength = stream.Size

  set extensionMatch = 0

  for i=1:1:contentConfig.cache.ignore.%Size() - 1 {
    if contentConfig.cache.ignore.%Get(i) = extension {
      set extensionMatch = 1
      quit
    }
  }

  if 'extensionMatch {
    do ..Context.Response.SetHeader("ETag", ..MakeETag(stream, config.etag))
    do ..Context.Response.SetHeader("Cache-Control", contentConfig.cache.configuration)
  }

  if ..IsCacheHit(stream, config.etag) {
    do ..Context.Status("304 Not Modified")
    return ""
  }

  do ..Context.Response.SetHeader("Last-Modified", ##class(%CSP.StreamServer).ToHTTPDate(stream.LastModified))
  do ..Context.Response.SetHeader("Vary", "Accept-Encoding")

  if contentConfig.disposition = "attachment" {
    do ..Context.Response.SetHeader("Content-Disposition", $$$FormatText("%1; filename=%2", contentConfig.disposition, fileName))
  }
  return stream
]]></Implementation>
</Method>

<Method name="GetContentConfiguration">
<FormalSpec>extension:%String,config:%DynamicObject</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[

  set globalCharsetOverwrite = config.charset
  set extensionConfig = $property(config.extensions, extension)

  do ##class(%CSP.StreamServer).FileClassify(extension, .contentType, .bin, .charset)

  if globalCharsetOverwrite '= "" { set charset = globalCharsetOverwrite }
  elseif (charset = "" &&( bin '= 1)) { set charset = "utf-8" }

  if '$isobject(extensionConfig) set extensionConfig = {}
  if '$isobject(config.cache) set config.cache = {}

  return ##class(Frontier.Shared.Utilities).DeepExtend(
    extensionConfig,
    { "cache": (config.cache) },
    { "cache": { "configuration": "max-age=2628000, public", "ignore": [] } },
    { "binary": (bin), "mimeType": (contentType), "charset": (charset) },
    { "disposition": "inline" }
  )
]]></Implementation>
</Method>

<Method name="MakeETag">
<FormalSpec>stream:%Stream.Object,validator:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if validator = "strong" {
    set hash = ##class(%File).SHA1Hash(stream.Filename)
    return $c(34)_$zcvt(##class(%xsd.hexBinary).LogicalToXSD(hash), "l")_$c(34)
  }

  set hash = $System.Encryption.SHA1Hash(stream.Filename_stream.LastModified_stream.Size)
  return "W/"_$c(34)_$zcvt(##class(%xsd.hexBinary).LogicalToXSD(hash), "l")_$c(34)
]]></Implementation>
</Method>

<Method name="IsCacheHit">
<FormalSpec>stream:%Stream.Object,validator:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set ifNoneMatch = ..Context.Request.GetCgiEnv("HTTP_IF_NONE_MATCH")
  if ifNoneMatch '= "" && (ifNoneMatch = ..MakeETag(stream, validator)) return 1
  return 0
]]></Implementation>
</Method>

<Method name="GetFileServerConfig">
<FormalSpec>*config:%DynamicObject={{}}</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  set appPath = $extract(..Context.Request.Application, 1, *-1)

  set application = ##class(Security.Applications).%OpenId(appPath)
  if '$isobject(application) return $$$ERROR($$$GeneralError, "Application not found.")
  if application.ServeFiles '= 1 return $$$ERROR($$$GeneralError, "The application is not configured to serve files.")

  set config.ServeFilesTimeout = application.ServeFilesTimeout

  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Files.Uploader">
<Description>
This class is the actual engine for handling multipart/form-data uploads.

Configuration is made by using a %DynamicObject instances.
The uploader always returns empty responses if not OK, throws an exception when a error happens.
However since uploads can be still be realized partially, the implementation can use the hooks to
undo any uploads that have succeeded (OnError) or do something based on its success (OnCompleteOne).

The path is built based on a list of the following placeholders:

:KEY - Represents the destination name.
:FILE_NAME - Self-described.
:NAMESPACE - Self-described.
:USERNAME - Self-described.
:EXTENSION - The extension in the file name, could be empty.
:RANDOM - Represents a list of random characters to provide lower conflict chances.

The path can be provided as string to each destination key or using object format.
Using object format allows certain uploads to be optional.

Its also possible to define a set of filters that purge irregular entries.

Those filters can be:

fileMaxSize - Specify a KB size limit, files bigger than that are purged from the queue.
extensions - When providing a list of extensions, files whose extension is outside the array are purged from queue.
minNameLength - Requires the filename to have at least N chars length.
maxNameLength - Requires the filename to have a maxium of N chars length.

There are also 3 optional hooks that can be used to handle specific situations:

OnComplete - Called whenever a upload is finished without errors.
OnCompleteAll - Called when all uploads are finished without error
OnError - Called whenever an upload fails.

You can check the method TestPOSTMultipartFileUpload from the class Frontier.UnitTest.Router
to see a complete example on how to configure it.</Description>
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64817,60989.521649</TimeCreated>

<Parameter name="MINFILENAMELENGTHMSG">
<Default>File name :FILE_NAME must have at least :SIZE characters.</Default>
</Parameter>

<Parameter name="MAXFILENAMELENGTHMSG">
<Default>File name :FILE_NAME cannot exceed :SIZE characters.</Default>
</Parameter>

<Parameter name="MAXFILESIZEMSG">
<Default>File :FILE_NAME (:SIZE bytes) exceeded the max allowed size of :VALUE bytes.</Default>
</Parameter>

<Parameter name="EXTENSIONNOTALLOWEDMSG">
<Default>File extension :EXTENSION is not allowed.</Default>
</Parameter>

<Property name="Context">
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Property name="OnItemUploadSuccess">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="OnItemUploadError">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Filter">
<Type>%DynamicObject</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context
  return $$$OK
]]></Implementation>
</Method>

<Method name="HandleRequest">
<Internal>1</Internal>
<FormalSpec>settings:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  #define DestinationAsObject(%d) if '$isobject(%d) set %d = { "path": (%d) }
  set sc = $$$OK
  set validMethods = $lb("POST", "PUT")

  if $lf(validMethods, ..Context.Request.Method) < 1 {
    return $$$ERROR($$$GeneralError, "Must use POST or PUT to handle uploads.")
  }

  if '$isobject(settings.filters) set settings.filters = {}
  if '$isobject(settings.hooks) set settings.hooks = {}

  set ..OnItemUploadSuccess = settings.hooks.onItemUploadSuccess

  set result = []

  $$$QuitOnError($$AssertContentTypeMatch(settings.%IsDefined("destinations")))

  if $isobject(settings.destinations) {
    set it = settings.destinations.%GetIterator()
    set isSingle = 1

    while it.%GetNext(.key, .destination) {
      $$$DestinationAsObject(destination)
      if destination.slots = "" || (destination.slots < 0) set destination.slots = 1

      set ssc = ..HandleMultipart(key, destination, settings.filters, .filePath)

      if $$$ISOK(ssc) set ssc = $$$EMBEDSC(ssc, ..CallHook(settings.hooks.onItemUploadSuccess, key, destination, filePath))
      else  set ssc = $$$EMBEDSC(ssc, ..CallHook(settings.hooks.onItemUploadError, key, destination, filePath, ssc))

      set sc = $$$ADDSC(sc, ssc)
      do result.%Push({ "sc": (ssc), "key": (key), "destination": (destination), "filePath": (filePath) })
    }
  } elseif settings.destination '= "" {
    set sc = $$$ADDSC(sc, ..HandleSingleFile(settings.destination, settings.filters, .filePath))
    do result.%Push({ "sc": (sc), "destination": (settings.destination), "filePath": (filePath) })

    if $$$ISERR(sc) {
      set sc = $$$ADDSC(sc, ..CallHook(settings.hooks.onItemUploadError, "", settings.destination, filePath, sc))
    }
  } else {
    return $$$ERROR($$$GeneralError, "No valid uploader configuration was found.")
  }

  set sc = $$$ADDSC(sc, ..CallHook(settings.hooks.onComplete, result))
  return sc

AssertContentTypeMatch(multi)
  set error = $$$ERROR($$$GeneralError, "Wrong request headers.")

  set receivedMulti = (..Context.Request.ContentType [ "multipart/form-data")
  set receivedSingle = (..Context.Request.ContentType '[ "multipart/form-data")

  if (multi && (receivedMulti = 1)) || ('multi && receivedSingle = 1) {
    return $$$OK
  }

  do ..Context.Status("400 Bad Request")
  return error
]]></Implementation>
</Method>

<Method name="HandleMultipart">
<FormalSpec>key:%String,destination:%DynamicObject,filters:%DynamicObject,*filePath:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define AddErrorAndContinue(%error) set sc = $$$ADDSC(sc, %error)  continue

  set sc = $$$OK
  set mimeDataCount = ..Context.Request.CountMimeData(key)

  // Prevents the request from bypassing the limit otherwise takes the count as limit
  // if the request provided is lesser MIME entries than the expected.
  set limit = $select(destination.slots > mimeDataCount : mimeDataCount, 1: destination.slots)

  if '$isobject(destination.filters) set destination.filters = {}
  set filters = ##class(Frontier.Shared.Utilities).DeepExtend(destination.filters, filters)

  for i=1:1:limit {
    set mimeData = ..Context.Request.GetMimeData(key, "", i)

    if '$isobject(mimeData) {
      if destination.optional = 1 return $$$OK
      if limit > 1 $$$AddErrorAndContinue($$$ERROR($$$GeneralError, $$$FormatText("No data for '%1' at index %2.", key, i)))
      $$$AddErrorAndContinue($$$ERROR($$$GeneralError, $$$FormatText("No data for '%1'.", key)))
    }

    set fileName = ##class(Frontier.Shared.Utilities).SanitizeFilename(mimeData.FileName)
    set extension = $piece(fileName, ".", *)

    set filePath = ..MakeFilePath(key, i, fileName, destination.path, extension)

    if '..MatchFilters(filters, fileName, extension, mimeData, .fsc) $$$AddErrorAndContinue(fsc)
    $$$AddErrorAndContinue(..StoreToFS(key, i, destination.path, filePath, mimeData))
 }
 return sc
]]></Implementation>
</Method>

<Method name="HandleSingleFile">
<FormalSpec>destination:%String,filters:%DynamicObject,*filePath=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set stream = ..Context.Request.Content

 if '$isobject(stream) {
   return $$$ERROR($$$GeneralError, "No file was sent.")
 }

 set fileName = ##class(%File).GetFilename(destination)
 set extension = $piece(fileName, ".", *)

 set filePath = ..MakeFilePath("", fileName, "", destination, extension)

 if '..MatchFilters(filters, fileName, extension, stream, .sc) return sc

 return ..StoreToFS("", "", destination, filePath, stream)
]]></Implementation>
</Method>

<Method name="MakeFilePath">
<FormalSpec>key:%String,index:%String,fileName:%String,destination:%String,extension:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  set filePath = ##class(Frontier.Shared.Utilities).ReplacePlaceholders({
    "text": (destination),
    "placeholders": {
      ":RANDOM": (##class(Frontier.Shared.Utilities).RandomString(10)),
      ":FILE_NAME": ($piece(fileName, ".", *-1)),
      ":KEY": (key),
      ":INDEX": (index),
      ":EXTENSION": ($case(extension, "": "", : "."_extension)),
      ":NAMESPACE": ($namespace),
      ":USER": ($username)
    }
  })
  return ##class(%File).NormalizeFilename(filePath)
]]></Implementation>
</Method>

<Method name="StoreToFS">
<FormalSpec>key:%String,index:%String,destination:%String,filePath:%String,mimeData:%Stream.Object</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  try {
    // Sometimes GetDirectory cannot find the directory.
    // So we use $piece instead.
    // set path = ##class(%File).GetDirectory(filePath)
    set path = $piece(filePath, $$$OSSlash, 1, *-1)
    set created = ##class(%File).CreateDirectoryChain(path, .oserr)

    if 'created {
      return $$$ERROR($$$GeneralError, "Cannot prepare file destination: System reported code "_oserr_".")
    }

    if mimeData.IsCharacter() {
      set file = ##class(%Stream.FileCharacter).%New()
    } else {
      set file = ##class(%Stream.FileBinary).%New()
    }

    $$$ThrowOnError(file.LinkToFile(filePath))
    $$$ThrowOnError(file.CopyFromAndSave(mimeData))
    $$$ThrowOnError(..CallHook(..OnItemUploadSuccess, key, index, destination, filePath))
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="CallHook">
<ClassMethod>1</ClassMethod>
<FormalSpec>hook:%String="",args...</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if hook = "" return $$$OK

  set classname = $piece(hook, ":", 1)
  set method = $piece(hook, ":", 2)
  try {
    return $classmethod(classname, method, args...)
  } catch ex {
    return ex.AsStatus()
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="MatchFilters">
<ClassMethod>1</ClassMethod>
<FormalSpec>filters:%DynamicObject,fileName:%String,extension:%String,mimeData:%Stream.Object,*sc:%Status</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[

  set sc = $$$OK
  set nameLength = $length(fileName)

  if filters.%IsDefined("minNameLength") {
    do BuildFilter(filters.minNameLength, ..#MINFILENAMELENGTHMSG, .minNameLength)
    if nameLength < minNameLength.value {
      if filters.verbose = 1 set sc = $$$ERROR($$$GeneralError, minNameLength.message)
      return 0
    }
  }

  if filters.%IsDefined("maxNameLength") {
    do BuildFilter(filters.maxNameLength, ..#MAXFILENAMELENGTHMSG, .maxNameLength)
    if nameLength > maxNameLength.value {
      if filters.verbose = 1 set sc = $$$ERROR($$$GeneralError, maxNameLength.message)
      return 0
    }
  }

  if filters.%IsDefined("maxFileSize") {
    do BuildFilter(filters.maxFileSize, ..#MAXFILESIZEMSG, .maxFileSize)
    if mimeData.Size > maxFileSize.value {
      if filters.verbose = 1 set sc = $$$ERROR($$$GeneralError, maxFileSize.message)
      return 0
    }
  }

  if filters.%IsDefined("extensions") {
    do BuildFilter(filters.extensions, ..#EXTENSIONNOTALLOWEDMSG, .extensions)
    set match = 0
    for i=0:1:extensions.value.%Size() - 1 {
      if extensions.value.%Get(i) = extension {
        set match = 1
        quit
      }
    }
    if 'match {
      if filters.verbose = 1 set sc = $$$ERROR($$$GeneralError, extensions.message)
      return 0
    }
  }

  return 1

BuildFilter(filter, templateMsg, normalizedFilter)
  if '$isobject(filter) || 'filter.%IsA("%DynamicObject") {
    set filter = {
      "value": (filter),
      "errorTemplate": (templateMsg)
    }
  }

  set placeholders = {
    ":FILE_NAME": (fileName),
    ":VALUE": (filter.value),
    ":SIZE": (mimeData.Size),
    ":EXTENSION": (extension)
  }

  set normalizedFilter = {
    "value": (filter.value),
    "message": (
      ##class(Frontier.Shared.Utilities).ReplacePlaceholders({
        "text": (filter.errorTemplate),
        "placeholders": (placeholders)
      })
    )
  }

  quit
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Method">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64502,35961.209604</TimeCreated>

<Property name="DispatchClass">
<Type>%String</Type>
</Property>

<Property name="DispatchMethod">
<Type>%String</Type>
</Property>

<Property name="MethodArguments">
<Type>ArgumentDescription</Type>
<Collection>list</Collection>
</Property>

<Property name="MethodDescriptor">
<Type>%Dictionary.CompiledMethod</Type>
<Private>1</Private>
</Property>

<Property name="ReturnTypeParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Payload">
<Type>%CacheString</Type>
</Property>

<Property name="HttpMethod">
<Type>%String</Type>
<InitialExpression>"GET"</InitialExpression>
</Property>

<Property name="RouteParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Arguments">
<Type>%CacheString</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Context">
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec><![CDATA[context:Frontier.Context,RESTMethodArguments:%String=0,&matches:%String=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set requestQueryParams = 0
  set strictQueryParameters = context.StrictQueryParameters
  set propertyFormatter = context.PropertyFormatter
  set request = context.Request

  $$$ThrowOnError(..AssertMethodExists(context.ClassName, context.Method))

  set ..DispatchClass = context.ClassName
  set ..DispatchMethod = context.Method
  set ..Context = context
  set ..HttpMethod = context.Request.Method
  set ..MethodDescriptor = ##class(%Dictionary.CompiledMethod).%OpenId(context.ClassName_"||"_context.Method)

  $$$ThrowOnError(..ParseArguments())
  $$$ThrowOnError(..ParseReturnTypeParameters())

  if ..MethodDescriptor.ReturnType = "" {
    $$$ThrowOnError($$$ERROR($$$GeneralError, $$$FormatText("Expected a return type for method %1.", ..DispatchMethod)))
  }

  if $isobject(request) {
    set ..Payload = request.Content
    set ..HttpMethod = request.Method
    merge requestQueryParams = request.Data
  }

  merge i%RouteParameters = RESTMethodArguments

  if matches = "" {
    $$$ThrowOnError(..MergeArguments(.RESTMethodArguments, .requestQueryParams, .mergedArguments, strictQueryParameters))
    $$$ThrowOnError(..Sequentialize(.mergedArguments, propertyFormatter))
  } else {
    set i%Arguments = matches
    merge i%Arguments = matches
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ParseArguments">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set describedArguments = ##class(%ListOfObjects).%New()
  set formalSpec = ..MethodDescriptor.FormalSpecParsed
  set unparsedFormalSpec = ..MethodDescriptor.FormalSpec
    
  for i=1:1:$ll(formalSpec) {
    set argSpec = $lg(formalSpec, i)
    set unparsedArg = $piece(unparsedFormalSpec, ",", i)
    set argument = ##class(Frontier.ArgumentDescription).%New()    
    set argName = $lg(argSpec, 1)
    set defaultValue = $lg(argSpec, 4)       
    
    set argument.Index = i
    
    if argName [ "..." {
      set argName = $replace(argName, "...", "")
      set argument.Arity = 1
    }
    
    if defaultValue '= "" {
      set argument.HasDefaultValue = 1
      set argument.DefaultValue = $$$trimQuote(defaultValue)
    }
    
    set argument.Name = argName
    
    // This deals with unspecified argument type, we cannot use FormalSpecParsed because
    // when undefined it defaults to %Library.String, and that is not ideal for type checking.
    set typeDef = $piece(unparsedArg, ":", 2)
    // -2 = Go back to the position BEFORE the char is found.
    set typeBoundary = $find(typeDef, "(") - 2
    if typeBoundary < 1 set typeBoundary = $find(typeDef, "=") - 2
    if typeBoundary < 1 set typeBoundary = $length(typeDef)                
    
    set argument.Type = $extract(typeDef, 1, typeBoundary)
    
    for ii=6:2:$ll(argSpec) {
      set paramName = $lg(argSpec, ii - 1)
      set paramValue = $$$trimQuote($lg(argSpec, ii))
      do argument.Parameters.SetAt(paramValue, paramName)
      if paramName = "ALIAS" set argument.Alias = paramValue
    }
    do ..MethodArguments.Insert(argument)
  }
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="FindArgumentByAliasOrName">
<Internal>1</Internal>
<FormalSpec>identifier:%String</FormalSpec>
<Private>1</Private>
<ReturnType>Frontier.ArgumentDescription</ReturnType>
<Implementation><![CDATA[

  for i=1:1:..MethodArguments.Count() {
    set argument = ..MethodArguments.GetAt(i)
    if argument.Name = identifier || (argument.Alias = identifier) return argument
  }
  return ""
]]></Implementation>
</Method>

<Method name="ParseReturnTypeParameters">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set serializedParameters = ..MethodDescriptor.ReturnTypeParams
  if serializedParameters = "" return $$$OK
  set parametersCount = $length(serializedParameters, ",")

  for i=1:1:parametersCount {
    set part = $piece(serializedParameters, ",", i)
    set parameterKey = $piece(part, "=", 1)
    set parameterValue = $piece(part, "=", 2)
    set i%ReturnTypeParameters(parameterKey) = parameterValue
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertMethodExists">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = className_"||"_methodName

  if '##class(%Dictionary.CompiledClass).%ExistsId(className) {
    return $$$ERROR($$$ClassDoesNotExist, className)
  }

  if '##class(%Dictionary.CompiledMethod).%ExistsId(id) {
    return $$$ERROR($$$MethodDoesNotExist, methodName)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Sequentialize">
<FormalSpec><![CDATA[&mergedArguments=0,propertyFormatter:Frontier.PropertyFormatter=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim methodArgument As Frontier.ArgumentDescription
  #define TriggerPayloadFlag if ..HttpMethod = "POST" || (..HttpMethod = "PUT") || (..HttpMethod = "PATCH") set payloadFound = 1
  #define AssertSinglePayloadParameter throw:payloadFound=1 ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, "Cannot have more than one payload for POST/PUT/PATCH requests."))
  #define GetPayloadType(%classname) $case(%classname, "%Library.DynamicArray" : "array", : "object")

  set sc = $$$OK

  set argsProcessed = 0
  set payloadFound = 0

  set methodArgumentsLength = ..MethodArguments.Count()

  set jsonErrorMessage = "Wrong argument value: Using '%1' as argument type requires that a JSON payload is sent to be parsed."
  if $$$ISERR(sc) return sc

  set maxLength = methodArgumentsLength
  if maxLength < mergedArguments set maxLength = mergedArguments 

  if methodArgumentsLength > 0 {
    for argsProcessed=1:1:maxLength {
      set methodArgument = $select(argsProcessed > methodArgumentsLength
        :  ..MethodArguments.GetAt(methodArgumentsLength),
        1: ..MethodArguments.GetAt(argsProcessed)
      )

      set value = $get(mergedArguments(argsProcessed))
      set resolvedId = ""

      if value = "" {
        if 'methodArgument.Arity set value = methodArgument.DefaultValue
        else  set value = $get(mergedArguments(methodArgument.Index))
      }

      set shouldUnmarshall = (methodArgument.Parameters.GetAt("UNMARSHAL") = 1)
      set whereId = methodArgument.Parameters.GetAt("WHEREID")
      set isDynamic = ##class(Frontier.Types).IsDynamic(methodArgument.Type)
      set isPersistable = ##class(Frontier.Types).IsPersistent(methodArgument.Type)

      if whereId '= "" {
        set sc = ..ResolveWhereId(whereId, methodArgument.Name,  methodArgument.Type, .resolvedId)
      }

      if shouldUnmarshall || isDynamic {
        set dynamicClass = $select('shouldUnmarshall : methodArgument.Type, 1: "%Library.DynamicObject")
        if ..Payload = "" {
          return $$$ERROR($$$GeneralError, $$$FormatText(jsonErrorMessage, dynamicClass))
        }        

        // If there's already a payloadable argument and another one is found, then we fail the request.
        $$$AssertSinglePayloadParameter
        $$$TriggerPayloadFlag

        // This flag is only set for some specific http methods.
        // This is useful for validating if one of these methods are used.
        if 'payloadFound {
          set errMessage = $$$FormatText("Incorrect http method: Dispatcher method '%1' cannot expect payload because it's configured to accept %2 HTTP method, which is not payloadable.", ..DispatchMethod, ..HttpMethod)
          return $$$ERROR($$$GeneralError, errMessage)
        }

        try {
          set value = $classmethod(dynamicClass, "%FromJSON", ..Payload)
          if 'shouldUnmarshall {
            set type = methodArgument.Type
            $$$NormalizeClassName(type)
            set expected = $$$GetPayloadType(type)
            set received = $$$GetPayloadType($classname(value))
            if expected '= received {
              return $$$ERROR($$$GeneralError, $$$FormatText("Payload type mismatch: expected %1 but received %2", expected, received))
            }
          }         
        } catch ex {
          return $$$ERROR($$$GeneralError, "Error while parsing the payload: the request did not send a valid JSON format.")
        }

        if isPersistable {
          // POST is default. So we check the object first.
          if ..HttpMethod = "PUT" || (..HttpMethod = "PATCH") {
            // PUT or PATCH usually send the id along with the URL, so we try to fetch from it or we fallback to object again.
            if resolvedId set value."__id__" = resolvedId
            if value."__id__" = "" {
              set value."__id__" = $get(..RouteParameters(methodArgument.Name), value."__id__")
              if value."__id__" = "" {
                // Still no ids, then no more hope. This request is doomed.
                return $$$ERROR($$$GeneralError, $$$FormatText("Cannot unmarshall payload to '%1': A PUT/PATCH request requires an identifier. E.g.: /route/1 or { __id__: 1 }.", methodArgument.Type))
              }
            }
          } else {
            // POST should always create. So remove __id__ from the payload.
            do value.%Remove("__id__")
          }
          set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal(methodArgument.Type, value, .instance, propertyFormatter)
          if $$$ISERR(sc) return sc
          set value = instance
        }
      } elseif isPersistable {
        // Type extends from %Persistent, but the match is expecting a GET.
        set value = $System.OBJ.OpenId(methodArgument.Type, $select(resolvedId '= "" : resolvedId, 1: value))
      } elseif methodArgument.Type = "%Boolean" {
        // true/false -> 1/0.
        set value = $$$BooleanToBinary(value)
      }

      set i%Arguments(argsProcessed) = value
    }
  }
  set i%Arguments = argsProcessed
  return sc
]]></Implementation>
</Method>

<Method name="MergeArguments">
<FormalSpec><![CDATA[&routeArguments:%String=0,&requestArguments:%String=0,*preArguments:%String=0,strictMode:%Boolean=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  // Conformity check:
  // 1 - No weak typing: All arguments must have a type provided.
  // 2 - Default values must be specified if optional.
  // 3 - Arity arguments must follow argumentnameN format, where N is an index.
  // 4 - Payloads must not have default values.
  // 5 - Each method must have only one payloadable type (%DynamicObject or DynamicArray).

  set argumentIndex = routeArguments
  set nextKeyIndex = 0
  set key = ""
  set preArguments = 0
  set methodArgumentsLength = ..MethodArguments.Count()
  set keysFound = ""  
  
  if $data(requestArguments("Error:ErrorCode", 1)) {
    return $$$EMBEDSC($$$ERROR($$$GeneralError, "A fatal error happened while trying to dispatch the result. Check this web application's configuration."), requestArguments("Error:ErrorCode", 1))
  } 

  for {
    set key = $order(requestArguments(key))
    quit:key=""
    
    set keyGroup = $$$KeyGroup(key)
    set $list(keysFound, *+1) = keyGroup
    set methodArgument = ..FindArgumentByAliasOrName(key)

    if '$isobject(methodArgument) {
      set methodArgument = ..FindArgumentByAliasOrName(keyGroup)
    }

    if '$isobject(methodArgument) {
      if strictMode {
        return $$$ERROR($$$GeneralError, keyGroup_" query parameter was not expected.")
      } else {
        continue
      }
    }

    // Don't depend on query parameter repeatance, because JavaScript cannot repeat object keys.
    // Instead the parameter should follow the pattern "paramN" which represents a sequence.
    set value = requestArguments(key, 1)

    // Checks if we have a sequenced query param.
    if key?.A1.2N && (key '= methodArgument.Name) {
      if methodArgument.Arity '= 1 {
        if strictMode {
          return $$$ERROR($$$GeneralError, $$$FormatText("'%1' was NOT expected to be sequential.", keyGroup))
        } else {
          continue
        }
      }
      if methodArgumentsLength > 1 {
        set argumentIndex = methodArgumentsLength + nextKeyIndex
      } else {
        set argumentIndex = nextKeyIndex + 1
      }

      set nextKeyIndex = nextKeyIndex + 1

      if nextKeyIndex '= $$$KeyIndex(key) {
        return $$$ERROR($$$GeneralError, $$$FormatText("'%1' was expected to be sequential.", keyGroup))
      }
    } else {
      set argumentIndex = methodArgument.Index
    }
    set preArguments(argumentIndex) = value
  }

  set missingArguments = ""
  set weakTypedArgs = ""

  if methodArgumentsLength > 0 {
    for m=1:1:methodArgumentsLength {
      set methodArgument = ..MethodArguments.GetAt(m)
      set isDynamic = ##class(Frontier.Types).IsDynamic(methodArgument.Type)
      set isPersistent = ##class(Frontier.Types).IsPersistent(methodArgument.Type)
      set shouldUnmarshal = (methodArgument.Parameters.GetAt("UNMARSHAL") = 1)
      set isPayloadArgument = isDynamic || (isPersistent && shouldUnmarshal)
      if methodArgument.Type = "" set $list(weakTypedArgs, *+1) = methodArgument.Name

      if 'methodArgument.HasDefaultValue && 'isPayloadArgument {
        set queryParameterName = $select(
          methodArgument.Alias '= "" : methodArgument.Alias,
          1: methodArgument.Name
        )

        if methodArgument.Arity {
          set queryParameterName = $$$KeyGroup(queryParameterName)
        }

        if '$lf(keysFound, queryParameterName) && '$data(routeArguments(queryParameterName)) {
          set $list(missingArguments, *+1) = queryParameterName
        }
      }
    }
  }

  if $ll(weakTypedArgs) > 0 {
    return $$$ERROR($$$GeneralError, "The following arguments are missing the type definition: "_$lts(weakTypedArgs, ", ")_".")
  }

  if $ll(missingArguments) > 0 {
    return $$$ERROR($$$GeneralError, "The following query parameters are missing: "_$lts(missingArguments, ", ")_".")
  }

  // Now we must merge the route arguments back, remember that they always take priority over query parameters.
  set routeKey = ""
  for {
    set routeKey = $order(routeArguments(routeKey), 1, routeValue)
    quit:routeKey=""

    set methodArgument =  ..FindArgumentByAliasOrName(routeKey)

    if '$isobject(methodArgument) {
      return $$$ERROR($$$GeneralError, $$$FormatText("Route parameter '%1' was not specified as an argument in the method '%2'.", routeKey, ..MethodDescriptor.Name))
    }
    set preArguments(..FindArgumentByAliasOrName(routeKey).Index) = routeValue
  }
  set preArguments = argumentIndex
  return $$$OK
]]></Implementation>
</Method>

<Method name="ResolveWhereId">
<Internal>1</Internal>
<FormalSpec>expression:%String,argumentName:%String,argumentType:%String,resolvedId:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define NextPlaceholder  $e(expression, $f(expression, ":") - 1, $f(expression, " ", $f(expression, ":")) - 2)

  set expression = expression_ " "
  set value = resolvedId
  set matchesWherePlaceholder = 0
  set sqlTemplate = "SELECT TOP 1 ID FROM %1 WHERE %2"

  set sqlParams = ""

  while expression [ ":" {
    set placeholder = $$$NextPlaceholder
    if '(placeholder?1":".AN) {
      return $$$ERROR($$$GeneralError, "Invalid where format. Expected 'field = :placeholder")
    }

    set parameterValue = ..RouteParameters($e(placeholder, 2, $l(placeholder)))
    if parameterValue = "" set parameterValue = $property(..Context.User, placeholder)
    if parameterValue = "" set parameterValue = $property(..Context.Data, placeholder)       

    if parameterValue = "" {
      return $$$ERROR($$$GeneralError, $$$FormatText("No id could be resolved source because '%1' could not be found or is empty.", name))
    }

    set sqlParams($i(i)) = parameterValue
    set sqlParams = i
    set expression = $replace(expression, placeholder, "?", 1)
  }

  set tableName = ##class(%Dictionary.CompiledClass).%OpenId(argumentType).SqlQualifiedNameQ
  set rows = ##class(%SQL.Statement).%ExecDirect(, $$$FormatText(sqlTemplate, tableName, expression), sqlParams...)
  do rows.%Next()

  if rows.%SQLCODE '= 0 {
    set sc = ##class(%Exception.SQL).CreateFromSQLCODE(rows.%SQLCODE, rows.%Message).AsStatus()
  } else {
    set resolvedId = rows.%Get("ID")  
  }
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Invoke">
<Internal>1</Internal>
<FormalSpec>*methodReturn="",*stack:%Stream.Object=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  set sc = $$$OK
  set io = $io
  merge methodArguments = ..Arguments
  set returnType = ..MethodDescriptor.ReturnType
  
  use $$$NULL
  
  new $estack   

  try {
    if methodArguments > 0 {
      set methodReturn = $classmethod(..DispatchClass, ..DispatchMethod, methodArguments...)
    } else {
      set methodReturn = $classmethod(..DispatchClass, ..DispatchMethod)
    }       
  } catch ex {
    do ##class(Frontier.Exception).CaptureStack(.stack)
    set sc = ex.AsStatus()
  }
  
  use io 
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter">
<Super>%RegisteredObject</Super>
<TimeCreated>64561,37245.906153</TimeCreated>

<Property name="Properties">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="Format">
<FormalSpec>propertyName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set storedFormatted = $get(i%Properties(depth, propertyName, "F"))
  if storedFormatted return storedFormatted
  
  set formattedName = ..OnFormat(propertyName)
  
  set i%Properties(depth, propertyName, "F") = formattedName
  set i%Properties(depth, formattedName, "N") = propertyName
  return formattedName
]]></Implementation>
</Method>

<Method name="FormatAllProperties">
<Internal>1</Internal>
<FormalSpec>collection:%ListOfObjects,depth:%Integer=1</FormalSpec>
<Implementation><![CDATA[
  for i=1:1:collection.Count() {
    set propertyName = collection.GetAt(i).Name
    if $extract(propertyName) '= "%" {
      do ..Format(collection.GetAt(i).Name, depth)
    }
  }
]]></Implementation>
</Method>

<Method name="OnFormat">
<FormalSpec>propertyName</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return propertyName
]]></Implementation>
</Method>

<Method name="Normalize">
<Final>1</Final>
<FormalSpec>formattedName:%String,depth:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return $get(i%Properties(depth, formattedName, "N"))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.CamelCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,42861.513845</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Camelify(propertyName)
]]></Implementation>
</Method>

<Method name="Camelify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	return $$$lcase($extract(propertyName, 1))_$extract(propertyName, 2, *)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.PropertyFormatter.SnakeCase">
<Super>Frontier.PropertyFormatter</Super>
<TimeCreated>64561,37293.153787</TimeCreated>

<Method name="OnFormat">
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	return ..Snakeify(propertyName)
]]></Implementation>
</Method>

<Method name="Snakeify">
<ClassMethod>1</ClassMethod>
<FormalSpec>propertyName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set snakedName = ""
	set nameLength = $length(propertyName)
	for i=1:1:nameLength {
		set c = $extract(propertyName, i)
		set n = $extract(propertyName, i+1)
		if c?1A = 1 && (c = $$$ucase(c) && (n '= $$$ucase(n)) && (i > 1)) set c = "_"_c
		set snakedName = snakedName_c
	}	
	return $$$lcase(snakedName)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter">
<IncludeCode>%occErrors</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64537,40798.410075</TimeCreated>

<Method name="%OnNew">
<FormalSpec>configuration:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  $$$ThrowStatus($$$ERROR($$$MethodNotImplemented, "%OnNew"))
]]></Implementation>
</Method>

<Method name="Setup">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  $$$ThrowStatus($$$ERROR($$$MethodNotImplemented, "Setup"))
]]></Implementation>
</Method>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  $$$ThrowStatus($$$ERROR($$$MethodNotImplemented, "Report"))
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Reporter.Log">
<IncludeCode>%occErrors</IncludeCode>
<Super>%Persistent,Frontier.Reporter</Super>
<TimeCreated>64225,38505.055952</TimeCreated>

<Parameter name="DEFAULTLIMIT">
<Default>5000</Default>
</Parameter>

<Property name="Path">
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Property name="Route">
<Type>%String</Type>
<Parameter name="MAXLEN" value="250"/>
</Property>

<Property name="IPAddress">
<Type>%String</Type>
</Property>

<Property name="HTTPMethod">
<Type>%String</Type>
</Property>

<Property name="HTTPStatus">
<Type>%String</Type>
</Property>

<Property name="Router">
<Type>%String</Type>
</Property>

<Property name="DispatchMethod">
<Type>%String</Type>
</Property>

<Property name="Error">
<Type>%Status</Type>
</Property>

<Property name="Arguments">
<Type>%List</Type>
</Property>

<Property name="Browser">
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Property name="TS">
<Type>%DateTime</Type>
</Property>

<Property name="IncludedCodes">
<Type>%List</Type>
<Internal>1</Internal>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="ExcludedCodes">
<Type>%List</Type>
<Internal>1</Internal>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="Limit">
<Type>%Integer</Type>
<Internal>1</Internal>
<InitialExpression>..#DEFAULTLIMIT</InitialExpression>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Method name="%OnNew">
<FormalSpec>configuration:%DynamicObject={{ "include": [($$$CacheError)] }}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if 'configuration.%IsDefined("limit") set ..Limit = ..#DEFAULTLIMIT
  else  set ..Limit = configuration.limit
  
  do ..PopulateList(configuration, "include")
  do ..PopulateList(configuration, "exclude")
  return $$$OK
]]></Implementation>
</Method>

<Method name="PopulateList">
<FormalSpec>configuration:%DynamicArray,key:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if 'configuration.%IsDefined(key) return $$$OK
  set iterator = configuration.%Get(key).%GetIterator()
  
  while iterator.%GetNext(,.value) { 
    if key = "include" set $list(i%IncludedCodes, *+1) = value 
    else  set $list(i%ExcludedCodes, +1) = value
  }
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateLog">
<FormalSpec>context:Frontier.Context</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set count = ..GetLogCount()  
  if count > ..Limit do ..Shift()
  
  set ..Path = context.Request.URL
  set ..Route = context.Route
  set ..Router = context.ClassName
  set ..HTTPMethod = context.Request.Method
  set ..HTTPStatus = context.Response.Status
  set ..DispatchMethod = context.Method
  set ..Browser = context.Request.GetCgiEnv("HTTP_USER_AGENT")
  set ..Arguments = $$SerializeArguments()
  set ..TS = $zdt($zts, 3)
  set ..IPAddress = context.Request.GetCgiEnv("HTTP_X_FORWARDED_FOR", context.Request.GetCgiEnv("REMOTE_ADDR"))
  set ..Error = context.Exception.AsStatus()
  
  return ..%Save()
  
SerializeArguments()
  set list = ""
  
  for i=1:1:context.ArgumentValues {
    set value = context.ArgumentValues(i)
    if $isobject(value) && value.%Extends("%Persistent") set value = value.%Id()
    set $list(list, *+1) = value
  }  
  return list
]]></Implementation>
</Method>

<Method name="GetLogCount">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set s = ##class(%SQL.Statement).%New()
  set sc = s.%PrepareClassQuery($classname(), "LogCount")
  if $$$ISERR(sc) quit sc
  
  set cursor = s.%Execute()
  set more = cursor.%Next(.sc)
  if $$$ISERR(sc) quit sc
  return cursor.%Get("AMOUNT")
]]></Implementation>
</Method>

<Method name="Shift">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<Implementation><![CDATA[
  set s = ##class(%SQL.Statement).%New()
  set sc = s.%Prepare("DELETE TOP 1 FROM FRONTIER_REPORTER.LOG")
  if $$$ISERR(sc) quit sc
  return s.%Execute()
]]></Implementation>
</Method>

<Query name="LogCount">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>  SELECT COUNT(ID) AS AMOUNT FROM FRONTIER_REPORTER.LOG</SqlQuery>
</Query>

<Method name="Report">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '$lf(i%IncludedCodes, context.Exception.Code) || $lf(i%ExcludedCodes, context.Exception.Code) return $$$OK
  return ..CreateLog(context)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.Reporter.LogD</DataLocation>
<DefaultData>LogDefaultData</DefaultData>
<IdLocation>^Frontier.Reporter.LogD</IdLocation>
<IndexLocation>^Frontier.Reporter.LogI</IndexLocation>
<StreamLocation>^Frontier.Reporter.LogS</StreamLocation>
<Data name="LogDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Path</Value>
</Value>
<Value name="3">
<Value>IPAddress</Value>
</Value>
<Value name="4">
<Value>HTTPMethod</Value>
</Value>
<Value name="5">
<Value>HTTPStatus</Value>
</Value>
<Value name="6">
<Value>Router</Value>
</Value>
<Value name="7">
<Value>DispatchMethod</Value>
</Value>
<Value name="8">
<Value>ErrorData</Value>
</Value>
<Value name="9">
<Value>Arguments</Value>
</Value>
<Value name="10">
<Value>Browser</Value>
</Value>
<Value name="11">
<Value>Route</Value>
</Value>
<Value name="12">
<Value>TS</Value>
</Value>
<Value name="13">
<Value>CodesToCapture</Value>
</Value>
<Value name="14">
<Value>IncludedCodes</Value>
</Value>
<Value name="15">
<Value>ExcludedCodes</Value>
</Value>
<Value name="16">
<Value>Error</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Frontier.Reporter.Manager">
<Description>
This class allows the routers to add reporters and iterates over each calling the Report method.
For each call the context object is sent to provide full disclosure regarding the current status.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64538,33046.39632</TimeCreated>

<Property name="Reporters">
<Description>
This holds the list of the reporters added by using the AddReporter method.</Description>
<Type>Frontier.Reporter</Type>
<Collection>list</Collection>
<Private>1</Private>
</Property>

<Property name="Context">
<Description>
This holds the current instance of the class Frontier.Context.</Description>
<Type>Frontier.Context</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>context:Frontier.Context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Context = context   
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddReporter">
<Description>
Adds a reporter to the queue which is called whenever an uncaught exception is detected.</Description>
<FormalSpec>reporter:Frontier.Reporter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..Reporters.Insert(reporter)
]]></Implementation>
</Method>

<Method name="Report">
<Description>
Iterates over the queue calling the Report method for each. Each call is implementation dependent.</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if '$isobject(..Context.Exception) return $$$OK
  
  try {
    for i=1:1:..Reporters.Count() {
      set reporter = ..Reporters.GetAt(i)
      set sc = $$$ADDSC(sc, reporter.Report(..Context))
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Router">
<IncludeCode>%occErrors,%occStatus,frontier</IncludeCode>
<Super>%CSP.REST</Super>
<TimeCreated>64492,32085.189445</TimeCreated>
<DependsOn>Frontier.Schema.Util</DependsOn>

<Parameter name="CHARSET">
<Default>utf-8</Default>
</Parameter>

<Parameter name="CONTENTTYPE">
<Default>application/json</Default>
</Parameter>

<Parameter name="CONVERTINPUTSTREAM">
<Default>1</Default>
</Parameter>

<Method name="Page">
<ClassMethod>1</ClassMethod>
<FormalSpec>skipheader:%Boolean=1</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  $$$QuitOnError(..InitializeContext(.%frontier))    
  
  #dim sc As %Status = $$$OK
  #dim e As %Exception.AbstractException
  
  #dim redirected As %Boolean
  #dim originRoutine, url As %String = ""
  #dim %response As %CSP.Response
  #dim %frontier As Frontier.Context
      
  try {        
    set %response.CharSet = %frontier.Encoding 
    do %response.MatchLanguage() 
    
    // Gets the current redirection status. ON or OFF.
    set redirected = ##class(%Library.Device).ReDirectIO()
            
    // Gets the routine before attempting to redirect. Used to restore original direction.
    set originRoutine = $System.Device.GetMnemonicRoutine()
    
    // Set the web server routine to handle the request.
    use $io::("^%SYS.cspServer2")
      
    // Redirect write calls to the routine above.
    do ##class(%Library.Device).ReDirectIO(1)
      
    // Check if the application has a dispatch class.
    if $$$GetSecurityApplicationsDispatchClass(%request.AppData) = "" {
      set %response.Status = ..#HTTP500INTERNALSERVERERROR
      $$$ThrowStatus($$$ERROR($$$GeneralError, "Application has no dispatch class."))
    }
      
    // Attempt to get the URL.
    Set url = $Get(%request.CgiEnvs("CSPLIB"))      
    if url = "" Set url = %request.URL           
            
    // Query parameters are dealt later. So for now it's stripped off.
    set url = $piece(url, "?")
      
    // Delegate the handling to the appropriate router.
    $$$ThrowOnError(..DispatchRequest(url, %request.Method))
      
  } catch (e) {
    write ##class(Frontier.Exception).ToDynamicObject(e).%ToJSON()
    set %response.OutputSessionToken = 0
    set sc = e.AsStatus()
  }
          
  // Must write something to trigger redirection and write the headers.
  write ""
  
  // If we have a redirection.
  If redirected {       
    // Then restore it to the original.
    use $io::("^"_originRoutine)
      
    // And switch the redirection back to what it was originally.
    do ##class(%Library.Device).ReDirectIO(1)
  }
      
  return $$$OK
]]></Implementation>
</Method>

<Method name="InitializeContext">
<ClassMethod>1</ClassMethod>
<FormalSpec>*context:Frontier.Context=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  new %frontier
  set context = ##class(Frontier.Context).%New(%session, %request, %response)
  set %session.Data("%frontier") = context
  return $$$OK
]]></Implementation>
</Method>

<Method name="Login">
<ClassMethod>1</ClassMethod>
<FormalSpec>skipheader:%Boolean=1</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..Page(skipheader)
]]></Implementation>
</Method>

<Method name="DispatchMap">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>index:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
     
  // Don't try to generate patterns if the target class is Frontier.Router.
  if %compiledclass.Name = "Frontier.Router" return $$$OK   
  
  $$$ThrowOnError(##class(Frontier.Schema.Util).Parse(%compiledclass.Name, .routes))
  $$$ThrowOnError(##class(Frontier.Schema.Util).GeneratePatterns(routes, %compiledclass.Name, .patterns))  
  
  set patternIndex = ""
  
  for {
    set patternIndex = $order(patterns(patternIndex), 1, pattern)
    quit:patternIndex=""
    
    set patternString = ""
    set patternType = $lg(pattern, 1)
    
    for i=1:1:$ll(pattern) {
      set item = $lg(pattern, i)      
      if patternType = "M" {
        if i = 4 set $list(patternString, *+1) = "$lfs("_$$MakeString(item)_")"
        else  set $list(patternString, *+1) = """"_$lg(pattern, i)_""""
      } elseif patternType = "R" {
        if i = 6 set $list(patternString, *+1) = "$lfs("_$$MakeString(item)_")"
        else  set $list(patternString, *+1) = """"_$lg(pattern, i)_""""
      }
    }
    
    do %code.WriteLine("  if index = "_patternIndex_ " return $lb("_$lts(patternString)_")")
  }
  
  // Prevents the dispatch from throwing <OBJECT DISPATCH> if route is not defined.
  // This will make the engine return "Resource not found" instead.
  do %code.WriteLine("  return """"")  
  return $$$OK
  
MakeString(list)
  set stringList = ""
  for li=1:1:$ll(list) {
    set item = $lg(list, li)
    set $piece(stringList, ",", li) = ""_item_""
  }
  return """"_stringList_""""
]]></Implementation>
</Method>

<Method name="DispatchRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[url:%String,httpMethod:%String,forwarded:%Boolean="",routeParameters:%String=0,&matches:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set httpStatus = $case(httpMethod, "POST": ..#HTTP201CREATED, : ..#HTTP200OK)
  set isResourceMatch = 0
  set isHttpMethodMatch = 0
  
  set %frontier.Method = "DispatchRequest"
  
  // Normalize the HTTP method.
  set httpMethod = $$$ucase(httpMethod)
  
  // Prevents attempts to dispatch from this class itself.
  $$$QuitOnError($$ValidateRouteOrigin)
  
  try {       
    set resolvedUrl = $$ResolveUrl(url)      
    
    while $$NextDispatchMap(.index, .mapEntry) {
      set matchType = $list(mapEntry, 1)
      set urlExpression = $list(mapEntry, 2)      
      set matcher = ##class(%Regex.Matcher).%New(urlExpression)              
      
      // If there's no match, skip to the next candidate.
      if matcher.Match(resolvedUrl) {
        set isResourceMatch = 1
        set resourceScope = $lg(mapEntry, 7)        
        set strictRouteParameters = $lg(mapEntry, 9, 1)              
        
        // Method is not an OPTIONS, neither one that should match the schema.
        if httpMethod '= "OPTIONS" && (httpMethod '= $list(mapEntry, 3) && (matchType = "R")) continue
        
        // OnSetup must be run even if the Router forwards to another one.
        set %frontier.Method = "OnSetup"
        $$$ThrowOnError(..OnSetup())
        
        set %frontier.RequestURL = %request.URL
        set %frontier.Route = urlExpression
        set %frontier.ClassName = $classname()                                      
        
        // Does this router have CORS configured?
        if %frontier.CORS.IsActive() {
          if httpMethod = "OPTIONS" {          
            do %frontier.CORS.CheckPreflight()
            return $$$OK
          } else {
            // Clears any configuration set by another router.
            do %frontier.CORS.Unset()
            // Applies the configuration defined by the current router.
            do %frontier.CORS.Set()
          }
        }                        
        
        if matcher.GroupCount && strictRouteParameters {
          do FetchRouteParameters(.routeParameters)
          merge %frontier.RouteParameters = routeParameters
        } elseif 'strictRouteParameters {
          // Cannot merge FROM ReadOnly property. Are you serious?!
          do ManualGroupMerge(matcher)
        }       
        
        // Found the router that should handle the request.
        if matchType = "R" {           
          set useAuth = $lg(mapEntry, 8)
          set authStrategy = $lg(mapEntry, 11)                                         
                   
          if useAuth && %frontier.AuthenticationManager.HasStrategies() {
            // Run pending authentication strategies. If one passes, then the implementation
            // is responsible for filling the user object.
            if authStrategy = "" {
              $$$ThrowOnError(%frontier.AuthenticationManager.Verify(.user, resourceScope))
            } else {
              // Auth is enabled AND the route requests for a specific strategy to be used.              
              $$$ThrowOnError(%frontier.AuthenticationManager.VerifyUsing(authStrategy, .user, resourceScope))
            }
            
            if '%frontier.AuthenticationManager.Verified {
              set %response.Status = ..#HTTP401UNAUTHORIZED
              $$$ThrowOnError($$$ERROR($$$GeneralError, "You must be authenticated to access this resource."))
            }
            
            set %frontier.User = user                       
          
            // Don't let the user access this resource if this request doesn't match it.           
            if '%frontier.AuthenticationManager.CheckResourceScope(resourceScope, user.scope) {
              if %response.Status = ..#HTTP200OK || (%response.Status = ..#HTTP201CREATED) {
                set %response.Status = ..#HTTP403FORBIDDEN
              }
              $$$ThrowOnError($$$ERROR($$$GeneralError, "This account has not enough privilege to access this resource."))
            }                                            
          }                   
          
          set %frontier.Method = "OnDataSet"
          $$$ThrowOnError(..OnDataSet(%frontier.Data))
          
          set dispatchMethod = $listget(mapEntry, 4)
          set dispatchClass = $classname()
          
          // If the Call has : then it's calling a method outside this router.
          if dispatchMethod [ ":" {
            set dispatchClass = $piece(dispatchMethod, ":", 1)    
            set dispatchMethod = $piece(dispatchMethod, ":", 2)
          }
          
          set %frontier.ClassName = dispatchClass
          set %frontier.Method = dispatchMethod
          
          // Parse dispatchMethod retrieving its metadata.
          set publicMethod = ##class(Method).%New(%frontier, .routeParameters, .matches)
          merge methodArguments = publicMethod.Arguments
          
          if matches = "" merge %frontier.RouteParameters = routeParameters
          else  merge %frontier.RouteParameters = matches
          
          merge %frontier.ArgumentValues = publicMethod.Arguments
          
          // Executes the method and retrives its value. The method MUST return a value or a 
          // <COMMAND> will be issued.
          set sc = publicMethod.Invoke(.methodReturn, .stack)
          set %frontier.Stack = stack          
          
          $$$ThrowOnError(sc)
          
          // Now we serialize and output the result back to the agent.
          $$$ThrowOnError(..DispatchResponse(methodReturn))
          
          // Finishes the request.
          return $$$OK
        } elseif matchType = "M" {
          // We're reading a map, Map patterns already include everything needed to forward the
          // correct URL part, as long as we always consider targeting its the last match.
          set forwardingClass = $listget(mapEntry, 3)
          
          if forwardingClass = $classname() {
            $$$ThrowOnError($$$ERROR($$$GeneralError, $$$FormatText("Dispatcher class %1 is attempting to forward %2 to itself.", forwardingClass, resolvedUrl)))
          }                    
          
          set resolvedUrl = "/"_matcher.Group(matcher.GroupCount)
                    
          // Re-invoke this method using the class that this map forwards the request to. 
          $$$ThrowOnError($classmethod(forwardingClass, "DispatchRequest", resolvedUrl, httpMethod, 1, .routeParameters, .matches))
          // Maps are also a match, so abort everything else and let the forwarding class handle the rest.
          return $$$OK
        }
      }      
    }
    
    // Didn't have a match for the resource, report not found.
    if isResourceMatch '= 1 || (isHttpMethodMatch '= 1) {
      set %response.Status = ..#HTTP404NOTFOUND
      $$$ThrowOnError($$$ERROR($$$GeneralError, "Resource not found."))
    }
    
    return $$$OK       
  } catch ex {    
    set exceptionPayload = ..HandleException(ex)
    do ##class(Frontier.Dynamic.Serializer).Serialize(exceptionPayload, 1, %frontier.PropertyFormatter)
  }
  return $$$OK
  
ResolveUrl(url)
  if 'forwarded return "/"_$extract(url, $length(%request.Application)+1,*)
  return url
  
NextDispatchMap(index=0, mapEntry="", dispatchClass="")  
  set index = index + 1
  set mapEntry = ..DispatchMap(index)
  return (mapEntry '= "")  
  
FetchRouteParameters(routeParameters=0)  
  if matchType = "R" {
    if httpMethod '= $lg(mapEntry, 3) quit
    set max = $ll($lg(mapEntry,6))
    set storedUrl = $lg(mapEntry, 10) 
  } elseif matchType = "M" { 
    set max = $ll($lg(mapEntry,4))
    set storedUrl = $lg(mapEntry, 6) 
  }
  
  if strictRouteParameters { 
    for p=1:1:max {
      if matchType = "R" {
        set routeParameterName = $lg($lg(mapEntry,6), p)
        if '$data(routeParameters(routeParameterName)) {
          set routeParameters(routeParameterName) = matcher.Group(p)
          set routeParameters = routeParameters + 1
        }
      } elseif matchType = "M" {      
        set routeParameterName = $lg($lg(mapEntry, 4), p)      
        set routeParameters(routeParameterName) = $piece(matcher.Group(p), "/")
        set routeParameters = routeParameters + 1
      }
    }
  } else {
    set storedUrlMatcher = ##class(%Regex.Matcher).%New(storedUrl)
    set storedUrlMatcher.Text = resolvedUrl
    do storedUrlMatcher.Locate()
    for p=1:1:storedUrlMatcher.GroupCount {
      set matchIndex = $order(matches(""), -1) + 1    
      set matches(matchIndex) = storedUrlMatcher.Group(p)
      set matches = matchIndex
    }
  }
  quit
 
ManualGroupMerge(matcher)
  set %frontier.Matches = matcher.GroupCount
  for i=1:1:matcher.GroupCount {
    set %frontier.Matches(i) = matcher.Group(i)
  }
 quit
 
ValidateRouteOrigin()
  if $classname() = "Frontier.Router" {
    return $$$ERROR($$$GeneralError, "Invalid route origin: did you configure Frontier.Router as 'Dispatch Class' instead?")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="HandleException">
<ClassMethod>1</ClassMethod>
<FormalSpec>exception:%Exception.AbstractException</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set responseCode = +$piece(%response.Status, " ")
    
  // There might have cases where we get a success HTTP status, we need to normalize forcing it to be a 500 error.
  if responseCode < 300 {
    set %response.Status = ..#HTTP500INTERNALSERVERERROR
    set responseCode = 500
  }
    
  set exceptionJSON = ##class(Exception).ToDynamicObject(exception)
  set exceptionJSON.responseCode = responseCode  
    
  set %frontier.Exception = exception  
  set %response.OutputSessionToken = 0
  
  return exceptionJSON
]]></Implementation>
</Method>

<Method name="DispatchResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>returnedData:%CacheString</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  set response = {}  
  
  if $isobject(returnedData) {
    set type = $classname(returnedData)    
    $$$QuitOnError($$AssertClassNamespaceAvailability(type))    
    
    if ##class(Frontier.Types).IsStream(type) && %frontier.IsRaw() {
      return returnedData.OutputToDevice()
    }    
    
    set isCollection = ##class(Types).IsCollection(type)
    set isSQLProvider = ##class(Types).IsSQLProvider(type)
    set isStream = ##class(Types).IsStream(type)
    set isDynamic = ##class(Types).IsDynamic(type)
    set isSystemType = ($extract(type) = "%")
    set isMarshallable = isCollection || isDynamic || isStream || isSQLProvider || ('isSystemType && ##class(Types).IsInstantiable(type))
    if isMarshallable {
      if isStream {
        set stream = returnedData set returnedData = response
        set response.content = stream
      } elseif isSQLProvider {
        set provider = returnedData
        set response.results = provider
      } else {
        $$$QuitOnError(##class(Frontier.Dynamic.Marshaller).MarshalDirect(returnedData, .response))
      }
    } elseif returnedData.%IsA("Frontier.Dynamic.Marshaller") {
      $$$QuitOnError(returnedData.Marshal(.response))
    } else {
      return $$$ERROR($$$GeneralError, "Cannot serialize system class instances.")
    }
  } elseif %frontier.IsJSON() {
    set response.result = returnedData  
  } else {
    write returnedData
    return $$$OK
  }  
  
  // We must use a custom serializer because the current %ToJSON implementation cannot serialize
  // mixed instances.
  if %frontier.DirectWrite = 1 {
    return ##class(Frontier.Dynamic.Serializer).Serialize(response, 1, %frontier.PropertyFormatter)
  } else {
    $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(.stream, response, 1, %frontier.PropertyFormatter))
    do stream.OutputToDevice()
  }
  return $$$OK

AssertClassNamespaceAvailability(className)
  if '##class(%Dictionary.CompiledClass).%OpenId(className) {
    return $$$ERROR($$$GeneralError, $$$FormatText("The object is an instance of %1 that is not available in the namespace %2.", className, $namespace))
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="OnDataSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<XData name="Schema">
<Description>
This is the Schema which defines the form of the dispatch map</Description>
<Internal>1</Internal>
<Data><![CDATA[
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" >

<xs:element name="Routes">
<xs:complexType>
<xs:choice  minOccurs="0" maxOccurs="unbounded">
<xs:element name="Route">
<xs:complexType>
<xs:attribute name="Url"    type="string" use="required"/>
<xs:attribute name="Method" type="string" use="required"/>
<xs:attribute name="Call" type="call" use="required"/>
<xs:attribute name="Cors" type="xs:boolean" use="optional" default="false"/>
<xs:attribute name="Scope" type="string" use="optional" default="false"/>
<xs:attribute name="UseAuth" type="xs:boolean" use="optional" default="true"/>
<xs:attribute name="AuthStrategy" type="xs:string" use="optional"/>
<xs:attribute name="Strict" type="xs:boolean" use="optional" default="true"/>
</xs:complexType>
</xs:element>
<xs:element name="Map">
<xs:complexType>
<xs:attribute name="Prefix" type="string" use="required"/>
<xs:attribute name="Forward" type="forward" use="required"/>
<xs:attribute name="Strict" type="xs:boolean" use="optional" default="true"/>
</xs:complexType>
</xs:element>
</xs:choice>
</xs:complexType>
</xs:element>

<xs:simpleType name="call">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*:)?[%]?[a-zA-Z][a-zA-Z0-9]*"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="forward">
<xs:restriction base="xs:string">
<xs:pattern value="([%]?[a-zA-Z][a-zA-Z0-9]*(\.[a-zA-Z][a-zA-Z0-9]*)*)"/>
</xs:restriction>
</xs:simpleType>

<xs:simpleType name="string">
<xs:restriction base="xs:string">
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>

</xs:schema>
]]></Data>
</XData>
</Class>


<Class name="Frontier.SQL">
<Super>%RegisteredObject</Super>
<TimeCreated>64531,35746.997056</TimeCreated>

<Method name="Prepare">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Implementation><![CDATA[  return ##class(Frontier.SQL.Provider).%New(SQLExpression)
]]></Implementation>
</Method>

<Method name="InlineQueryBuilder">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[  return ##class(Frontier.SQL.InlineQueryBuilder).%New(className)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.InlineQueryBuilder">
<Description><![CDATA[
This class can be used to query and return a set of SQL results.
You'll probably never have to call it outside the context created by Frontier.

The filter format can be divided into two formats:

Simple: fieldnameA_operation:value;fieldnameB_operation:value
Composited: _or:[fieldnameA_operation:value,fieldNameA_operation:value]

Supported operations:

field_eq:value field = value
field_neq:value field <> value
field_gt:value field > value
field_gte:value field >= value
field_lt:value field < value
field_lte:value field <= value
field_sw:value field %STARTSWITH value
field_nsw:value field NOT %STARTSWITH value
field_ct:value field [ value
field_nct:value field '[ value
field_lk:%value% field LIKE '%value%'
field_nlk:%value% field NOT LIKE '%value%'
field_il:v,a,l,u,e  field %INLIST($lfs('v,a,l,u,e'))
field_nil:v,a,l,u,e field NOT %INLIST($lfs('v,a,l,u,e'))
field_is:null field IS NULL
field_isn:null field IS NOT NULL
field_bt:0,5 field BETWEEN 0 and 5
field_nbt:0,5 field NOT BETWEEN 0 and 5
field_in:v,a,l,u,e field IN('v','a','l','u','e')
field_nin:v,a,l,u,e field NOT IN('v','a','l','u','e')
field:value is translated to field_eq:value

The method "OrderBy" can be used to sort the fields, the syntax is the same as you would use with SQL.
The method "Fields" can be used to select the fields you want include in the results.

Note: Both methods will not allow the usage of dubious characters that could into a destructive command.
Only alphanumeric inputs are allowed with a few symbols, they are: underscore, dot, asterisk and comma.

Example of usage:

set builder = %frontier.SQL.InlineQueryBuilder("Frontier.UnitTest.Fixtures.Student")

if page '= "" && (limit '= "") do builder.Pagination(page, limit)
if orderBy '= "" do builder.OrderBy(orderBy)
if groupBy '= "" do builder.GroupBy(groupBy)
if filter '= "" do builder.Filter(filter)

return builder.Build().Provide()]]></Description>
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>65024,58346.572175</TimeCreated>

<Property name="Filter">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="OrderBy">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="PaginationParameters">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="SelectedFields">
<Type>%String</Type>
<InitialExpression>"*"</InitialExpression>
<Private>1</Private>
</Property>

<Property name="BuildStatus">
<Type>%Status</Type>
<InitialExpression>1</InitialExpression>
<Private>1</Private>
</Property>

<Property name="For">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Result">
<Type>%String</Type>
</Property>

<Property name="GroupBy">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%Parameters = 0
  set ..For = className
  return $$$OK
]]></Implementation>
</Method>

<Method name="Filter">
<FormalSpec>filter</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[
  set ..Filter = filter
  return $this
]]></Implementation>
</Method>

<Method name="Pagination">
<FormalSpec>page:%Integer,limit:%String</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[
  
  set ..PaginationParameters = $lb(page, limit)
  return $this
]]></Implementation>
</Method>

<Method name="Fields">
<FormalSpec>fields:%String</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[
  if fields = "" set ..SelectedFields = "*" 
  else  set ..SelectedFields = ..SanitizeInput(fields)
  return $this
]]></Implementation>
</Method>

<Method name="OrderBy">
<FormalSpec>orderBy:%String</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[
  set ..OrderBy = "ORDER BY "_..SanitizeInput(orderBy)
  return $this
]]></Implementation>
</Method>

<Method name="GroupBy">
<FormalSpec>groupBy:%String</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[  set ..GroupBy = "GROUP BY "_..SanitizeInput(groupBy)
]]></Implementation>
</Method>

<Method name="SanitizeInput">
<FormalSpec>input:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $zstrip(input, "*E'N'A", "", "_.*, ")
]]></Implementation>
</Method>

<Method name="WithPagination">
<FormalSpec>where:%String="",tableName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if ..PaginationParameters = "" return ""
  
  set page = $lg(..PaginationParameters, 1)
  set limit = $lg(..PaginationParameters, 2)
  set offset = (page * limit) - (limit - 1)
  set limit = page * limit
  
  set args = 8
  set args(1) = limit
  set args(2) = ..SelectedFields
  set args(3) = tableName
  set args(4) = where  
  set args(5) = ..GroupBy
  set args(6) = ..OrderBy
  set args(7) = offset
  set args(8) = limit
  
  return $$$FormatText("SELECT *, %VID AS row FROM (SELECT TOP %1 %2 FROM %3 %4 %5 %6) WHERE %VID BETWEEN %7 AND %8", args...)
]]></Implementation>
</Method>

<Method name="CheckPaginationParameters">
<Private>1</Private>
<Implementation><![CDATA[
     
  #define AppendStatus(%newStatus) set sc = $$$ADDSC(sc, $$$ERROR($$$GeneralError, %newStatus))  
  
  set sc = $$$OK
  set page = $lg(..PaginationParameters)
  set limit = $lg(..PaginationParameters, 2)
  
  if '$isvalidnum(page) $$$AppendStatus("Page must be a number.")
  if page = 0 $$$AppendStatus("Page must page must start from 1.")
  if page < 0 $$$AppendStatus("Page must be a positive number.")
  
  if '$isvalidnum(page) $$$AppendStatus("Limit must be a number.")
  if page = 0 $$$AppendStatus("Limit must start from 1.")
  if page < 0 $$$AppendStatus("Limit must be a positive number.")
  
  if $$$ISERR(sc) return $$$EMBEDSC($$$ERROR($$$GeneralError, "Invalid pagination parameters."), sc)
  return sc
]]></Implementation>
</Method>

<Method name="CreateWHEREStatement">
<FormalSpec>filter:%String=..Filter,type:%String=" AND ",whereStatement:%String="WHERE "</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 
  if filter = "" return ""  
  set where = ""  
  set l = $length(filter, ";")
  
  for i=1:1:l {
    set condition = $piece(filter, ";", i)
    // If ] is found then the builder is trying to capture the same condition, so skip it.   
    if condition?.ANP1"]" = 1 continue
    if $extract(condition, 1, 3)?1"_"1(1"or",1"an") = 1 {
      set conditionType = $$$ucase($extract(condition, $find(condition, "_"), $find(condition, ":") - 2))
      set expression = $$HandleCompositeCondition(condition, conditionType)
    } else {
      set expression = $$HandleSingleCondition(condition)
    }    
    set $list(where, *+1) = expression    
  }
  
  if $ll(where) '= 0 set where = whereStatement_"("_$lts(where, " "_type_" ")_")"
  return where
  
 
HandleSingleCondition(condition)
  // Normalizes field:value to field_eq:value.
  if condition '[ "_" set condition = $piece(condition, ":")_"_eq:"_$piece(condition, ":", 2, *)
  set field = $$$trim($piece(condition, "_"))
  
  // Deep access: a.b = a->b in Cach SQL.
  if field [ "." set field = $replace(field, ".", "->")
  
  set op = $$$trim($piece($piece(condition, "_", 2, 2), ":", 1))
  set value = $piece(condition, ":", 2, *)
  
  set exp = ..TransformFilter(field, value, op)
  return exp
    
HandleCompositeCondition(condition, conditionType)  
  set start = $find(filter, condition) - ($length(condition) - 5)
  set end = $find(filter, "]", start) - 2
  set setStart = start
  if conditionType = "AND" set setStart = start + 1  
  set composition = $extract(filter, setStart, end)
  return ..CreateWHEREStatement(composition, conditionType, "")
]]></Implementation>
</Method>

<Method name="Build">
<FormalSpec>*sc:%Status=$$$OK,*expression:%String="",*parameters:%String=""</FormalSpec>
<ReturnType>Frontier.SQL.InlineQueryBuilder</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  merge parameters = i%Parameters
  
  set ..BuildStatus = sc
  
  try {
    if ..PaginationParameters '= "" $$$ThrowOnError(..CheckPaginationParameters())
    if ..For = "" $$$ThrowStatus($$$ERROR($$$GeneralError, "For method not called."))
    
    set cclass = ##class(%Dictionary.CompiledClass).%OpenId(..For)
    if cclass = "" $$$ThrowStatus($$$ERROR($$$GeneralError, $$$FormatText("Class '%1' does not exist.", ..For)))
    set tableName = cclass.SqlQualifiedNameQ
  
    if tableName = "" $$$ThrowStatus($$$ERROR($$$GeneralError, "Class cannot be projected to SQL."))
    
    set where = ..CreateWHEREStatement()
    set paginatedQuery = ..WithPagination(where, tableName)
    set expression = paginatedQuery
    
    if expression = "" {
      set expression = $$$FormatText("SELECT %1 FROM %2 %3 %4 %5", ..SelectedFields, tableName, where, ..GroupBy, ..OrderBy)
    }
    
    set ..Result = expression    
  } catch ex {
    set ..BuildStatus = ex.AsStatus()
    set sc = ..BuildStatus
  }
  return $this
]]></Implementation>
</Method>

<Method name="TransformFilter">
<FormalSpec>filter:%String,value,op:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set expression = ""
  set singleVarOpTypes = $lb("eq", "ne", "gt", "gte", "lt", "lte", "sw", "nsw", "ct", "nct", "lk", "nlk", "is", "isn", "il", "nil")
  
  if $lf(singleVarOpTypes, op) > 0 {
    if op = "eq" set expression = filter_" = ?"
    if op = "ne" set expression = filter_" <> ?"
    if op = "gt" set expression = filter_" > ?"
    if op = "gte" set expression = filter_" >= ?"
    if op = "lt" set expression = filter_" < ?"
    if op = "lte" set expression = filter_" <= ?"
    if op = "sw" set expression = filter_" %STARTSWITH ? "
    if op = "nsw" set expression = "NOT "_filter_" %STARTSWITH ?"
    if op = "ct" set expression = filter_" [ ?"
    if op = "nct" set expression = filter_" '[ ?"
    if op = "lk" set expression = filter_" LIKE ?"
    if op = "nlk" set expression = filter_" NOT LIKE ?"
    if op = "il" set expression = filter_" %INLIST ?" set value = $lfs(value)
    if op = "nil" set expression = filter_" NOT %INLIST ?" set value = $lfs(value)
    
    if op '= "is" && (op '= "isn") {
      do AddParameter(value)
    } elseif value = "null" {
      set null = $$$ucase(value)
      if op = "is" set expression = filter_" IS "_null
      if op = "isn" set expression = filter_" IS NOT "_null
    }
  } elseif op = "bt" || (op = "nbt") {
    set not = ""
    if op = "nbt" set not = "NOT"
    set left = $piece(value, ",", 1, 1)
    set right = $piece(value, ",", 2, 2)
    set expression = filter_not_" BETWEEN ? AND ? "
    do AddParameter(left)
    do AddParameter(right)
  } elseif op = "in" || (op = "nin") {
    set not = ""
    set phs = ""
    set l = $length(value, ",")
    for i=1:1:l  do AddParameter($piece(value, ",", i)) set $list(phs, *+1) = "?"
    set expression = filter_not_" IN ("_$lts(phs)_")"
  }
  
  return expression
  
AddParameter(newparam)
  set i%Parameters = i%Parameters + 1
  set i%Parameters(i%Parameters) = newparam
]]></Implementation>
</Method>

<Method name="Provide">
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  
  // Must check if the building phase had any errors.
  $$$ThrowOnError(..BuildStatus)
  
  set params = ""
  merge params = i%Parameters
  set provider = ##class(Frontier.SQL.Provider).%New(..Result)
  if params > 0 $$$ThrowOnError(provider.Parameters(params...))
  return provider
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Provider">
<IncludeCode>frontier</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64531,36463.732591</TimeCreated>

<Property name="QueryClass">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="SQL">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="QueryParameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Mode">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="Error">
<Type>%Status</Type>
<Internal>1</Internal>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="StatementExecuted">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Results">
<Type>%SQL.StatementResult</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Metadata">
<Type>%SQL.StatementMetadata</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>statement:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if statement '= "" do ..ResolveStatement(statement)
  return $$$OK
]]></Implementation>
</Method>

<Method name="Parameters">
<FormalSpec>params...:%String</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(..SetQueryParameters(params...))
  return $this
]]></Implementation>
</Method>

<Method name="Mode">
<FormalSpec>selectMode:%Integer=0</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set ..Mode = selectMode
  return $this
]]></Implementation>
</Method>

<Method name="Execute">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..StatementExecuted = 1
  return ..CreateAndExecute()
]]></Implementation>
</Method>

<Method name="ResolveStatement">
<FormalSpec>SQLExpression:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  if $length(SQLExpression, ":") = 2 {   
    set ..QueryClass = $piece(SQLExpression, ":")
    set ..QueryName = $piece(SQLExpression, ":", 2)
  } elseif $extract($$$ucase($$$trim(SQLExpression)), 1, 6) = "SELECT" {
    set ..SQL = SQLExpression
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="SetQueryParameters">
<FormalSpec>parameters...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if parameters '= 0 && 'parameters?.N && ($order(parameters(""), -1) '= parameters) {
    return $$$ERROR($$$GeneralError, "Invalid parameter spec.")
  }
  
  kill i%QueryParameters
  set i%QueryParameters = parameters
  
  merge i%QueryParameters = parameters
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateAndExecute">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  merge parameters = ..QueryParameters
  
  set statement = ##class(%SQL.Statement).%New()
  set statement.%SelectMode = ..Mode  
  
  if ..QueryClass '= "" && (..QueryName '= "") {
    set sc = statement.%PrepareClassQuery(..QueryClass, ..QueryName)    
  } elseif ..SQL '= "" {
    set sc = statement.%Prepare(..SQL)
  }
  
  set i%Metadata = statement.%Metadata 
  
  $$$QuitOnError(sc)
  set results = statement.%Execute(parameters...)
  
  if results.%SQLCODE '= 0 {
    set sc = ##class(%Exception.SQL).CreateFromSQLCODE(results.%SQLCODE, results.%Message).AsStatus()
  }
  set i%Results = results
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SQL.Serializer">
<Super>Frontier.AbstractSerializer</Super>
<TimeCreated>64539,50921.256251</TimeCreated>

<Method name="Serialize">
<ClassMethod>1</ClassMethod>
<FormalSpec>results:%SQL.Statement,metadata:%SQL.StatementMetadata,depth:%Integer=1,propertyFormatter:Frontier.PropertyFormatter=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
     
  set sc = $$$OK
  $$$QuitOnError(..FetchColumnMetadatas(metadata, .columnMetadata))  
  
  set data = ##class(%Stream.GlobalCharacter).%New()
  
  write "["
  
  set itemComma = ""
  set propertyComma = ""
  
  try {               
    while results.%Next(.sc) {
      $$$ThrowOnError(sc)
      
      write itemComma
      
      set itemComma = ","
      set propertyComma = ""
      
      write "{"         
      
      for c=1:1:columnMetadata {
        write propertyComma
        set propertyComma = ","
        
        set columnName = columnMetadata(c)
        set columnType = columnMetadata(c, "type")
        set isList = columnMetadata(c, "list")
        set value = results.%Get(columnName)        
        set jsonDataFormat = ##class(Frontier.Types).GetJSONDataFormat(columnType)
        
        if $isobject(propertyFormatter) {
          set columnName = propertyFormatter.Format(columnName, depth)
        }
        
        write $$$ZENJSONPROP(columnName, "s")_":"
        
        if isList = 1 {
          set delimiter = columnMetadata(c, "list_delimiter")
          set isString = columnMetadata(c, "list_string")
          do ListToJSONArray(value, delimiter, isString)
        } elseif value = "" && (jsonDataFormat = "null") {
          if jsonDataFormat = "null" write jsonDataFormat
          else  write """"
        } elseif jsonDataFormat = "boolean" {
          set value = $$$FormatBoolean(value)
          // Must be set to empty and not assume false because some applications might be checking the value like: value '= "".
          // That could generate a breaking change.
          if value = "" write """"""
          else  write value
        } else {
          write $$$ZENJSONVALUE(value, "s")
        }                               
      }
      write "}"
    }   
    write "]"
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
  
ListToJSONArray(value, delimiter, string)
  write "["
  
  set comma = ""  
  set length = $length(value, delimiter)
  
  for i=1:1:length {
    write comma
    if string write $$$ZENJSONSTR($piece(value, delimiter, i), "s")
    else  write $$$ZENJSNUM($piece(value, delimiter, i))
    set comma = ","
  }
  
  write "]"
]]></Implementation>
</Method>

<Method name="FetchColumnMetadatas">
<ClassMethod>1</ClassMethod>
<FormalSpec>metadata:%SQL.StatementMetadata,*columnMetadata:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set columns = metadata.columns
  set columnMetadata = columns.Count()
  for i=1:1:columnMetadata {
    set column = columns.GetAt(i)
    set columnMetadata(i) = column.label
    
    if $isobject(column.typeClass) {
      set columnMetadata(i, "type") = column.typeClass.Name
    } else {
      set columnMetadata(i, "type") = ""
    }
    
    if $isobject(column.property) {
      set columnMetadata(i, "list") = (column.property.Collection = "list")
      set columnMetadata(i, "list_delimiter") = $$$trimQuote(column.property.Parameters.GetAt("CollectionOdbcDelimiter"))
      set columnMetadata(i, "list_string") = ($$$ucase(column.property.Type) [ "STRING")
    } else {
      set columnMetadata(i, "list") = 0
    }
  }  
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Schema.Map">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36886.274558</TimeCreated>

<Property name="Prefix">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Forward">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Route">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36903.793612</TimeCreated>

<Property name="Url">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Method">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Call">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cors">
<Description>
Deprecated but kept in favor of compability with %CSP.REST.</Description>
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Scope">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="UseAuth">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Strict">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="AuthStrategy">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="Frontier.Schema.Routes">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>64552,36920.7862</TimeCreated>

<Parameter name="XMLPROJECTION">
<Default>WRAPPED</Default>
</Parameter>

<Property name="Route">
<Type>Frontier.Schema.Route</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Map">
<Type>Frontier.Schema.Map</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="Frontier.Schema.Util">
<Abstract>1</Abstract>
<TimeCreated>64552,36997.083393</TimeCreated>

<Method name="Parse">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>targetClass:%String,*routes:Frontier.Schema.Routes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set xdataId = targetClass_"||UrlMap"
  
  if '##class(%Dictionary.CompiledXData).%ExistsId(xdataId) {
    return $$$ERROR($$$XDataBlockMissing, targetClass, "UrlMap")
  }
  
  try {
    set reader = ##class(%XML.Reader).%New()
    set xdata = ##class(%Dictionary.CompiledXData).%OpenId(xdataId).Data   
    set resolver = ##class(%XML.SAX.XDataEntityResolver).%New(targetClass)
    set reader.EntityResolver = resolver
    $$$ThrowOnError(reader.OpenStream(xdata))
    do reader.Correlate("Routes", "Frontier.Schema.Routes")
    do reader.Next(.routes, .sc)
    $$$ThrowOnError(sc)
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="GeneratePatterns">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>routes:Frontier.Schema.Routes,targetClass:%String,*patterns:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim route As Frontier.Schema.Route
  #dim map as Frontier.Schema.Map
  
  set totalRoutes = routes.Route.Count()
  set totalMaps = routes.Map.Count()
  set k = 0
  set p = 0
  
  set lowPriorityPatterns = 0
  
  if totalRoutes > 0 {
    set resourceType = "R"
    for i=1:1:totalRoutes {
      set route = routes.Route.GetAt(i)
      set pattern = $$WritePattern(route.Url, .placeholders, route.Strict)
      set routePattern = $lb(resourceType, pattern, route.Method, route.Call, route.Cors, placeholders, route.Scope, route.UseAuth, route.Strict, route.Url, route.AuthStrategy)
      if placeholders = "" && (pattern '= "/") {
        set patterns($increment(p)) = routePattern
      } else {
        set lowPriorityPatterns($increment(k)) = routePattern
        set lowPriorityPatterns = k
      }
    }    
  } 
  
  if totalMaps > 0 {
    set resourceType = "M"
    for j=1:1:totalMaps {
      set map = routes.Map.GetAt(j)
      set pattern = $$WritePattern(map.Prefix, .placeholders, 1)
      set routePattern = $lb(resourceType, pattern, map.Forward, placeholders, 1)
      if placeholders = "" && (pattern '= "/") {
        set patterns($increment(p)) = routePattern
      } else {
        set lowPriorityPatterns($increment(k)) = routePattern
        set lowPriorityPatterns = k
      }
    }
  }
  
  for i=1:1:lowPriorityPatterns {
    set patterns(p + i) = lowPriorityPatterns(i)
  }  
  
  return $$$OK
  
WritePattern(resource, placeholders, strict)
  #define GetPlaceholder(%exp) $piece(%exp, ":", 2) 
  #define AddPlaceholderIfNotDefined(%placeholder)  ##continue
  if '$lf(placeholders, %placeholder) { ##continue
    set $list(placeholders, *+1) = $$$GetPlaceholder(%placeholder) ##continue 
  }    
      
  set pattern = ""
  set placeholders = ""
  set shouldCloseParenthesis = 0
  
  if 'strict return resource
  
  if $extract(resource) = ":" {
    $$$AddPlaceholderIfNotDefined($piece(resource, "/", 1))
  }
  
  set resourcePartsLength = $length(resource,"/")
  
  for resourceIndex=2:1:resourcePartsLength {
    set resourcePart = $piece(resource,"/", resourceIndex)
    if $extract(resourcePart) = ":" {
      $$$AddPlaceholderIfNotDefined(resourcePart) 
      set pattern = pattern_"/([^\/]+?)"
    } else {      
      set pattern = pattern_"/"_resourcePart
    }   
  }
  return $case(resourceType, "M" : pattern_"(?:(?:/(?=.*))(.*)|/?$)", : pattern)
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Security.CookieSignature">
<Description>
This class can be used to generate a url/cookie friendly token.</Description>
<TimeCreated>65140,50703.439727</TimeCreated>

<Method name="Sign">
<Description><![CDATA[
Providing a value and secret, returns a token in the format:
<value>.<b64(hmac(sha512(value, secret)))>
The 'value' parameter is concatenated into the token in plain text. If you want to hide the info, you can encode/encrypt it before calling this method.
The 'secret' is the string key used by the encryption algorithm and should never be exposed.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String,secret:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return value_"."_$translate($System.Encryption.Base64Encode($System.Encryption.HMACSHA(512, value, secret), 1), "=/+$", "")
]]></Implementation>
</Method>

<Method name="Unsign">
<Description>
Takes a token returning the value portion if valid otherwise empty.
The 'token' parameter must be exactly what was generated by the Sign method.
The 'secret' must also be the same used to generated the token. It can also be a $list of secrets that must be tested against.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>token:%String,secret:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  if secret '= "" && $lv(secret) && ($ll(secret) > 1) {
    for i=1:1:$ll(secret) {
      set value = ..Unsign(token, $lg(secret, i))
      if value '= "" return value
    }
    
    return ""
  }
  
  set value = $piece(token, ".", 1)
  set mac = ..Sign(value, secret)

  if $$ConstantTimeCompare(mac, token) {
    return value
  }

  return ""

ConstantTimeCompare(a, b)
  if $length(a) '= $length(b) return 0
  for i=1:1:$length(a) {
    // Convert char to ASCII code and then to bitstring.
    set aChar = $factor($ascii($extract(a, i)))
    set bChar = $factor($ascii($extract(b, i)))
    set match = $bitlogic(aChar ^ bChar)
    set all = $bitlogic(all | match)
  }
  // 00000000 = valid
  return $bitfind(all, 1) = 0
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.SessionEvents">
<Super>%CSP.SessionEvents</Super>
<TimeCreated>64594,37362.115919</TimeCreated>

<Method name="OnEndRequest">
<Description>
Called when we have finished processing this request</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set frontier = %session.Get("%frontier")
  if $isobject(frontier) return frontier.ReporterManager.Report()
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Shared.Utilities">
<Abstract>1</Abstract>
<TimeCreated>64817,54920.187316</TimeCreated>

<Method name="RandomString">
<ClassMethod>1</ClassMethod>
<FormalSpec>size,lowerCase:%Boolean=0,extras=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set key = ""
  set alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  if lowerCase = 1 set alpha = alpha_$$$lcase(alpha)
  if extras '= "" set alpha = alpha_extras
  
  while $length(key) < size {
    set next = $select($random(2) = 1 : $extract(alpha, $random($length(alpha))), 1: $random(9))
    set key = key_next
  }
  quit key
]]></Implementation>
</Method>

<Method name="SanitizeFilename">
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if fileName [ "/" set fileName = $piece(fileName, "/", *)
  if fileName [ "\" set fileName = $piece(fileName, "\", *)
  
  set fileName = $translate(fileName, "", "aaAAAaAAAAaeeEEeEEiiIIIiooOOOOOoOouuUUUuCcOoUuN")
  return $zstrip(fileName, "*E'N'A", "", "_-@. ")
]]></Implementation>
</Method>

<Method name="ReplacePlaceholders">
<ClassMethod>1</ClassMethod>
<FormalSpec>definitions:%DynamicObject</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set text = definitions.text
    
  set it = definitions.placeholders.%GetIterator()
  while it.%GetNext(.key, .value) { set text = $replace(text, key, value) }  
  
  return text
]]></Implementation>
</Method>

<Method name="DeepExtend">
<ClassMethod>1</ClassMethod>
<FormalSpec>sources...:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  
  #dim result As %DynamicObject
    
  set result = {}    
  
  for i=1:1:sources {
    set iterator = sources(i).%GetIterator()
    while iterator.%GetNext(.property, .value) {
      set target = $property(result, property)
      if $isobject(value) && value.%IsA("%DynamicObject") && $isobject(target) {
        set isSameSize = (target.%Size() = value.%Size())
        set hasSameProperty = $property(target, property) = $property(value, property)
        if '(isSameSize && hasSameProperty) {
          set $property(result, property) = ..DeepExtend(target, value)
        }
      } elseif 'result.%IsDefined(property) {
        set $property(result, property) = value
      }      
    }
  }
  return result
]]></Implementation>
</Method>

<Method name="SafeClassMethodCall">
<ClassMethod>1</ClassMethod>
<FormalSpec>expression:%String,args...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if expression = "" return sc
  
  set class = $piece(expression, ":")
  set method = $piece(expression, ":", 2)
  try {
    set sc = $classmethod(class, method, args...)
  } catch ex {
    set sc = ex.AsStatus()
  }
  return sc
]]></Implementation>
</Method>

<Method name="SafeMethodCallAndReturn">
<ClassMethod>1</ClassMethod>
<FormalSpec>sc:%Status=$$$OK,instance:%RegisteredObject,method:%String,args...</FormalSpec>
<Implementation><![CDATA[
  set ret = ""
  
  try {
    set ret = $method(instance, method, args...)
    if $extract(ret, 1, 2) = "0 " && $lv($p(ret, " ", 2)) {
      set errcode = $$$GETERRORCODE(ret)
      if errcode '= "" {
        set sc = ret
        set ret = ""
      }
    }
  } catch ex {
    set sc = ex.AsStatus()
  }
  return ret
]]></Implementation>
</Method>

<Method name="URLBase64Encode">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $translate($System.Encryption.Base64Encode(value, 1), "+/=", "-_")
]]></Implementation>
</Method>

<Method name="URLBase64Decode">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $System.Encryption.Base64Decode($translate(value, "-_", "+/"))
]]></Implementation>
</Method>

<Method name="CallAndCapture">
<ClassMethod>1</ClassMethod>
<FormalSpec>object,method:%String,*str:%Stream.GlobalCharacter="",args...:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new oldMnemonic, alreadyRedirected, sc
  
  set sc = $$$OK
  set isRedirected = 0  
  
  set str = ##class(%Stream.GlobalCharacter).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
  set initIO = $io  
  
  try {   
    use $io::("^"_$zname)    
    do ##class(%Device).ReDirectIO(1)
    set isRedirected = 1    
    if $isobject(object) set sc = $method(object, method, args...)
    else  set class = object set sc = $classmethod(class, method, args...)
    do str.Rewind()
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }     
  
  if oldMnemonic '= "" {
    use initIO::(oldMnemonic)
  } else {
    use oldMnemonic
  }
  
  do ##class(%Device).ReDirectIO(alreadyRedirected)
      
  return sc
  
wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.Types">
<Abstract>1</Abstract>
<IncludeCode>frontier</IncludeCode>
<TimeCreated>64502,35492.335596</TimeCreated>

<Method name="IsInstantiable">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%RegisteredObject")
]]></Implementation>
</Method>

<Method name="IsPersistent">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Persistent")
]]></Implementation>
</Method>

<Method name="IsDataType">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%DataType")
]]></Implementation>
</Method>

<Method name="IsStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Stream.Object")
]]></Implementation>
</Method>

<Method name="IsCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%Collection.AbstractIterator")
]]></Implementation>
</Method>

<Method name="IsSerial">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ..IsTypeOf(className, "%SerialObject")
]]></Implementation>
</Method>

<Method name="IsDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicAbstractObject")
]]></Implementation>
</Method>

<Method name="IsDynamicArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicArray")
]]></Implementation>
</Method>

<Method name="IsDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%DynamicObject")
]]></Implementation>
</Method>

<Method name="IsZENProxyObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "%ZEN.proxyObject")
]]></Implementation>
</Method>

<Method name="IsSQLProvider">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ..IsTypeOf(className, "Frontier.SQL.Provider")
]]></Implementation>
</Method>

<Method name="IsTypeOf">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,expectedType:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
   
  if className = "" quit 0
  
  $$$NormalizeClassName(className)
  $$$NormalizeClassName(expectedType)  
  
  if className = expectedType return 1
  
  // Uses default %Extends method to check for common cases and improve performance.
  return ##class(%Dictionary.CompiledClass).%ExistsId(className) && $classmethod(className, "%Extends", expectedType)
]]></Implementation>
</Method>

<Method name="GetJSONDataFormat">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>cacheType:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  $$$NormalizeClassName(cacheType)
  
  if ..IsDataType(cacheType) {
    set type = $case(cacheType,
      "%Library.Boolean": "boolean",
      "%Library.Double": "number",
      "%Library.BigInt": "number",
      "%Library.TinyInt": "number",
      "%Library.Decimal": "number",
      "%Library.Integer": "number",
      "%Library.Float": "number",
      "%Library.Date": "number",
      "%Library.Time": "number",
      "%Library.DateTime": "number",
      "%Library.TimeStamp": "number",
      : "string")
  } else {
    set type = "null"
  }
  return type
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Authentication.DummyStrategy">
<Super>Frontier.Authentication.Strategy</Super>
<TimeCreated>64560,50335.046682</TimeCreated>

<Property name="Behavior">
<Type>%String</Type>
<InitialExpression>"fail"</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>config:%DynamicObject={{}}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="Verify">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*user:%DynamicObject={{}},resourceScope:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  if ..Behavior = "bypass" return $$$OK
  if ..Behavior = "pass" set ..Verified = 1 return $$$OK
  set response.Status = "401 Unauthorized"
  return $$$ERROR($$$GeneralError, "Requested to fail")
]]></Implementation>
</Method>

<Method name="GetChallenge">
<FormalSpec>session:%CSP.Session,request:%CSP.Request,response:%CSP.Response,*challenge:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set challenge = "realm=""Tests"""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Class">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34585.6306</TimeCreated>

<Property name="Plate">
<Type>%String</Type>
</Property>

<Property name="Students">
<Type>Student</Type>
<Cardinality>many</Cardinality>
<Inverse>Class</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Note">
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.Fix50C.ClassD</DataLocation>
<DefaultData>ClassDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.Fix50C.ClassD</IdLocation>
<IndexLocation>^Frontier.UnitTest.Fix50C.ClassI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.Fix50C.ClassS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="ClassDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Plate</Value>
</Value>
<Value name="3">
<Value>Note</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Note">
<Selectivity>100.0000%</Selectivity>
</Property>
<Property name="Plate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Fixtures.Student">
<Super>%Persistent,%Populate</Super>
<TimeCreated>64502,34683.761379</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Class">
<Type>Class</Type>
<Cardinality>one</Cardinality>
<Inverse>Students</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Enrollment">
<Type>%DateTime</Type>
</Property>

<Property name="Adress">
<Type>%String</Type>
<Parameter name="POPSPEC" value="Street()"/>
</Property>

<Property name="PeriodStart">
<Type>%Time</Type>
</Property>

<Property name="PeriodEnd">
<Type>%Time</Type>
</Property>

<Property name="LastPresentDate">
<Type>%Date</Type>
<Parameter name="FORMAT" value="4"/>
</Property>

<Property name="Active">
<Type>%Boolean</Type>
</Property>

<Query name="PaginatedStudents">
<Type>%SQLQuery</Type>
<FormalSpec>offset:%Integer,limit:%Integer</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>  
  SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN :offset AND :limit</SqlQuery>
</Query>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Frontier.UnitTest.F50C.StudentD</DataLocation>
<DefaultData>StudentDefaultData</DefaultData>
<IdLocation>^Frontier.UnitTest.F50C.StudentD</IdLocation>
<IndexLocation>^Frontier.UnitTest.F50C.StudentI</IndexLocation>
<StreamLocation>^Frontier.UnitTest.F50C.StudentS</StreamLocation>
<ExtentSize>10</ExtentSize>
<Data name="StudentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Class</Value>
</Value>
<Value name="4">
<Value>BirthDate</Value>
</Value>
<Value name="5">
<Value>SomeValue</Value>
</Value>
<Value name="6">
<Value>Adress</Value>
</Value>
<Value name="7">
<Value>Enrollment</Value>
</Value>
<Value name="8">
<Value>PeriodStart</Value>
</Value>
<Value name="9">
<Value>PeriodEnd</Value>
</Value>
<Value name="10">
<Value>LastPresentDate</Value>
</Value>
<Value name="11">
<Value>Active</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>1.1</AverageFieldSize>
</Property>
<Property name="Active">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="Adress">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>17</AverageFieldSize>
</Property>
<Property name="BirthDate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="Enrollment">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>1</AverageFieldSize>
</Property>
<Property name="LastPresentDate">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="Name">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>16</AverageFieldSize>
</Property>
<Property name="PeriodEnd">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="PeriodStart">
<Selectivity>10.0000%</Selectivity>
<AverageFieldSize>4.9</AverageFieldSize>
</Property>
<Property name="SomeValue">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>7</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Frontier.UnitTest.Router">
<Super>Frontier.Router</Super>
<TimeCreated>64503,35090.481271</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/public/single" Method="GET" Call="TestGETSingleStaticFile" />
<Route Url="/public/(.*)" Strict="false" Method="GET" Call="TestGETStaticFile"/>
<Route Url="/public/custom/(.*)" Strict="false" Method="GET" Call="TestGETStaticFileWithCustomConfig"/>
<Route Url="/upload/multi" Method="POST" Call="TestPOSTMultipartFileUpload"/>
<Route Url="/upload" Method="POST" Call="TestPOSTSingleFileUpload"/>
<Route Url="/route-params/:class" Method="GET" Call="TestGETRouteParams"/>
<Route Url="/route-params/:class/students/:student" Method="GET" Call="TestGETRouteParamsWhereId"/>
<Route Url="/query-params" Method="GET" Call="TestGETOneQueryParameter"/>
<Route Url="/rest-params" Method="GET" Call="TestGETRestParametersSum"/>
<Route Url="/sql/dynamic" Method="GET" Call="TestGETDynamicSQLResult"/>
<Route Url="/sql/query" Method="GET" Call="TestGETQuerySQLResult"/>
<Route Url="/sql/inline-query" Method="GET" Call="TestGETInlineQueryBuilder" />
<Route Url="/raw" Method="GET" Call="TestGETRawMode"/>
<Route Url="/shared-data" Method="GET" Call="TestGETData"/>
<Route Url="/stream" Method="GET" Call="TestGETStream"/>
<Route Url="/alias" Method="GET" Call="TestGETAliasedQueryParameter"/>
<Route Url="/payload/single-object" Method="POST" Call="TestPOSTObjectPayloadSingle"/>
<Route Url="/payload/object-with-query-params" Method="POST" Call="TestPOSTObjectPayloadQueryParams"/>
<Route Url="/payload/single-array" Method="POST" Call="TestPOSTArrayPayloadSingle"/>
<Route Url="/payload/array-with-query-params" Method="POST" Call="TestPOSTArrayPayloadQueryParams"/>
<Route Url="/payload/invalid" Method="POST" Call="TestPOSTInvalidPayload"/>
<Route Url="/mixed/object" Method="GET" Call="TestGETMixedDynamicObject"/>
<Route Url="/mixed/array" Method="GET" Call="TestGETMixedDynamicArray"/>
<Route Url="/mixed/rest" Method="POST" Call="TestPOSTMixedRestParametersSum"/>
<Route Url="/unmarshal" Method="POST" Call="TestPOSTUnmarshalToClass"/>
<Route Url="/unmarshal/:class" Method="PUT" Call="TestPUTUnmarshalToClass"/>
<Route Url="/user-info" Method="GET" Call="TestGETSessionUserInfo"/>
<Route Url="/sign-in" Method="POST" UseAuth="false" Call="SignIn" />
<Route Url="/errors/siblings" Method="GET" Call="TestGETMultipleSiblingErrors"/>
<Route Url="/arguments/no-weak-typed" Method="GET" Call="TestGETNoWeakTypedArgs"/>
<Route Url="/methods/no-weak-typed" Method="GET" Call="TestGETNoWeakTypedMethods" />
<Route Url="/custom-auth" Method="GET" AuthStrategy="BasicSystemLogin" Call="TestGETCustomAuth" />
<Route Url="/x-www-urlencoded" Method="POST" Call="TestXWWWUrlEncoded" />
<Map Prefix="/map/A/:param1" Forward="Frontier.UnitTest.Router.Map.A" />
<Map Prefix="/map/B/:param1/:param2" Forward="Frontier.UnitTest.Router.Map.B" />
<Map Prefix="/map/C" Forward="Frontier.UnitTest.Router.Map.C" />
<Map Prefix="/map/D/:paramA/fixed/:paramB" Forward="Frontier.UnitTest.Router.Map.D"/>
<Map Prefix="/map/E/:namedParam" Forward="Frontier.UnitTest.Router.Map.E"/>
</Routes>
]]></Data>
</XData>

<Method name="OnDataSet">
<Description>
Use this method to share data between methods.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  /// This 'data' object is shared between all methods. Accessible using %frontier.Data.
  set data.Message = "This 'Message' is shared between all methods."
  set data.Workspace = ##class(%File).NormalizeFilename(##class(Port.Configuration).GetWorkspace("frontier"))
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnSetup">
<Description>
This method is reserved for setting up configurations.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  // Add reporters to notify the developers about ongoing errors.
  // This one creates a new entry into the Frontier.Reporter.Log table.
  set logReporter = ##class(Frontier.Reporter.Log).%New({
    // We want to log any abnormal error.
    "include": [($$$CacheError), ($$$InvalidUsernameOrPassword)],
    /// But we don't want to log custom errors.
    "exclude": [($$$GeneralError)]
  })  
  
  $$$QuitOnError(%frontier.ReporterManager.AddReporter(logReporter)) 

  set cookieStrategy = ##class(Frontier.Authentication.CookieStrategy).%New({
    "secret": "shhh",
    "validator": ($classname()_":ValidateUsingCookie")
  })

  // Asks the user for a Basic + Base64(username:password) encoded Authorization header.
  set basicStrategy = ##class(Frontier.Authentication.BasicStrategy).%New({
    "realm": "tests",
    "validator": ($classname()_":ValidateCredentials")
  })

  set systemBasicStrategy = ##class(Frontier.Authentication.BasicStrategy).%New({
    "realm": "system",
    "name": "BasicSystemLogin",
    "validator": ($classname()_":ValidateSystemCredentials")
  })

  // This uses the cookie generated by the /sign-in route to validate the access.
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(cookieStrategy))

  // This provides a way to check if the current user is authenticated using Basic scheme.
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(basicStrategy))
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(systemBasicStrategy))

  set %frontier.Response.GzipOutput = 1
  do %frontier.CORS.Default()
   
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Description>
Whenever a parameter is typed of %Persistent and a valid id is provided, the parameter will be instantiated.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/route-params/6'
{"Plate":"O5397","Students":[{"Name":"Drabek,Peter T.","__id__":"20"}],"__id__":"6"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return class
]]></Implementation>
</Method>

<Method name="TestGETRouteParamsWhereId">
<Description><![CDATA[
This follows the same principle as the TestGETRouteParams example, however IDWHERE allows the developer to search
for the id using alternative sources other than relying straight to route parameters.
ID WHERE is useful for avoiding the object id from being exposed to the world by masking it with contextual data.
The format is close to a SQL where, however supporting :placeholders.
Placeholders are checked using the following order:
:name -> %frontier.RouteParameters("name") (obligatory)
:name -> %frontier.User.name (optional)
:name -> %frontier.Data.name (optional)
This example brings the route parameter class's value along with the route parameter value from student.
The result is /route-params/1/students/2 instead of /route/params/1/students/1||2.
Query parameters are also supported and are fetched if the parameter name matches the URL query name.
Although <Route /> doesn't define the parameter itself. It's defined by putting it into the method's signature.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class,student:Frontier.UnitTest.Fixtures.Student</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return student
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Description>
Query parameters with default value are considered optional, otherwise they become obligatory.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/query-params?msg=hello'
{result":"hello"}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return msg
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Description><![CDATA[
Rest parameters are sequential query parameters. They can have flexible size and have the format parameterN.
This request takes that number of parameters and sum them.
Rest parameters are always optional.
Call example:
curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/rest-params?n1=10&n2=20&n3=30']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>n...:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  set sum = 0
  for i=1:1:n  set sum = sum + n(i)
  return sum
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Description><![CDATA[
Dynamic SQL queries can be returned as long as the Frontier SQL API is used.
For SQL, the usage of Prepare() from frontier.SQL API is required.
Call example:
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/dynamic?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows

  return %frontier.SQL.Prepare(
    "SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?"
  ).Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Description><![CDATA[
The same applies for named (cached) SQL queries. Notice that they can be called by providing
the class:queryname instead of a dynamic SQL.
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/sql/query?page=1&rows=5']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>page:%Integer=1,rows:%Integer=5</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set offset = (page * rows) - (rows - 1)
  set limit = page * rows

  return %frontier.SQL.Prepare("Frontier.UnitTest.Fixtures.Student:PaginatedStudents").Parameters(offset, limit).Mode(2)
]]></Implementation>
</Method>

<Method name="TestGETInlineQueryBuilder">
<Description><![CDATA[
This method captures parameter "filter" as a source to build the custom query.
You need to provide the target class which resolves to the SQL Table using the For method.
The filter format can be divided into two types:
Simple: fieldnameA_operation:value;fieldnameB_operation:value
Composited: _or:[fieldnameA_operation:value;fieldNameA_operation:value]
Supported operations:
field_eq:value field = value
field_neq:value field <> value
field_gt:value field > value
field_gte:value field >= value
field_lt:value field < value
field_lte:value field <= value
field_sw:value field %STARTSWITH value
field_nsw:value field NOT %STARTSWITH value
field_ct:value field [ value
field_nct:value field '[ value
field_lk:%value% field LIKE '%value%'
field_nlk:%value% field NOT LIKE '%value%'
field_il:v,a,l,u,e  field %INLIST($lfs('v,a,l,u,e'))
field_nil:v,a,l,u,e field NOT %INLIST($lfs('v,a,l,u,e'))
field_is:null field IS NULL
field_isn:null field IS NOT NULL
field_bt:0,5 field BETWEEN 0 and 5
field_nbt:0,5 field NOT BETWEEN 0 and 5
field_in:v,a,l,u,e field IN('v','a','l','u','e')
field_nin:v,a,l,u,e field NOT IN('v','a','l','u','e')
field:value is translate to field_eq:value
OrderBy can be used to sort the fields, the syntax is the same as you would use with SQL.
Fields can be used to select the fields you want include in the results.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%String,page:%String="",limit:%String="",orderBy:%String="",groupBy:%String=""</FormalSpec>
<ReturnType>Frontier.SQL.Provider</ReturnType>
<Implementation><![CDATA[
  set builder = %frontier.SQL.InlineQueryBuilder("Frontier.UnitTest.Fixtures.Student")
  if page '= "" && (limit '= "") do builder.Pagination(page, limit)
  if orderBy '= "" do builder.OrderBy(orderBy)
  if groupBy '= "" do builder.GroupBy(groupBy)
  if filter '= "" do builder.Filter(filter)

  return builder.Build().Provide()
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Description>
There can be cases where the response should not be a JSON.
This method shows how to output a text in plain format.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/raw</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  return "hello raw response"
]]></Implementation>
</Method>

<Method name="TestGETData">
<Description>
This method uses the data object provided on Setup method.
The idea is to demonstrate how to access shared data.
Call example:
/// curl -H "Content-Type: application/json" 'localhost:57772/api/frontier/test/shared_data'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return %frontier.Data
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Description>
This method demonstrates how %Stream.Object based instances are treated.
Call example:
curl -H "Content-Type: application/json" 'http://localhost:57772/api/frontier/test/stream'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  set stream = ##class(%Stream.GlobalCharacter).%New()
  do stream.Write("This line is from a stream.")

  return stream
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Description>
If the request is a POST/PUT/PATCH method, it can receive a payload that's represented by a parameter typed of %DynamicObject instances.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/single-object'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Description>
Request can have a payload along with a query parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/payload/object-with-query-params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String="",payload:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return {
    "msg": (msg),
    "payload": (payload)
  }
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Description>
Payloads can also be an array.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/single-array'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return payload
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Description>
Requests with array payloads also support query parameters.
Call example:
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/array-with-query-params?msg=hello'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payload:%DynamicArray,msg:%String=""</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (msg), (payload) ]
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Description>
This demonstrates payload validation, as browsers can receive one payload per request
a classmethod that expects more than one is considered invalid and will throw an exception.
curl -H "Content-Type: application/json" -X POST -d '[{"username":"xyz","password":"xyz"}]' 'http://localhost:57772/api/frontier/test/payload/invalid'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>payloadA:%DynamicArray,payloadB:%DynamicObject</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return payloadA
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Description>
Normally %Dynamic instances cannot serialize childrens that aren't dynamic as well. (%ToJSON would thrown an exception).
Frontier fixes it by marshalling irregularities to %Dynamic instances beforehand and making them compatible.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/object?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  return {
    "class": (class)
  }
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Description>
Also supported for %DynamicArray.
Call example:
curl -H "Content-Type: application/json" http://localhost:57772/api/frontier/test/mixed/array?class=1</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[  return [ (class) ]
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Description><![CDATA[
It's possible to mix multiple parameter types as you could when calling a method.
The example below illustrates the usage of a method that receives a 'msg' query parameter along with a payload and a rest parameter.
Call example:
curl -H "Content-Type: application/json" -X POST -d '{"username":"xyz","password":"xyz"}' 'http://localhost:57772/api/frontier/test/mixed/rest?n1=10&n2=20&msg=hello']]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,data:%DynamicObject,n...:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set parameters = []
  set sum = 0
  for i=1:1:n  set sum = sum + n(i) do parameters.%Push(n(i))
  return {
    "sum": (sum),
    "data": (data),
    "params": (parameters),
    "msg": (msg)
  }
  return sum
]]></Implementation>
</Method>

<Method name="TestGETAliasedQueryParameter">
<Description>
For compability with existing clients that use query parameters with symbols. For such cases
ALIAS can be used to make it compatible. If the expected alias is not found then Frontier will
fall back to using the original argument name instead.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String(ALIAS="aliased_key")</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return msg
]]></Implementation>
</Method>

<Method name="TestPOSTUnmarshalToClass">
<Description>
It's also possible to save from a payload directly to a %Persistent instance as long as the payload
has the same format as the %Persistent class. Just define the the parameter UNMARSHALL to 1.
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshal'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class(UNMARSHAL=1)</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="TestPUTUnmarshalToClass">
<Description>
You can also edit the entity just by providing the property "__id__" along with the new payload data. If you want the id to be read from the URL,
add a new parameter and map the unmarshaller to use it as id by specifying the WHEREID. If WHEREID is not
found, the id will be searched inside the payload. Note that when the id is not found, an exception will be thrown regarding  the
incorrect PUT usage.
curl -H "Content-Type: application/json" -X POST -d '{"Plate": "R-2948","Students": [{"Name": "Rubens","BirthDate": "04/21/1970","SomeValue": 0}]}' 'http://localhost:57772/api/frontier/unmarshall/15'</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:Frontier.UnitTest.Fixtures.Class</FormalSpec>
<ReturnType>Frontier.UnitTest.Fixtures.Student</ReturnType>
<Implementation><![CDATA[
  $$$ThrowOnError(class.%Save())
  return {
    "ok": 1,
    "__id__": (class.%Id())
  }
]]></Implementation>
</Method>

<Method name="TestGETSessionUserInfo">
<Description>
This method depends on the authorization header sent by the client and validated with the validator method.
The validator method is also responsible for defining the user object.
Call example:
curl -H "Authorization: Basic Zm9vOmJhcg" 'http://localhost:57772/api/frontier/test/user'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return %frontier.User
]]></Implementation>
</Method>

<Method name="TestGETStaticFile">
<Description><![CDATA[
Serves all files from the path defined on Data.Workspace (this project's folder).
This is the fastest way to implement a file server.
In order to use it, you must provide A non-Strict route that allows custom regular expressions like this one:
<Route Url="/public/?(.*)?" Strict="false" Method="GET" Call="TestFileServer"/>
That regular expression means 'put everything after public or public/ into %frontier.Matches'.
E.g.: /public/my/path/has/this/file.txt resolves into /<root>/my/path/has/this/file.txt
Keep in mind that this won't create a virtual host. So if you're serving files like HTML that link to other files,
you must provide the path relative to the server's virtual host instead of relating it to the Route path.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[  return %frontier.Files.ServeFrom(%frontier.Data.Workspace)
]]></Implementation>
</Method>

<Method name="TestGETStaticFileWithCustomConfig">
<Description><![CDATA[
This actually does the same than TestGETStaticFile.
Using Serve allows to provide advanced cache configuration and extension recognition.
The settings are:

root - Provides the path where files are located.

file - If root is not provided, a 'file' is expected to be defined. Which points to a file instead of a directory.

index - Indicates which files to search for and serve as default if no specific file path was provided.

cache - How the cache should behave.

charset - Defines which charset to be apply while reading the device and also sets the charset parameter for the response.

cache.configuration - A string containing the Cache-Control header configuration. Eg: "max-age=120, public".
cacheignore - A array indicating which extensions should not be cached.

extensions - An Object containing how to the server should handle files matching the extension.

The file server attempts to discover how to handle the extension.
But defaults to 'application/octet-stream' if the extension is unknown. The 'extension' object provides a way to handle them.
Each extension object should be keyed by its own extension identifier along with a child object.

<extension> - This is the keyed object, all configurations inside it will affect the <extension> exclusively.
<extension>.disposition - This will set the Content-Disposition header.
<extension>.disposition = "attachment" will force the browser to download the file instead of opening it.
<extension>.disposition = "inline" will force the browser to open the file.
<extension>.mimeType - Sets the Content-Type to the specified string.
<extension>.binary - Informs the file server to handle the file as binary. This disables charset conversion.
<extension>.charset - If not specified, this assumes the global 'charset' configuration. This setting exists to differ the charset by file extension.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  return %frontier.Files.Serve({
    "root": (%frontier.Data.Workspace),
    "index": "index.html index.htm",
    "extensions": {
      "md": {
        "disposition":  "inline",
        "mimeType": "text/markdown",
        "binary": false
      }
    }
  })
]]></Implementation>
</Method>

<Method name="TestGETSingleStaticFile">
<Description>
If you need to provide access to a single file without exposing the path where it actually is, then
you can do so by using the ServeFile instead, this method takes an absolute path to a file restricting
the access to anything else.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[  return %frontier.Files.ServeFile(%frontier.Data.Workspace_"/README.md", "utf-8")
]]></Implementation>
</Method>

<Method name="TestPOSTMultipartFileUpload">
<Description>
This method implements a full-sized configuration on how to handle multipart uploads.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set location = %frontier.Data.Workspace_"/fixtures/uploads/multiple"
  set destination = (location_"/:KEY/:FILE_NAME:EXTENSION")

  // 512 KB
  set maxFileSize = (1024**2/0.5)

  return %frontier.Files.Upload({
    "hooks": {
      "onItemUploadSuccess": "Frontier.UnitTest.Router:WriteResultToProcessGlobal",
      "onItemUploadError": "Frontier.UnitTest.Router:WriteErrorToProcessGlobal",
      "onComplete": "Frontier.UnitTest.Router:WriteResultSummaryToProcessGlobal"
    },
    "filters": {
      "verbose": true,
      "maxFileSize": { "value": (maxFileSize), "errorTemplate": "O arquivo excedeu o limite de :VALUE bytes." },
      "extensions": ["cls", "md", "txt", "pdf"]
    },
    "destinations": {
      "file_a": { "path": (destination) },
      "file_b": { "path": (destination) },
      "file_c": { "path": (destination), "optional": true },
      "file_d": { "path": (destination), "optional": true },
      "files": {
        "path": (location_"/files/:INDEX/:FILE_NAME:EXTENSION"),
        "slots": 3,
        "filters": { "maxFileSize": 500000000 }
      }
    }
  })
]]></Implementation>
</Method>

<Method name="TestPOSTSingleFileUpload">
<Description>
This is an alternative format for handling uploads that aren't form-data/multipart.
This format should be used to handle simple file uploads.
The uploader changes to this mode if "destination" is passed instead of "destinations".
With a few placeholder exceptions (FILE_NAME, EXTENSION), all other features can also be applied here.
Since only the file is sent straight to %request.Content, there's no way to know the
file name, which means that its name should defined by the implementation.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  return %frontier.Files.Upload({
    "filters": {
      "verbose": true,
      "extensions": ["txt"]
    },
    "hooks": {
      "onItemUploadError": "Frontier.UnitTest.Router:WriteErrorToProcessGlobal",
      "onComplete": "Frontier.UnitTest.Router:WriteResultSummaryToProcessGlobal"
    },
    "destination": (%frontier.Data.Workspace_"/fixtures/uploads/single/file.txt")
  })
]]></Implementation>
</Method>

<Method name="WriteResultToProcessGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,index:%String,destination:%String,filePath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier("success", key) = $lb(destination, filePath)
  return $$$OK
]]></Implementation>
</Method>

<Method name="WriteResultSummaryToProcessGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>summary:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier("summary") = summary.%ToJSON()
  return $$$OK
]]></Implementation>
</Method>

<Method name="WriteErrorToProcessGlobal">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,index:%String,destination:%String,filePath:%String,sc:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^||Frontier("error", key, index) = $lb(sc, key, destination, filePath)
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETMultipleSiblingErrors">
<Description>
Errors can be put together. Either by simblings or childrens.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc1 = $$$ERROR($$$GeneralError, "First")

  set sc2 = $$$ERROR($$$GeneralError, "Second")
  set sc3 = $$$ERROR($$$GeneralError, "Third")
  set sc3 = $$$EMBEDSC(sc3, $$$ERROR($$$QueryNameTooLong, "Child"))
  set sc1 = $$$ADDSC(sc1, sc2)
  set sc1 = $$$ADDSC(sc1, sc3)
  $$$ThrowOnError(sc1)
]]></Implementation>
</Method>

<Method name="TestGETNoWeakTypedArgs">
<Description>
This will thrown an error. Because Frontier doesn't allow arguments without type.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%String="",b="",c</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETNoWeakTypedMethods">
<Description>
Neither it allows methods without return type.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETCustomAuth">
<Description>
This method can be retrieved only if the user logs with the Cach credentials.
The purpose is to show that custom authentication strategies can be used exclusively.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "works"
]]></Implementation>
</Method>

<Method name="ValidateCredentials">
<ClassMethod>1</ClassMethod>
<FormalSpec>login:%String,password:%String,found:%Boolean=1,*httpStatus:%String,*user:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set useScope = 0
  if login = "foo" && (password = "bar") set found = 1
  if login = "admin" && (password = "admin") set found = 1 set useScope = 1
  if found set httpStatus = ..#HTTP200OK
  else  set httpStatus = ..#HTTP403FORBIDDEN

  set user = {
    "login": (login)
  }

  if useScope {
    set user.scope = "admin not_enough"
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ValidateSystemCredentials">
<ClassMethod>1</ClassMethod>
<FormalSpec>login:%String,password:%String,*found:%Boolean=1,*httpStatus:%String,*user:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set found = $System.Security.Login(login, password)
  if 'found {
    set httpStatus = ..#HTTP403FORBIDDEN
    return $$$ERROR($$$InvalidUsernameOrPassword)
  }

  if '$System.Security.CheckUserPermission(login, "%Development", "USE") {
    set httpStatus = ..#HTTP403FORBIDDEN
    return $$$ERROR($$$RequiresRoleForConnection, "%Development")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ValidateUsingCookie">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String,*found=0,*httpStatus,*user</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set data = $zcvt($System.Encryption.Base64Decode(value), "I", "UTF8")
  set login = $listget(data, 1)

  if login = "foo" set password = "bar"
  set exp = +$listget(data, 2)

  if exp < $h {
    set found = 0
    set httpStatus = "401 Forbidden"
    return $$$OK
  }

  return ..ValidateCredentials(login, password, .found, .httpStatus, .user)
]]></Implementation>
</Method>

<Method name="SignIn">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do %frontier.Raw()
  set exp = $piece($h, ",") +30_","_$piece($h, ",", 2)
  set credential = $translate($System.Encryption.Base64Encode($zcvt($lb("foo", exp), "O", "UTF8")), "=/+$", "")
  set expires = ##class(%CSP.StreamServer).ToHTTPDate(exp)
  do %frontier.Response.SetCookie("__fc", ##class(Frontier.Security.CookieSignature).Sign(credential, "shhh"), expires, %frontier.Request.Application,,,1)
  return ""
]]></Implementation>
</Method>

<Method name="TestXWWWUrlEncoded">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,birthDate:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return { "name": (name), "birthDate": (birthDate) }
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.A">
<Super>Frontier.Router</Super>
<TimeCreated>64573,30152.808473</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
   <Route Url="/route-parameter-not-specified" Method="GET" Call="TestGETRouteParameterNotSpecified" />
   <Route Url="/pass-route-param-to-child" Method="GET" Call="TestGETPassRouteParamToChild" />
   <Route Url="/prioritize-route-parameter" Method="GET" Call="TestGETPrioritizeRouteParameter" />
 </Routes>
]]></Data>
</XData>

<Method name="TestGETRouteParameterNotSpecified">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "this wont be returned"
]]></Implementation>
</Method>

<Method name="TestGETPassRouteParamToChild">
<ClassMethod>1</ClassMethod>
<FormalSpec>param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1
]]></Implementation>
</Method>

<Method name="TestGETPrioritizeRouteParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec>param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.B">
<Super>Frontier.Router</Super>
<TimeCreated>64573,34962.694117</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
    <Route Url="/" Method="GET" Call="TestGETMultipleRouteParameters" />
    <Route Url="/something_(up|down)" Strict="false" Method="GET" Call="TestMe" />
  </Routes>
]]></Data>
</XData>

<Method name="TestMe">
<ClassMethod>1</ClassMethod>
<FormalSpec>matches:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return matches
]]></Implementation>
</Method>

<Method name="TestGETMultipleRouteParameters">
<ClassMethod>1</ClassMethod>
<FormalSpec>param2:%String,param1:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return param1_" "_param2
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.C">
<Super>Frontier.Router</Super>
<TimeCreated>64573,35614.836117</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
 <Map Prefix="/no-self-forwarding" Forward="Frontier.UnitTest.Router.Map.C" />
 <Route Url="/" Method="GET" Call="TestGETRouteWithoutParameters" />
 <Route Url="/:id" Method="GET" Call="TestGETRouteWithoutParametersA" />
 <Route Url="/scoped" Method="GET" Scope="admin" Call="TestGETScopedResponse" />
 <Route Url="/auth/bypass" Method="GET" UseAuth="false" Call="TestGETBypassAuth" />
</Routes>
]]></Data>
</XData>

<Method name="TestGETRouteWithoutParameters">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return "Hello from a simple but mapped route!"
]]></Implementation>
</Method>

<Method name="TestGETRouteWithoutParametersA">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return id
]]></Implementation>
</Method>

<Method name="TestGETScopedResponse">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $$$FormatText("Hello %1! If you're seeing this, then you have enough privilege for that!", %frontier.User.login)
]]></Implementation>
</Method>

<Method name="TestGETBypassAuth">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 
  return "This is an unprotected resource!"
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.D">
<Super>Frontier.Router</Super>
<TimeCreated>64573,37233.838307</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
 <Route Url="/parent-sparse-params/:operation" Method="GET" Call="TestGETParentSparseParams"/>
</Routes>
]]></Data>
</XData>

<Method name="TestGETParentSparseParams">
<ClassMethod>1</ClassMethod>
<FormalSpec>operation:%String,paramA:%Integer,paramB:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  if operation = "sum" return paramA + paramB
  if operation = "subtract" return paramA - paramB
  if operation = "divide" return paramA / paramB
  if operation = "multiply" return paramA * paramB
  return 0
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Router.Map.E">
<Super>Frontier.Router</Super>
<TimeCreated>64574,39559.82603</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/frontier</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/get-parent-and-(\w+)-(\w+)" Strict="false" Method="GET" Call="TestGETMultipleRegexMatches" />
</Routes>
]]></Data>
</XData>

<Method name="TestGETMultipleRegexMatches">
<ClassMethod>1</ClassMethod>
<FormalSpec>namedParam:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set matches = [ (namedParam) ]
  
  for i=1:1:%frontier.Matches {
    do matches.%Push(%frontier.Matches(i))
  }
  
  return matches
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64503,34684.599157</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Method name="CreateWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set targetNamespace = $namespace
  
  new $namespace  
  set $namespace = "%SYS"
  
  write !, ">> Creating demo web application using namespace "_targetNamespace_" ..."
  if ##class(Security.Applications).Exists(..#NAME) {
    write !, ">> Application already exists, skipping ..."
    return $$$OK
  }
  
  set properties("CookiePath") = ..#NAME
  set properties("DispatchClass") = "Frontier.UnitTest.Router"
  set properties("EventClass") = "Frontier.SessionEvents"
  set properties("NameSpace") = targetNamespace
  set properties("UseCookies") = 2
  set properties("AutheEnabled") = 64
  
  $$$QuitOnError(##class(Security.Applications).Create(..#NAME, .properties))
  write !, ">> Application /api/frontier/test has been created."
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveWebApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"
  
  if '##class(Security.Applications).Exists(..#NAME) return $$$OK
  write !, ">> Deleting demo web application "_..#NAME_" ..."
  
  $$$QuitOnError(##class(Security.Applications).Delete(..#NAME))
  write !, ">> Web application has been deleted with success."
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="MergeErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec>errors:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  for i=0:1:(errors.%Size() - 1) {
    set errorObject = errors.%Get(i)
    set sc = $$$ADDSC(sc, $$$ERROR(errorObject.code, errorObject.params.%Get(0)))
  }
  
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Frontier.UnitTest.WebApplicationInstaller">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64530,35966.171067</TimeCreated>

<Parameter name="NAME">
<Default>/api/frontier/test/</Default>
</Parameter>

<Projection name="Installer">
<Type>Frontier.UnitTest.WebApplicationInstaller</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).Populate())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).Populate())  
  return ##class(Frontier.UnitTest.Util).CreateWebApplication()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Class).%KillExtent())
  $$$QuitOnError(##class(Frontier.UnitTest.Fixtures.Student).%KillExtent())  
  return ##class(Frontier.UnitTest.Util).RemoveWebApplication()
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Authentication.Manager">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64560,42325.952774</TimeCreated>

<Property name="AuthenticationManager">
<Type>Frontier.Authentication.Manager</Type>
</Property>

<Property name="Request">
<Type>%CSP.Request</Type>
</Property>

<Property name="Response">
<Type>%CSP.Response</Type>
</Property>

<Property name="Session">
<Type>%CSP.Session</Type>
</Property>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Session = ##class(%CSP.Session).%New("t3st1ng")
  set ..Request = ##class(%CSP.Request).%New()
  set ..Response = ##class(%CSP.Response).%New()
  set context = ##class(Frontier.Context).%New(..Session, ..Request, ..Response)
  set ..AuthenticationManager = context.AuthenticationManager  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Request = ""
  set ..Response = ""
  set ..Session = ""
  set ..AuthenticationManager = ""
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestVerify">
<Implementation><![CDATA[
  
  // Skips first and second strategy, assume that the validation criteria wasn't found on each of them.
  set dummyStrategy1 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy1.Behavior = "bypass"
  
  set dummyStrategy2 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy2.Behavior = "bypass"
  
  // Instead, assume that the third input fits the third strategy, thus verifying it.
  set dummyStrategy3 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy3.Behavior = "pass"
  
  do ..AuthenticationManager.AddStrategy(dummyStrategy1)  
  do ..AuthenticationManager.AddStrategy(dummyStrategy2)
  do ..AuthenticationManager.AddStrategy(dummyStrategy3)
  
  set sc = ..AuthenticationManager.Verify(.user)  
  
  // Must not return an error.
  do $$$AssertStatusOK(sc, "allows access")
  
  do $$$AssertTrue(..Response.GetHeader("WWW-Authenticate") = "", "doesn't include the challenge if one strategy works.")
  
  set dummyStrategy4 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  
  // This one should not be called because the manager should bail out after validating using the third strategy.
  do ..AuthenticationManager.AddStrategy(dummyStrategy4)
  
  set sc = ..AuthenticationManager.Verify(.user)
  do $$$AssertStatusOK(sc, "skips pending strategies if one works")
  
  // Now we'll test the failure condition.
  set dummyStrategy3.Behavior = ""
  
  // This is not a verification mismatch, but a true error.
  set sc = ..AuthenticationManager.Verify(.user)
  
  // Validation failed, user should be empty.
  do $$$AssertEquals(user.name, "", "always return an user object even if empty")    
  do $$$AssertStatusNotOK(sc, "returns the last strategy error")
  
  // Header should NOT be set, remember that this is not an user error.
  do $$$AssertTrue(..Response.GetHeader("WWW-Authenticate") = "", "don't output the strategy on error.")
   
  do ..AuthenticationManager.Reset()
    
  // Test the condition where every strategy is bypassed and so it should enforce the first one.
  set dummyStrategy5 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy5.Behavior = "bypass"
  
  set dummyStrategy6 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy6.Behavior = "bypass" 
  
  set dummyStrategy7 = ##class(Frontier.UnitTest.Authentication.DummyStrategy).%New()
  set dummyStrategy7.Behavior = "bypass"  
  
  do ..AuthenticationManager.AddStrategy(dummyStrategy5)
  do ..AuthenticationManager.AddStrategy(dummyStrategy6)
  do ..AuthenticationManager.AddStrategy(dummyStrategy7)
    
  set sc = ..AuthenticationManager.Verify(.user)
  
  do $$$AssertStatusOK(sc, "returns ok if all strategies were skipping")  
  do $$$AssertNotTrue(..AuthenticationManager.Verified, "Verified flag must be 0")  
  do $$$AssertTrue(..Response.GetHeader("WWW-Authenticate") '= "", "outputs the challenge because nothing was provided.")
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Dynamic.Unmarshaller">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>65035,59288.330238</TimeCreated>

<Method name="TestUnmarshalErrors">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Missing.Class", ({ "__id__": 1 }), .i)
  do $$$AssertStatusNotOK(sc, "returns an error if the class doesn't exists")
  do $$$AssertEquals(i, "", "returns null on error")
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", ({ "__id__": "invalid_id" }), .i)
  do $$$AssertStatusNotOK(sc, "imposes the provision of a valid id when __id__ is used")
  
  set o = { 
    "Plate": "TST-002", 
    "Students": [
      { "Name": "Juan", "Enrollment": "2-10-01T12::10.000Z" }
    ]    
  }  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", o, .i)
  do $$$AssertStatusNotOK(sc, "throws a validation error when the property fails to validate")
  do $$$AssertTrue(($System.Status.GetErrorText(sc) [ "Path: <root>.Students.0.Enrollment"), "indicates the failing path")
]]></Implementation>
</Method>

<Method name="CheckStudentsMatch">
<FormalSpec>list:%ListOfObjects</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set allMatch = 0
  
  for i=1:1:list.Count() {
    set instance = ##class(Frontier.UnitTest.Fixtures.Student).%OpenId(list.GetAt(i).%Id())
    if instance '= list.GetAt(i) set allMatch = 0 quit
    else  set allMatch = 1
  }
  return allMatch
]]></Implementation>
</Method>

<Method name="TestUnmarshalPropertyIgnore">
<Implementation><![CDATA[
  set payload = {
    "ignoreme": true
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .student)
  do $$$AssertStatusOK(sc, "doesn't output any error when an unknown property is provided")
  do $$$AssertTrue(($isobject(student) && (student.%Id() = "")), "simply creates a new instance")
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .student,,1)
  do $$$AssertStatusNotOK(sc, "outputs an error if strict mode enabled")
]]></Implementation>
</Method>

<Method name="TestUnmarshalSpecialId">
<Implementation><![CDATA[
  set payload = { "__id__": 1, "Plate": "RS-101" }
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", payload, .class)
  do $$$AssertTrue(($isobject(class) && class.%Id() = 1), "uses the property __id__ to identify to open the instance.")
  do $$$AssertEquals(class.Plate, "RS-101", "edits remaining provided properties allowing updates")
]]></Implementation>
</Method>

<Method name="TestUnmarshalMultiple">
<Implementation><![CDATA[
  &sql(SELECT JSON_ARRAYAGG(JSON_OBJECT('__id__':ID)) into :p FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  set payload = {}.%FromJSON(p)
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .students)
  do $$$AssertTrue(##class(Frontier.Types).IsCollection($classname(students)), "returns a collection")
  do $$$AssertTrue($isobject(students.GetAt(1)) && students.GetAt(1).%IsA("Frontier.UnitTest.Fixtures.Student"), "where each is a student")  
  
  do $$$AssertTrue(..CheckStudentsMatch(students), "and are instance equivalent")
]]></Implementation>
</Method>

<Method name="TestUnmarshalChildrenCollectionIds">
<Implementation><![CDATA[
  &sql(SELECT JSON_ARRAYAGG(JSON_OBJECT('__id__':ID)) into :p FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  set payload = {}.%FromJSON(p)
  
  set payload = {
    "Plate": "EG-402",
    "Students": (payload)
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", payload, .class)
  do $$$AssertTrue(..CheckStudentsMatch(class.Students), "can assign items by their existing ids using __id__")
  
  &sql(SELECT JSON_ARRAYAGG(ID) into :p FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)
  set payload = {}.%FromJSON(p)
  
  set payload = {
    "Plate": "EG-402",
    "Students": (payload)
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", payload, .class)
  do $$$AssertTrue(..CheckStudentsMatch(class.Students), "can assign items by their existing ids using their value")
]]></Implementation>
</Method>

<Method name="TestUnmarshallStreamProperty">
<Implementation><![CDATA[
  set payload = {
    "Plate": "CS-101",
    "Note": "Computer Science class"
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Class", payload, .class)
  do $$$AssertTrue(##class(Frontier.Types).IsStream($classname(class.Note)), "convert string to stream if property is typed from %Stream.Object")
]]></Implementation>
</Method>

<Method name="TestDatePropertiesNormalization">
<Implementation><![CDATA[
  set payload = {
    "PeriodStart": "08:00",
    "PeriodEnd": "16:00:00",
    "Enrollment": "2001-10-01T14:00:12.345Z",
    "LastPresentDate": "12/04/2006"
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .student)
  do $$$AssertEquals($zt(student.PeriodStart), "08:00:00", "can normalize using property normalization")
  do $$$AssertEquals(student.PeriodEnd, $zth("16:00:00"), "convert to internal value")
  do $$$AssertEquals(student.Enrollment, "2001-10-01 14:00:12.345", "can also normalize timestamps")
  do $$$AssertEquals($zd(student.LastPresentDate, 4), "12/04/2006", "respects FORMAT property")
]]></Implementation>
</Method>

<Method name="TestUnmarshalAndBoolean">
<Implementation><![CDATA[
  set payload = {
    "Class": null,
    "Active": true
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .student)
  do $$$AssertEquals(student.Class, "", "null is treated as empty")
  do $$$AssertEquals(student.Active, 1, "true is treated as 1")
  
  set payload = {
    "Active": false
  }
  
  set sc = ##class(Frontier.Dynamic.Unmarshaller).Unmarshal("Frontier.UnitTest.Fixtures.Student", payload, .student)
  do $$$AssertEquals(student.Active, 0, "false is treated as 0")
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Router">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64499,42651.978954</TimeCreated>

<Parameter name="TESTSERVER">
<Default>localhost</Default>
</Parameter>

<Parameter name="TESTSERVERPORT">
<Default>57772</Default>
</Parameter>

<Property name="Request">
<Type>%Net.HttpRequest</Type>
</Property>

<Property name="Class">
<Type>Frontier.UnitTest.Fixtures.Class</Type>
</Property>

<Property name="Student">
<Type>Frontier.UnitTest.Fixtures.Student</Type>
</Property>

<Property name="WebApplicationName">
<Type>%String</Type>
<InitialExpression>$e(##class(Frontier.UnitTest.WebApplicationInstaller).#NAME, 2, *)</InitialExpression>
</Property>

<Property name="Agent">
<Type>Forgery.Agent</Type>
</Property>

<Method name="OnBeforeAllTests">
<PublicList>%session</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(Frontier.UnitTest.Fixtures.Student).%DeleteExtent()
  do ##class(Frontier.UnitTest.Fixtures.Class).%DeleteExtent()

  do ##class(Frontier.UnitTest.Fixtures.Student).Populate()
  do ##class(Frontier.UnitTest.Fixtures.Class).Populate()

  &sql(SELECT TOP 1 ID INTO :classId FROM FRONTIER_UNITTEST_FIXTURES.CLASS)
  &sql(SELECT TOP 1 ID INTO :studentId FROM FRONTIER_UNITTEST_FIXTURES.STUDENT)

  set ..Class = ##class(Frontier.UnitTest.Fixtures.Class).%OpenId(classId)
  set ..Student = ##class(Frontier.UnitTest.Fixtures.Student).%OpenId(studentId)
  set ..Agent = ##class(Forgery.Agent).%New()

  set %session = ##class(%CSP.Session).%New("t3st1ng")

  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterAllTests">
<PublicList>%session</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill %session
  do ##class(%File).RemoveDirectoryTree(..GetTestDirectory("../fixtures"))
  return $$$OK
]]></Implementation>
</Method>

<Method name="AssertRequest">
<FormalSpec>resource:%String,expected:%DynamicAbstractObject="",method:%String="GET",payload:%DynamicAbstractObject="",authHeader:%String="Basic Zm9vOmJhcg==",contentType:%String="text/plain"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  // Default authHeader is Basic foo:bar. Refer to the ValidateCredentials method defined in the Frontier.UnitTest.Router class.
  // There's also an admin:admin account that is used to simulate scope usage.
  set sc = ..Agent.Request({
    "url": (resource),
    "method": (method),
    "data": (payload),
    "headers": {
      "Authorization": (authHeader),
      "Content-Type": (contentType)
    }
  }, .response)

  $$$QuitOnError(sc)

  set responseText = response.Read()
  set expectedText = expected

  set firstByte = $extract(responseText)

  if $extract(firstByte)?1(1"{",1"[") {
    set response = ##class(%DynamicObject).%FromJSON(responseText)
    if $isobject(response) {
      if ##class(Frontier.Types).IsDynamicObject(response) && (response.errors '= ""){
        return ##class(Frontier.UnitTest.Util).MergeErrors(response.errors)
      } elseif ##class(Frontier.Types).IsDynamic($classname(expected)) {
        $$$QuitOnError(##class(Frontier.Dynamic.Serializer).SerializeToStream(.str, expected))
        set expectedText = str.Read()
      }
    }
  }
  if responseText '= expectedText {
    return $$$ERROR($$$GeneralError, $$$FormatText("The received content mismatches with the expected one: %1%2 '= %3%4", $c(10,13), responseText, $c(10,13), expectedText))
  }

  return $$$OK
]]></Implementation>
</Method>

<Method name="TestGETRouteParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1route-params/%2", ..WebApplicationName, ..Class.%Id())
  do ##class(Frontier.Dynamic.Marshaller).MarshalDirect(..Class, .expected)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRouteParamsWhereId">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1route-params/%2/students/%3", ..WebApplicationName, ..Class.%Id(), ..Student.%Id())
  do ##class(Frontier.Dynamic.Marshaller).MarshalDirect(..Student, .expected)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETOneQueryParameter">
<Implementation><![CDATA[
  set expected = { "result": "hello" }
  set resource = $$$FormatText("%1query-params?msg=%2", ..WebApplicationName, "hello")
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRestParametersSum">
<Implementation><![CDATA[
  set expected = { "result": 60 }
  set resource = $$$FormatText("%1rest-params?n1=10&n2=20&n3=30", ..WebApplicationName)
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTMixedRestParametersSum">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/rest?n1=10&n2=20&msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"sum":30,"data":{"username":"xyz","password":"xyz"},"params":["10","20"],"msg":"hello"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTUnmarshalToClass">
<Implementation><![CDATA[

  &sql(SELECT TOP 1 CAST(ID + 1 as VARCHAR) INTO :classId FROM FRONTIER_UNITTEST_FIXTURES.CLASS ORDER BY ID DESC)

  set resource = $$$FormatText("%1unmarshal", ..WebApplicationName)
  set payload = {"Plate": "R-101-3", "Students": [(..Student.%Id())]}
  set expected = {"ok": 1, "__id__": (classId)}
  set result = ..AssertRequest(resource, expected, "POST", payload)

  return $$$AssertStatusOK(result, $$$FormatText("can unmarshal the payload data to the expected result when POST'ing to %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single-object", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTObjectPayloadQueryParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/object-with-query-params?msg=hello", ..WebApplicationName)
  set payload = {"username":"xyz","password":"xyz"}
  set expected = {"msg":"hello","payload":(payload)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadSingle">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1payload/single-array", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = payload
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTArrayPayloadQueryParams">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/array-with-query-params?msg=hello", ..WebApplicationName)
  set payload = [{"password":"xyz","username":"xyz"}]
  set expected = ["hello",(payload)]
  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", payload), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTInvalidPayload">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1payload/invalid", ..WebApplicationName)
  set payload = [{"username":"xyz","password":"xyz"}]
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */, "POST", payload), "returns an error if more than one payload is formally expected")
]]></Implementation>
</Method>

<Method name="TestGETInvalidRestSequence">
<Implementation><![CDATA[
  set resource =  $$$FormatText("%1rest-params?n1=&n4=10", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if rest argument index is not sequential")
]]></Implementation>
</Method>

<Method name="TestGETUnspecifiedArgument">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1query-params?unknown=1", ..WebApplicationName)
  return $$$AssertStatusNotOK(..AssertRequest(resource, "" /* we're expecting an error */), "returns an error if an unknown argument is provided")
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicObject">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/object?class=1", ..WebApplicationName)
  do ##class(Frontier.Dynamic.Marshaller).MarshalDirect(..Class, .class)
  set expected = {"class":(class)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETMixedDynamicArray">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1mixed/array?class=1", ..WebApplicationName)
  set sc =  ##class(Frontier.Dynamic.Marshaller).MarshalDirect(..Class, .class)
  set expected = [ (class) ]
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRawMode">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1raw", ..WebApplicationName)
  set expected = "hello raw response"
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETStream">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1stream", ..WebApplicationName)
  set expected = {"content":"This line is from a stream."}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETAliasedQueryParameter">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1alias?aliased_key=whatever", ..WebApplicationName)
  set expected = {"result":"whatever"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETDynamicSQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/dynamic", ..WebApplicationName)

  set sd = ##class(%SQL.Statement).%New()
  set sd.%SelectMode = 2
  do sd.%Prepare("SELECT *, %VID as Index FROM (SELECT * FROM FRONTIER_UNITTEST_FIXTURES.STUDENT) WHERE %VID BETWEEN ? AND ?")
  set mt = sd.%Metadata
  set rd = sd.%Execute(1, 5)

  set sc = ##class(Frontier.SQL.Serializer).SerializeToStream(.s, rd, mt)
  set array =  {}.%FromJSON(.s)
  set expected = {"results":(array)}

  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETQuerySQLResult">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1sql/query", ..WebApplicationName)

  set sd = ##class(%SQL.Statement).%New()
  set sd.%SelectMode = 2
  do sd.%PrepareClassQuery("Frontier.UnitTest.Fixtures.Student", "PaginatedStudents")
  set mt = sd.%Metadata
  set rd = sd.%Execute(1, 5)

  set sc = ##class(Frontier.SQL.Serializer).SerializeToStream(.s, rd, mt)
  set array =  {}.%FromJSON(.s)
  set expected = {"results":(array)}
  return $$$AssertStatusOK(..AssertRequest(resource, expected.%ToJSON()), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETSessionUserInfo">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1user-info", ..WebApplicationName)
  set expected = {"login":"foo"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRouteParameterNotSpecified">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/A/1/route-parameter-not-specified", ..WebApplicationName)
  set expected = {"error":{"internalCode":5001,"message":"Route parameter 'param1' was not specified as an argument in the method 'TestGETRouteParameterNotSpecified'."},"responseCode":500}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETPassRouteParamToChild">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/A/hello-from-parent/pass-route-param-to-child", ..WebApplicationName)
  set expected = {"result":"hello-from-parent"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETPrioritizeRouteParameter">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/A/hello-from-route/prioritize-route-parameter?param1=hello_from_query", ..WebApplicationName)
  set expected = {"result":"hello-from-route"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETRouteWithoutParameters">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/C/", ..WebApplicationName)
  set expected = {"result":"Hello from a simple but mapped route!"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETScopedResponse">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/C/scoped", ..WebApplicationName)
  set expected = {"result":"Hello admin! If you're seeing this, then you have enough privilege for that!"}
  do $$$AssertStatusNotOK(..AssertRequest(resource, expected), $$$FormatText("can NOT retrieve the expected data from the resource %1 because it's scoped", resource))
  return $$$AssertStatusOK(..AssertRequest(resource, expected,,,"Basic "_$System.Encryption.Base64Encode("admin:admin")), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETBypassAuth">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/C/auth/bypass", ..WebApplicationName)
  set expected = {"result":"This is an unprotected resource!"}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETParentSparseParams">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/D/5/fixed/3/parent-sparse-params/sum", ..WebApplicationName)
  set expected = {"result":8}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETParentRegexParameter">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1map/E/match/get-parent-and-this-group", ..WebApplicationName)
  set expected = ["match", "this", "group"]
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("can retrieve the expected data from the resource %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETNoWeakTypedArgs">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1arguments/no-weak-typed", ..WebApplicationName)
  set expected = {"error":{"internalCode":5001,"message":"The following arguments are missing the type definition: b, c."},"responseCode":500}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("blocks attempts to call methods with weak typed args", resource))
]]></Implementation>
</Method>

<Method name="TestGETNoWeakTypedMethods">
<Implementation><![CDATA[
  set resource = $$$FormatText("%1methods/no-weak-typed", ..WebApplicationName)
  set expected = {"error":{"internalCode":5001,"message":"Expected a return type for method TestGETNoWeakTypedMethods."},"responseCode":500}
  return $$$AssertStatusOK(..AssertRequest(resource, expected), $$$FormatText("blocks attempts to call methods without return types.", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTFileUpload">
<Implementation><![CDATA[
  set filePath = ##class(%File).NormalizeFilename(
    ##class(Port.Configuration).GetWorkspace("frontier")_"/"_
    "cls/Frontier/Router.cls"
  )
  set file = ##class(%File).%New(filePath)
  do file.Open("RS")

  set stream = ##class(%CSP.CharacterStream).%New()
  do stream.CopyFrom(file)
  set stream.FileName = file.Name

  set resource = $$$FormatText("%1upload/multi", ..WebApplicationName)
  set expected = ""

  set payload = {
    "file_a": (stream),
    "file_b": (stream)
  }

  return $$$AssertStatusOK(..AssertRequest(resource, expected, "POST", .payload,, "multipart/form-data"), $$$FormatText("can handle multipart uploads", resource))
]]></Implementation>
</Method>

<Method name="TestPOSTSingleFileUpload">
<Implementation><![CDATA[
  set filePath = ##class(%File).NormalizeFilename(
    ##class(Port.Configuration).GetWorkspace("frontier")_"/"_
    "cls/Frontier/Router.cls"
  )

  set file = ##class(%File).%New(filePath)
  do file.Open("RS")

  set resource = $$$FormatText("%1upload", ..WebApplicationName)
  set expected = ""

  set submmitted = file.Name
  set expectation = ..GetTestDirectory("../fixtures/uploads/single/file.txt")

  return $$$AssertStatusOK(..AssertRequest(resource, "", "POST", file,,"text/plain"), $$$FormatText("can upload a single file %1", resource))
]]></Implementation>
</Method>

<Method name="TestGETStaticFile">
<Implementation><![CDATA[
  for i = "README.md", "LICENSE.md", "CONTRIBUTING.md" {
    set filePath = ##class(%File).NormalizeFilename(##class(Port.Configuration).GetWorkspace("frontier")_"/"_i)
    set file = ##class(%Stream.FileCharacter).%New()
    set file.TranslateTable = "UTF8"
    do file.LinkToFile(filePath)
    set resource = $$$FormatText("%1public/%2", ..WebApplicationName, i)
    do $$$AssertStatusOK(..AssertRequest(resource, file.Read(), "GET"), "can fetch file from "_resource)
    set file = ""
  }
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Frontier.Types">
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64502,35612.05458</TimeCreated>

<Method name="TestIsDataType">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%Library.String"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDataType("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%String"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDataType("%ZEN.Datatype.boolean"), "can resolve deep inheritances (custom datatypes)")
]]></Implementation>
</Method>

<Method name="TestIsStream">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.Object"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsStream("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsStream("%Stream.GlobalCharacter"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsSerial">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%Library.SerialObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("%Library.RegisteredObject"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSerial("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%SerialObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsSerial("%ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsCollection">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Collection.AbstractIterator"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsCollection("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%ListOfDataTypes"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsCollection("%Library.ArrayOfDataTypes"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsPersistent">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Library.Persistent"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsPersistent("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Persistent"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsPersistent("%Dictionary.ClassDefinition"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsInstantiable">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%Library.RegisteredObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsInstantiable("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%RegisteredObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsInstantiable("%ZEN.proxyObject"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamic">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%Library.DynamicAbstractObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamic("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicObject"), "can resolve omitted %Library packages")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamic("%DynamicArray"), "can resolve deep inheritances")
]]></Implementation>
</Method>

<Method name="TestIsDynamicArray">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%Library.DynamicArray"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicArray("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicArray("%DynamicArray"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsDynamicObject">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%Library.DynamicObject"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsDynamicObject("Invalid"), "returns 0 if invalid")
  do $$$AssertTrue(##class(Frontier.Types).IsDynamicObject("%DynamicObject"), "can resolve omitted %Library packages")
]]></Implementation>
</Method>

<Method name="TestIsSQLProvider">
<Implementation><![CDATA[
  do $$$AssertTrue(##class(Frontier.Types).IsSQLProvider("Frontier.SQL.Provider"), "returns 1 if true")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("%String"), "returns 0 if false")
  do $$$AssertNotTrue(##class(Frontier.Types).IsSQLProvider("Invalid"), "returns 0 if invalid")
]]></Implementation>
</Method>
</Class>


<Routine name="frontier" type="INC"><![CDATA[
#include %ZEN.Utils
#include %occErrors

#define ltrim(%str)       $zstrip(%str, "<W")
#define rtrim(%str)       $zstrip(%str, ">W")
#define trim(%str)        $zstrip(%str, "<>W")
#define trimQuote(%str)   $zstrip(%str, "<>", $c(34))
#define IsSQLQuery(%str)  ($$$ucase($extract($$$trim(%str), 6)) = "SELECT")
#define KeyGroup(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "=>N")
#define KeyIndex(%requestKey)  $zstrip($zstrip(%requestKey, "<=N"), "<=A")
#define FormatBoolean(%value) $case(%value, 1: "true", 0: "false", : %value)
#define BooleanToBinary(%value) $case(%value, "true": 1, "false": 0, : %value)
#define NormalizeClassName(%cn) if $l(%cn, ".") = 1 && ($e(%cn) = "%") set %cn = "%Library."_$e(%cn, 2, *)
#define OSSlash $case($$$isWINDOWS, 1: "\", : "/")
#define AssertClassExists(%o) return:'$isobject(%o) $$$ERROR($$$ClassDoesNotExist, %o)
#define NULL $s($$$isWINDOWS : "//./nul", 1: "/dev/null")
#define ObjectOrNull(%obj) $select($isobject(%obj) : %obj, 1: "null")
]]></Routine>


<Project name="frontier" LastModified="2019-08-13 09:27:09.866402" Target="##class(Frontier.UnitTest.Router).T()" TargetType="2" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="Frontier.AbstractSerializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.ArgumentDescription" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.BasicStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.BearerStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.CookieStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Authentication.Strategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.CORS" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Context" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Marshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Serializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Dynamic.Unmarshaller" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Exception" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Files" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Files.Uploader" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Method" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter.CamelCase" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.PropertyFormatter.SnakeCase" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter.Log" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Reporter.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.InlineQueryBuilder" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.Provider" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SQL.Serializer" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Map" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Route" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Routes" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Schema.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Security.CookieSignature" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.SessionEvents" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Shared.Utilities" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Authentication.DummyStrategy" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Class" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Fixtures.Student" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router.Map.A" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router.Map.B" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router.Map.C" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router.Map.D" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Router.Map.E" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Frontier.UnitTest.WebApplicationInstaller" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Authentication.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Dynamic.Unmarshaller" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Router" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Frontier.Types" type="CLS"></ProjectItem>
    <ProjectItem name="frontier.INC" type="MAC"></ProjectItem>
  </Items>
  <BreakPoints>
    <BreakPoint Routine="Frontier.Router.CLS" Offset="DispatchRequest+24"></BreakPoint>
    <BreakPoint Routine="Frontier.SQL.InlineQueryBuilder.CLS" Offset="CreateWHEREStatement+2"></BreakPoint>
    <BreakPoint Routine="Frontier.SQL.InlineQueryBuilder.CLS" Offset="TransformFilter+4"></BreakPoint>
  </BreakPoints>
  <WatchVariables>
    <WatchVariable Variable="urlExpression" Pane="1"></WatchVariable>
  </WatchVariables>
</Project>
</Export>
